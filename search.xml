<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TAURI에 대한 개인적인 견해</title>
      <link href="/2023/12/13/tauri-story/"/>
      <url>/2023/12/13/tauri-story/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2023/12/13/tauri-story/tauri-story-cover.png" alt="tauri-story-cover"></p><p>잠시 시간적 여유가 있어서 이번 기회에 그동안 해보고 싶던 <code>TAURI</code>를 접해보기로 했다. 개념적으로만 알고 있던 TAURI를 실제로 사용해 보기 위해 만들 애플리케이션을 구상하였고 디자인하고 결과물을 만들었으며, 이 과정에서 내가 느낀 TAURI를 기록해 보고자 한다.</p><p>필자가 만든 앱은 <a href="https://github.com/kdydesign/nvm-desk">nvm desktop 버전</a>이며, 현재는 window 버전만 지원하도록 하였다. 이 프로그램은 80% 정도 진행된 상태에서 TAURI에 대해 글을 쓰고자 잠시 개발을 멈추고 이 포스팅을 작성하였다.</p><p>참고로 이번 포스팅은 TAURI에 대한 기술적 내용을 전달하기보다는 매우 주관적으로 내가 TARUI를 쓰고 느낀 바를 얘기해 보려고 하니 이 점은 참고하기를 바란다.</p><h1 id="Electron과의-차이"><a href="#Electron과의-차이" class="headerlink" title="Electron과의 차이"></a>Electron과의 차이</h1><p>TAURI의 장점은 Javascript 및 Vue, React와 같은 Framework를 사용하여 윈도우, 맥, 리눅스의 애플리케이션을 만들 수 있다는 것이다. 이 부분은 Electron과 동일하지만 차이점이라면 <code>안정성</code>에 있다. 이 안정성을 가져가기 위해서 TAURI는 <code>Rust를 채택</code>하였다. 이 부분이 Electron과의 다른 점이다. Electron은 Node.js 런타임을 기반으로 동작하기 때문에 안정성 측면에서는 부족한 편이다. <code>ContextBridge</code> 와 같은 API를 사용하여 프로세스 간 분리를 하지만 TAURI는 애초부터 Rust로 구분을 지었다. 알다시피  Rust는 안정성 측면에서는 매우 우수하다. 이외에 TAURI의 장점은 Electron에 비해 빌드 후 설치파일의 적은 용량과 속도로 볼 수 있다.</p><h1 id="Rust를-모른다면…"><a href="#Rust를-모른다면…" class="headerlink" title="Rust를 모른다면…"></a>Rust를 모른다면…</h1><p>TAURI를 처음 사용해 보는 것이기 때문에 Electron을 처음 접할 때와 마찬가지로 생소하다. 하지만 개발하는 꾸준히 진행하는 과정에서 일단 <code>Rust</code>에서 막혔다. 내가 Rust를 잘 모르기 때문인데, TAURI 자체도 생소하지만, Rust까지 커버하기 위해서는 많은 시간이 필요해 보였다. Front 쪽이야 게 눈 감추듯 개발을 진행하지만, System의 설정과 메뉴, 로그 등 시스템 측면에서 처리되어야 할 비즈니스 루틴들을 Rust로 구현하기가 여간 어려운 게 아니었다. 이 말인즉, TRAUI는 Rust를 모른다면 매우 러닝 커브가 크다는 말이다.</p><p>시스템 애플리케이션을 만들겠다는 목적 자체가 시스템 자원을 사용해야 하는데 Rust를 모른다면 차라리 웹으로 만드는 것이 낫다고 생각한다. 물론 Rust를 알고 있다면 시도해 볼 만하다.</p><h1 id="출시된-지-얼마-되지-않았지만…"><a href="#출시된-지-얼마-되지-않았지만…" class="headerlink" title="출시된 지 얼마 되지 않았지만…"></a>출시된 지 얼마 되지 않았지만…</h1><p>TAURI는 2019년에 출시되고 2022년도에 정식 릴리즈된 따끈따끈한 기술이다. 그렇기 때문에 커뮤니티가 매우 적고 정보 역시 적다. 필자도 개발하면서 산 넘어서 산이었다. 어떤 문제를 접하여 이를 해결하기 위해 github 등 모든 곳을 뒤져도 정보를 찾기 힘들었다. 거의 80% 개발이 다 된 상태에서 이 글을 쓰는 이유도 여기에 있다. 또한 공식 문서의 API가 조금씩 다르다는 것이다. github의 이슈에서 찾은 내용 몇 가지를 보고 해결한 후 문서를 다시 보면 전혀 기록되어 있지 않다. 그리고 제일 큰 문제는 제목대로 출시된 지 얼마 되지 않았고 릴리즈 버전은 1. x인데 벌써 2.x 버전의 알파 버전이 출시되었다. 크루 내부적인 문제도 있겠거니 생각하지만 불과 1~2년 만에 2버전을 출시하는 것은 Core에 수정될 수 없는 큰 결함이 있을 수 있다는 생각도 든다. 안정성을 추구하며 Rust를 사용하지만, 만약 수정이 불가피한 결함이 있다면 참 아이러니한 상황인 듯하다. 개인적으로 2.x 버전을 준비하느라 1.x 버전에 대해 소홀한 게 아닌가 싶기도 하다.</p><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>필자는 업무적으로도 Electron을 사용하여 배포까지 해보았고 지금에서야 개인적으로 진행하는 프로젝트에 TAURI를 반영하여 적용해 보았다. 이 프로젝트는 80% 정도 완성되었지만, 다시 Electron으로 포팅해야겠다고 생각한다. NSIS, 시스템 제어 등의 기능들을 이 적은 정보로 TAURI로 계속 개발해 나갈 수 없을 것 같다. 물론 TAURI가 나쁘다는 것은 아니다. 필자가 Rust의 지식이 부족해서 그럴 수 있기 때문이다. 하지만 누군가에게 조언하자면 지금 전반적인 상황을 본다면 당분간은 Electron으로 개발하는 것이 좋다고 조언해 줄 것이다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> tauri </category>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> rust </tag>
            
            <tag> tauri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>차세대 번들러 Vite! 개념은 알고 넘어가자!</title>
      <link href="/2023/11/24/vite-tutorial/"/>
      <url>/2023/11/24/vite-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2023/11/24/vite-tutorial/vite-tutorial-cover.png" alt="vite-tutorial-cover"></p><p>이 포스팅을 보기 전에 <a href="https://kdydesign.github.io/2023/10/08/module-system-bundler/">Javascript 모듈 시스템과 모듈 번들러의 이해</a> 글을 먼저 보기를 권장한다. Vite를 알기 전에 왜 Vite와 같은 빠른 번들러가 지속적으로 출시되는지 알게 된다면 Vite를 이해하는 데 도움이 될 것으로 생각한다.</p><p>위 포스팅을 요약하자면,</p><p>과거 웹 서비스의 용도는 정보를 전달하는 데 있었기에 그 규모와 복잡도가 낮아 자바스크립트의 모듈화가 필요하지 않았다. 단순하게 순차적 로드 방식으로 자바스크립트를 로드하기만 하면 되었지만, 점차 웹 서비스의 규모가 커지면서 복잡도도 향상되었다. 이에 비례하여 개발&#x2F;관리되어야 하는 자바스크립트의 파일들이 많아지면서 <code>Commonjs</code>, <code>AMD</code>, <code>UMD</code>, <code>ESM</code>과 같은 모듈 시스템이 등장하게 되었다. 많은 기술들의 등장으로 자바스크립트가 모듈화되어 파일의 개수와 규모는 간소해졌지만 수많은 종속된 모듈들이 증가하면서 이에 따라 모듈의 효율성을 높기 위한 도구로 <code>webpack</code>, <code>rollup</code>, <code>parcel</code>과 같은 번들러가 출시되었다. 하지만 이런 번들러들도 커지는 프로젝트 규모를 감당하기 힘든지 성능적인 문제들이 발생하기 시작하였고 이를 해결하고자 Native 번들러가 출시되기 시작한다.</p><hr><p><a href="https://kdydesign.github.io/2023/10/08/module-system-bundler/">Javascript 모듈 시스템과 모듈 번들러의 이해</a> 포스팅에 이어서 이번 포스팅에서는 <code>Vite</code>에 대해 알고 넘어가려고한다. 해당 포스팅에서는 문법과 같은 기술적인 측면보다는 Vite가 무엇이 왜 Vite와 같은 번들러가 출시되는지 관련된 동향과 함께 개념적으로 파악해보고자 한다.</p><h1 id="Native-Bundler"><a href="#Native-Bundler" class="headerlink" title="Native Bundler"></a>Native Bundler</h1><p>Vite를 설명하기 전에 먼저 알아야 할 것은 Native Bundler이다.</p><p>결과적으로는 개발 생산성은 번들러로 인해 과거보다 증가하였지만, 웹 기술과 다양한 프레임워크의 등장, 그리고 증가하는 모듈과 애플리케이션의 규모에 따라 결국 다시 개발 생산성은 저하되는 아이러니한 상황이 발생한다.</p><p>애플리케이션의 기술 발전과 처리되어야 하는 Javascript 모듈의 개수가 늘어남에 따라 번들링의 성능도 향상이 되어야 하며, 캐싱 및 최적화 작업으로 인하여 개선된 성능이지만 대규모 종속성 크롤링으로 인한 개발 서버의 속도(dev-server)가 저하된다. 또한 종속된 모듈이 많을수록 개발 서버의 가동 시간과 HMR(Hot Module Replacement)의 시간이 증가하며, 다양한 프레임워크가 출시되면서 이를 지원하기 위해 번들러의 설정이 복잡해지고 있다.</p><p>이러한 문제점을 해결하기 위해 Native의 성능을 자랑하는 <a href="https://esbuild.github.io/">esbuild</a>와 같은 Native Bundler가 탄생하게 되었다.</p><p>현재까지 출시된 많은 번들러들은 대부분이 Node.js 기반으로 작성된 번들러이다. 이와 다르게 <code>Native Bundler</code>는 <code>Go</code> 또는 <code>Rust</code>와 같은 <strong>Native 언어를 기반으로 둔 번들러</strong>이며, 이에 따라 기존 번들러와 차별되는 성능을 보인다. Vite의 기반인 esbuild 역시 Go 언어로 작성되었으며, SWC의 경우 Rust 기반으로 작성되었다. 이 Native의 또 다른 의미로는 Node.js가 아니기 때문에 싱글 쓰레드인 Node.js와 다르게 멀티 스레드 환경에서 동작하기 때문에 이 또한 기존 번들러와 성능적 차이를 보이는 요인 중 하나이다.</p><p><img src="/2023/11/24/vite-tutorial/esbuild-performance.png" alt="esbuild"></p><h2 id="번들러로서의-역할"><a href="#번들러로서의-역할" class="headerlink" title="번들러로서의 역할"></a>번들러로서의 역할</h2><p>Native 번들러는 기존 번들러와 성능적인 차별화는 있지만 번들러로서의 역할이 부족하다. 번들러로서의 조건은 빠른 성능만이 아니다. 개발 서버 구동, Sass와 Less, Stylus 등 표준이 아닌 기술들을 실행하고 변환할 수 있는 기능과 같은 기존 번들러들이 제공되는 기능 즉, <code>Dev-Server</code>, <code>Loader</code>, <code>Transpile</code>, <code>Code-Splitting</code>, <code>Tree Shaking</code>, <code>HMR</code>과 같은 기능 지원이 미비하다.</p><p>이를 보완하고자 esbuild 기반으로 빠른 성능의 장점과 Rollup의 번들러로서의 기능을 제공하는 <a href="https://ko.vitejs.dev/">Vite</a>가 등장한다.</p><hr><h1 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h1><p><code>Vite</code>는 빠르고 간결한 모던 웹 프로젝트 개발 경험에 초점을 맞춰 탄생한 빌드 도구로 개발 경험을 개선하여 <strong>속도와 성능에 중점을 둔 번들러</strong>이다.</p><p>Vite에서 제공하는 사전 번들링은 Go로 작성되어있는 <code>esbuild</code>를 사용하고 있기 때문에 Webpack, parcel과 같은 기존 번들러보다 <strong>10~100배 빠른 속도를 제공</strong>한다. 그리고 번들링 시 Rollup을 기반으로 다양한 빌드 커맨드를 사용하여 개발 경험을 높여준다.</p><h2 id="Vite의-특징"><a href="#Vite의-특징" class="headerlink" title="Vite의 특징"></a>Vite의 특징</h2><p>Vite는 ESM 및 Native 언어를 통해서 기존 Javascript 기반의 번들러의 문제점을 해결했다.</p><p>Native ESM 지원으로 별도의 번들링 없이 개발 서버를 실행할 수 있으며, ESM이기 때문에 별도의 변환 작업 없이 브라우저에 직접적으로 제공하며, esbuild를 통해 종속성 모듈을 사전 번들링하여 개발 서버의 성능을 향상 시킨다. 또한 preload 스텝을 이용한 병렬적(Parallel)으로 모듈을 로드하기 때문에 빌드에 최적화되어 있다.</p><p>요약하자면,</p><div class="alert info no-icon"><ul><li>Native ESM 지원으로 별도의 번들링 없이 개발 서버 실행 및 브라우저 직접 제공</li><li>esbuild를 통해 종속성 모듈을 사전 번들링</li><li>preload 스텝을 이용한 병렬적(Parallel)으로 모듈을 로드하여 빌드의 최적화</li></ul></div><p><strong>비동기 방식 모듈 로드 최적화</strong><br><img src="/2023/11/24/vite-tutorial/async-chunk.png" alt="async-chunk-loading-optimization"></p><p><strong>병렬처리</strong><br><img src="/2023/11/24/vite-tutorial/parallel-processing.png" alt="parallel-processing"></p><h2 id="기존-번들러의-문제점-해결"><a href="#기존-번들러의-문제점-해결" class="headerlink" title="기존 번들러의 문제점 해결"></a>기존 번들러의 문제점 해결</h2><p>Vite는 기존 번들러의 단점인 느린 피드백 루프에 초점을 맞춰 브라우저에서 지원하는 ESM 및 Natvie 언어로 작성되어 기존 문제점을 해결하였다.</p><h3 id="Dev-Server의-성능-저하"><a href="#Dev-Server의-성능-저하" class="headerlink" title="Dev-Server의 성능 저하"></a>Dev-Server의 성능 저하</h3><p>Javascript 번들러의 개발 서버 구동은 코드-스타트 방식(최초로 실행되어 이전에 캐싱한 데이터가 없는 경우)으로 애플리케이션 내의 모든 소스 코드에 대해 크롤링, 종속성 그래프를 생성하였고 빌드 작업이 끝나야만 실제로 페이지를 제공하였기 때문에 서버의 구동 시간이 오래 걸렸다. 이것은 애플리케이션의 규모가 커짐에 따라 비례하여 증가하기 때문에 규모가 클수록 더욱 느리다.</p><p>Vite는 이를 두 가지 방안으로 나누어 개발 서버의 성능 향상시켰다.</p><blockquote><p><strong>Dependencies(종속성)의 사전 번들링</strong><br>기존 번들러는 수백개에 이르는 종속된 Javascript 모듈을 비효율적으로 번들링하였고 이로 인해 많은 시간을 소모하였다. Vite의 경우 esbuild를 통해 종속된 모듈을 사전에 번들링하여 webpack, parcel 대비 10-100배 빠르도록 설계되었다.</p></blockquote><blockquote><p><strong>Native ESM을 이용한 소스 코드 제공</strong><br>Vite는 브라우저와 Node.js가 이해할 수 있는 Native ESM으로 소스 코드를 제공하기 때문에 별도의 컴파일링 없이 브라우저를 번들러로 사용하였기 때문에 성능적으로 향상되었다.</p></blockquote><h3 id="HMR-Hot-Module-Replacement-의-성능-저하"><a href="#HMR-Hot-Module-Replacement-의-성능-저하" class="headerlink" title="HMR(Hot Module Replacement)의 성능 저하"></a>HMR(Hot Module Replacement)의 성능 저하</h3><p>Javascript 번들러는 소스 코드를 업데이트하게 되면 번들링 과정을 다시 걸쳤으며, 이로 인해서 애플리케이션의 규모에 비례하여 HMR 속도도 저하되었다. 이에 반면 Vite의 경우 특정 모듈이 수정될 경우 ESM을 이용하여 수정된 부분만 교체 후 브라우저에서 해당 모듈을 요청하면 변경된 모듈만 전달하고 이과 정을 전부 ESM을 이용하기 때문에 애플리케이션의 규모와 상관없이 일정한 HTML 성능을 유지한다.</p><h2 id="Bundle-Base와-ESM-Base의-차이"><a href="#Bundle-Base와-ESM-Base의-차이" class="headerlink" title="Bundle Base와 ESM Base의 차이"></a>Bundle Base와 ESM Base의 차이</h2><p>Bundle Base의 경우 모든 종속성 모듈을 번들링하지만 Native ESM의 경우에는 경로 기반 검색으로 해당 모듈을 사용해야만 처리한다. 다시 말해, Native ESM 기반의 Dev-Server는 경로 기반으로 현재 화면에서 해당 모듈을 사용해야만 처리하기 때문에 배포에 필요한 번들링이나 HMR 속도가 빠른 것이다.</p><p><img src="/2023/11/24/vite-tutorial/bundle-base-dev-server.png" alt="bundle-base-dev-server"></p><p><img src="/2023/11/24/vite-tutorial/nativeesm-base-dev-server.png" alt="nativeesm-base-dev-server"></p><h2 id="번들러의-비교"><a href="#번들러의-비교" class="headerlink" title="번들러의 비교"></a>번들러의 비교</h2><p>지금도 물론 Webpack의 점유율이 높지만, 점차 급격하게 Vite가 상승하는 것을 확인 할 수 있다.</p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/3523_RC02/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"webpac","geo":"","time":"today 5-y"},{"keyword":"rollup","geo":"","time":"today 5-y"},{"keyword":"parcel","geo":"","time":"today 5-y"},{"keyword":"vite","geo":"","time":"today 5-y"}],"category":31,"property":""}, {"exploreQuery":"cat=31&date=today%205-y&q=webpac,rollup,parcel,vite&hl=ko","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><h2 id="지원-브라우저"><a href="#지원-브라우저" class="headerlink" title="지원 브라우저"></a>지원 브라우저</h2><p>Native ESM 모듈과 Dynamic Import를 지원하는 브라우저를 대상으로 지원한다. 레거시 브라우저는 프로덕션용으로 빌드 시 @vitejs&#x2F;plugin-legacy를 이용하여 지원할 수 있다.</p><p><img src="/2023/11/24/vite-tutorial/support-browser.png" alt="support-browser"></p><h2 id="성능테스트"><a href="#성능테스트" class="headerlink" title="성능테스트"></a>성능테스트</h2><p><code>vue-cli</code>와 <code>Vite</code>를 대상으로 <strong>100개의 컴포넌트</strong>를 기준으로 측정한 성능 테스트이다. 측정 대상은 개발서버 구동 속도, HMR, Build 속도이다. 이 테스트 벤치마킹은 개발 환경과 컴포넌트의 개수에 따라 달라지므로 참고만하도록 하자.</p><table><thead><tr><th></th><th>Dev-Server</th><th>HMR(Hot Module Replacement)</th><th>Build</th></tr></thead><tbody><tr><td>vue-cli</td><td>8초</td><td>0.6초</td><td>8.3초</td></tr><tr><td>vite</td><td>0.6초</td><td>즉시 반영</td><td>4.2초</td></tr></tbody></table><hr><p>지금까지 Vite의 개념적인 내용을 파악해 보았다. </p><p>Vite의 출시로 인해 Frontend 환경의 큰 변화를 가져다주었다. 지금 당장 실무에 반영해도 되겠냐는 의견이 있었다면, 나는 당장이라도 반영하라고 전하고 싶다. 그만큼 좋은 효과를 뽑아낼 수 있을 것이며, 지속적으로 Vite는 안정화되어 가고 있기 때문에 실무에 반영은 고민하지 않아도 된다고 생각한다. 물론 Vite를 반영하기 위해서는 이에 따른 특정 부분에 대한 마이그레이션이 필요하겠지만, Vite 자체로 가져다주는 효과를 생각한다면 충분히 감안해도 될 것이다.</p><p>다음 포스팅은 Vite의 문법과 설정 사항 등의 테크니컬적인 세부 내용을 살펴볼 예정이다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> bundler </category>
          
          <category> vite </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> vite </tag>
            
            <tag> esbuild </tag>
            
            <tag> bundler </tag>
            
            <tag> native esm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 모듈시스템과 모듈번들러의 이해</title>
      <link href="/2023/10/08/module-system-bundler/"/>
      <url>/2023/10/08/module-system-bundler/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2023/10/08/module-system-bundler/module-system-cover.png" alt="module-system-cover"></p><p>22년도에 vite에 관련된 세미나를 진행할 때 vite를 설명하기 전에 Module System과 Bundler를 먼저 설명하였다. 이유는 vite 역시 번들러에 속하며, 번들러가 왜 계속 발전해 오고 있는지 설명하고 vite에 대한 이해를 돕기 위해서이다. 처음 JavaScript 모듈 시스템과 번들러를 설명하고 이어 vite를 설명하려하였지만 이를 두 파트로 나누어 포스팅하려고 한다.</p><p>이 포스트에서는 JavaScript 모듈 방식인 <code>CommonJS</code> 와 <code>AMD</code>, <code>UMD</code>, <code>ESM</code>에 대해 설명하고, Module Bundler에 대해 살펴보려고 한다.</p><h1 id="Module-System"><a href="#Module-System" class="headerlink" title="Module System"></a>Module System</h1><blockquote><p>Module System은 HTML에 JavaScript 원본 소스를 제공하여 순차적으로 로드하는 방식</p></blockquote><p>과거 웹 서비스라 하면 정보를 제공하는 데 그쳤기 때문에 지금처럼 복잡하지도 않았으며 규모 역시 크지도 않았다. 웹 서비스를 구성하는 HTML이나 JavaScript 파일의 크기도 상대적으로 작았기 때문에 서비스를 유지하는 데 큰 무리가 없었다. 하지만 점차 웹 서비스의 규모가 커지고 V8 엔진의 등장으로 다방면으로 JavaScript 활용도도 증가하면서  JavaScript 파일도 많아졌다. <strong>파일의 구조가 복잡해지고 거대해지면서 순차적으로 로드하는 방식은 각 모듈 간 scope가 구분되지 않기 때문에 다른 파일을 오염시키거나 충돌이 일어나는 경우가 발생</strong>했다. 또한 외부 라이브러리가 증가하면서 애플리케이션에 사용하는 모듈의 개수도 증가하게 되었다. </p><p>이렇게 규모와 개발되는 파일의 개수, 그리고 모듈이 증가함으로 인해 모듈화에 대한 필요성이 부각되면서 <code>CommonJS</code>와 <code>AMD</code> 가 등장하게 되었다.</p><p><strong>순차적 모듈의 예시</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;src/A.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;src/B.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;src/C.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;src/D.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="CJS-CommonJS"><a href="#CJS-CommonJS" class="headerlink" title="CJS (CommonJS)"></a>CJS (CommonJS)</h2><blockquote><p>JavaScript를 브라우저에서뿐만 아니라 범용 언어 사용을 목적으로 둔 워킹 그룹</p></blockquote><p>동기적 방식을 사용하고 모든 종속성이 로컬 디스크에 존재하여 바로 사용할 수 있는 환경을 전제로 한다. 과거에 모듈 시스템은 반드시 필요했기 때문에 Node.js는 Common JS 방식의 명세를 채택하고 NPM과 함께 큰 성장을 하였다. 우리가 흔하게 쓰는 방식으로 대표적으로 <code>require</code>를 말할 수 있다.</p><p>동기적 방식은 브라우저에서 필요로 하는 모듈이 모두 다운로드 할 때까지 기다려야 하는 단점과 같은 비동기적 로드를 고려하지 않은 설계로 인해 브라우저에서의 사용에는 한계가 있기 때문에 Node.js의 서버 사이드 환경에서 용이하다.</p><p><strong>CJS 방식의 예</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//importing </span><br><span class="hljs-keyword">const</span> doSomething = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./doSomething.js&#x27;</span>)<br><br><span class="hljs-comment">//exporting</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span> (n) &#123;<br>  <span class="hljs-comment">// do something </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AMD-Asynchronous-Module-Definition"><a href="#AMD-Asynchronous-Module-Definition" class="headerlink" title="AMD (Asynchronous Module Definition)"></a>AMD (Asynchronous Module Definition)</h2><blockquote><p>JavaScript를 비동기적으로 사용하기 위해 CommonJS와 독립한 별도의 그룹</p></blockquote><p>CJS와 다르게 <strong>비동기적으로 모듈을 호출</strong>하며, 브라우저에서의 모듈 실행을 우선으로 한다. 비동기적 방식으로 CJS보다 나은 성능을 보였으며, 브라우저&#x2F;서버사이드 모두 호환되는 방식이지만 CJS보다 직관적이지 않은 단점이 있다.</p><p><strong>AMD 방식의 예</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">define</span>([<br>  <span class="hljs-string">&#x27;package/lib_1&#x27;</span>,<br>  <span class="hljs-string">&#x27;package/lib_2&#x27;</span><br>], <span class="hljs-keyword">function</span> (<span class="hljs-params">pack_1, pack_2</span>) &#123;<br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> () &#123;<br>       pack_1.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Package 1&#x27;</span>)<br>     &#125;<br><br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span> () &#123;<br>       pack_2.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Package 2&#x27;</span>)<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> &#123; foo, bar &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>([<br>  <span class="hljs-string">&#x27;my_package&#x27;</span><br>], <span class="hljs-keyword">function</span> (<span class="hljs-params">my_pack</span>) &#123;<br>     my_pack.<span class="hljs-title function_">foo</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="UMD-Universal-Module-Definition"><a href="#UMD-Universal-Module-Definition" class="headerlink" title="UMD (Universal Module Definition)"></a>UMD (Universal Module Definition)</h2><blockquote><p>CJS와 AMD 모두 호환되면서 범용적으로 여러 모듈을 구성하는 디자인 패턴</p></blockquote><p>CJS와 AMD가 서로 호환되지 않는 문제가 발생하면서 이를 해결하기 위해 나온 패턴으로 <strong>브라우저와 서버 사이드 모두 호환</strong>된다. 우리가 흔히 아는 Webpack, Rollup과 같은 번들러들은 ES6 방식으로 모듈 로드에 실패하였을 때 대체 모듈로 사용한다.</p><p><strong>UMD 방식의 예</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span> (<span class="hljs-params">root, factory</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="hljs-property">amd</span>) &#123;<br>    <span class="hljs-comment">// AMD</span><br>    <span class="hljs-title function_">define</span>([ <span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-string">&#x27;underscore&#x27;</span> ], factory)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-comment">// CJS</span><br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>), <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;underscore&#x27;</span>))<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// global</span><br>    <span class="hljs-comment">// root === window</span><br>    root.<span class="hljs-property">Requester</span> = <span class="hljs-title function_">factory</span>(root.<span class="hljs-property">$</span>, root.<span class="hljs-property">_</span>)<br>  &#125;<br>&#125;(<span class="hljs-variable language_">this</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">$, _</span>) &#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Requester</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Requester</span><br>&#125;))<br></code></pre></td></tr></table></figure><h2 id="ESM-ECMAScript-Module"><a href="#ESM-ECMAScript-Module" class="headerlink" title="ESM (ECMAScript Module)"></a>ESM (ECMAScript Module)</h2><blockquote><p>ES6의 등장으로 JavaScript의 표준 모듈 시스템으로 명세</p></blockquote><p>ES6 등장 이후 표준 모듈 시스템을 구현하고자 하는 JavaScript의 제안이며, 권장 사항이다. <strong>많은 최신 브라우저에서 동작하며, CJS의 단순한 구문과 AMD의 비동기적 방식을 모두 갖춘 모듈 시스템</strong>이다. </p><p>HTML type을 module로 지정하여 하나의 독립된 모듈로 사용할 수 있으며, 레거시 브라우저에서는 ES6 문법을 지원하지 않기 때문에 Babel과 같은 트랜스파일러(Transpiler)가 등장하였다.</p><p><strong>ESM 방식의 예</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; foo, bar &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./myLib&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;<br>  <span class="hljs-keyword">import</span> &#123;func1&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my-lib&#x27;</span>;<br><br>  <span class="hljs-title function_">func1</span>();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><h1 id="Module-Bundler"><a href="#Module-Bundler" class="headerlink" title="Module Bundler"></a>Module Bundler</h1><blockquote><p>분리된 코드와 관련된 모든 모듈 종속성을 최소한의 파일로 병합하는 도구</p></blockquote><p>SPA(Single Page Application)와 같은 Front-End에서 다양한 기술의 등장으로 웹 애플리케이션도 복잡도가 향상되었으며, 코드양도 증가하였다. 또한 많은 종속성 모듈에 대해 중복된 코드들이 증가하면서 이에 따라 효율성을 높이기 위한 도구로 번들러가 나오기 시작했다. 번들러는 애플리케이션에 필요한 모든 리소스들을 모듈 단위로 나누어 묶거나 난독화, Tree Shaking, CSS 전처리기 또는 최신 ESMAScript를 레거시 브라우저가 읽을 수 있도록 변환도 지원한다.</p><p><img src="/2023/10/08/module-system-bundler/bundle-diagram.png" alt="bundler"></p><p>번들러에는 우리가 흔히 알고 사용하고 있는 Webpack, Rollup을 포함하여 Vite에서 기반으로 사용하고 있는 esbuild와 이외에도  snowpack, swc, parcel, browserify 등 많은 번들러가 출시되고 사용되고 있다.</p><ul><li>이미지</li></ul><p>몇가지 대표적인 번들러를 비교해보자.</p><table><thead><tr><th></th><th>Entry Potint</th><th>Dev-Server</th><th>HMR</th><th>Tree Shaking</th><th>Transpile</th></tr></thead><tbody><tr><td>webpack</td><td>Javascript 파일이며, html은 플러그인을 사용</td><td>webpack-dev-server</td><td>webpack-dev-server</td><td>ES6 모듈만 지원, 별도의 설정 필요</td><td>babel-loader 등 로더 사용 및 구성</td></tr><tr><td>Rollup</td><td>Javascript 파일이며, html은 플러그인을 사용</td><td>rollup-plugin-serve</td><td>rollup-plugin-hotreload</td><td>코드를 정적으로 분석하며, 기존 도구와 모듈을 기반으로 빌드 가능</td><td>플러그인 지정</td></tr><tr><td>Parcel</td><td>html 파일을 진입점으로 하며, html 파일 분석 후 Javascript 번들링</td><td>내장 dev-server</td><td>내장 HMR 모듈</td><td>ES6, CommonJS 모두 지원</td><td>설정없이 자동 진행</td></tr></tbody></table><h2 id="웹-애플리케이션의-발전과-번들러의-관계"><a href="#웹-애플리케이션의-발전과-번들러의-관계" class="headerlink" title="웹 애플리케이션의 발전과 번들러의 관계"></a>웹 애플리케이션의 발전과 번들러의 관계</h2><p>애플리케이션의 기술 발전과 처리되어야 하는 Javascript 모듈의 개수가 늘어남에 따라 번들링의 성능도 향상이 되어야 하며, 캐싱 및 최적화 작업으로 인하여 개선된 성능이지만 대규모 종속성 클롤링으로 인한 개발 서버의 속도가 저하된다. 또한 종속된 모듈이 많을수록 개발 서버의 가동 시간과 HMR(Hot Module Replacement)의 시간이 증가하며, 다양한 프레임워크가 출시되면서 이를 지원하기 위해 번들러의 설정이 복잡해지고 있다.</p><p>결과적으로는 개발 생산성은 번들러로 인해 과거보다 증가하였지만, 웹 기술과 다양한 프레임워크의 등장, 그리고 증가하는 모듈과 애플리케이션의 규모에 따라 결국 다시 개발 생산성은 저하되는 아이러니한 상황이 발생한다.</p><p>실제로 필자가 진행한 프로젝트도 규모가 매우 큰 편인데 Webpack을 기반으로 사용기 때문에 최초 개발 서버 구동 시 3분 정도의 시간이 소요되며, HMR은 1분 안쪽, 빌드 시간은 5~6분으로 걸린다. 이 시간을 일 단위로 누적한다면 꽤 많은 시간을 비효율적으로 사용하고 있다. 그렇기에 vite를 사용하고자 세미나를 하고 마이그레이션 작업과 이 포스팅을 하고 있다.</p><p>이러한 문제점을 해결하기 위해 빠른 속도를 자랑하는 <code>esbuild</code>를 기반으로 한 <strong>vite</strong>가 출시되었다.</p><hr><p>Vite를 알기 전 먼저 JavaScript의 모듈 시스템과 번들러를 알아보았고 왜 Vite와 같은 빠른 번들러가 나오는지 알아보았다. 다음 포스팅에서는 Vite에 대해 포스팅해 보도록 하겠다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> commonjs </category>
          
          <category> amd </category>
          
          <category> umd </category>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> module system </tag>
            
            <tag> module bundler </tag>
            
            <tag> webpack </tag>
            
            <tag> rollup </tag>
            
            <tag> parcel </tag>
            
            <tag> commonjs </tag>
            
            <tag> amd </tag>
            
            <tag> umd </tag>
            
            <tag> cjs </tag>
            
            <tag> vite </tag>
            
            <tag> esbuild </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Electron] ContextBridge를 사용한 Electron RCE(Remote Code Execution) 보안 취약점 수정</title>
      <link href="/2023/09/28/electron-rce/"/>
      <url>/2023/09/28/electron-rce/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2023/09/28/electron-rce/electron-rce-cover.png" alt="electron-rce-cover"></p><p>Electron은 화면(UI)을 구성하는 Renderer Process와 기본 프로세스를 담당하는 Main Process로 나뉜다.</p><h1 id="Renderer-Process와-Main-Process"><a href="#Renderer-Process와-Main-Process" class="headerlink" title="Renderer Process와 Main Process"></a>Renderer Process와 Main Process</h1><p>이 둘 간의 통신은 기본적으로 <strong>ipcRenderer</strong>와 <strong>ipcMain</strong>으로 통신하는데 ipcRenderer는 Renderer Process에서 Main Process로 비동기 통신을 할 때 사용하며, ipcMain은 반대로 Main Process에서 Renderer Process로 비동기 통신할 때 사용된다. Electron의 프로세스 간 통신 방식에 대한 자세한 내용은 <a href="https://kdydesign.github.io/2020/12/23/electron-ipc-communication/">[Electron] Electron IPC 모듈로 Electron 통신 방법 파헤치기</a>를 참고하도록 하자.</p><h1 id="Remote-Code-Execution-RCE"><a href="#Remote-Code-Execution-RCE" class="headerlink" title="Remote Code Execution (RCE)"></a>Remote Code Execution (RCE)</h1><p>Electron의 두 프로세스를 쉽게 설명하면 Front-End (Renderer Process)와 Back-End (Main Process)로 볼 수 있다.</p><p>Front-End는 Chromium을 기반으로 하고, Back-End는 전체 운영 체제의 액세스 권한을 갖는 Node.js 런타임으로 동작된다. 그렇기에 Main Process는 Electron 모듈 이외의 Node.js 내장 기능과 NPM을 통해 설치된 모든 패키지에 액세스할 수 있는 반면에, Renderer Process는 Chromiumn을 사용하여 웹 페이지를 실행하는데 보통 우리는 javascript로 UI를 구성할 때 외부 또는 내부 모듈을 자연스럽게 require() 또는 import를 사용하지만, 이 require()를 통해서 시스템 리소스에 충분히 접근할 수 있는 문제가 발생한다. 이러한 보안적 취약점은 <strong>Remote Code Execution(RCE), 임의 코드 실행</strong>이라고 한다.</p><p>Electron에서 RCE(Remote Code Execution) 취약점이 발생하는 부분은 위에서 설명한 require()와 연관이 있다. Renderer Process에서 require()를 사용하기 위해서는 <code>webPreference</code>의 <code>nodeIntegration</code> 옵션과 연관이 있는데, 대부분 <code>require is not defined</code> 오류를 해결하기 위해 <code>nodeIntegration</code>을 <code>true</code> 지정하여 사용하지만, 무척이나 위험한 행위이다. <strong>stackoverflow나 검색된 어느 블로그 글들을 봐도 require is not defined 오류 해결 방안을 nodeIntegration을 true로 제안</strong>하고 있다.</p><p><img src="/2023/09/28/electron-rce/run-calculator.png" alt="run-calculator"></p><p>위 이미지를 보면 개발자 도구(dev tools)에서 <code>require(&#39;child_process&#39;)</code>를 접근하여 실제로 시스템의 계산기를 실해하는 모습을 볼 수 있다.</p><h2 id="nodeIntegration"><a href="#nodeIntegration" class="headerlink" title="nodeIntegration"></a>nodeIntegration</h2><p>nodeIntegation을 공식 문서의 설명을 보면 <code>노드 통합이 활성화되어 있는지의 여부</code> 라고, 하는데 Electron은 Node.js 기반에서 동작하기 때문에 이를 쉽게 설명하면 Renderer Process에서도 Node.js를 사용할 수 있게 하겠냐 것이다. 문제는 <strong>nodeIntegration의 기본값이 false</strong>인 데도 불구하고 이유도 모르고 true로 설정하였다가는 낭패를 볼 수 있다.</p><hr><p>그렇다면 nodeInteration을 사용하지 않고(false) 어떻게 Renderer Process에서 require()를 사용하라는 말인가?</p><p>이 포스팅은 이 부분에 대하여 필자가 겪고 해결한 방법을 공유하고자 작성한다.</p><h1 id="Renderer-Proces와-Main-Process-간의-Context-분리"><a href="#Renderer-Proces와-Main-Process-간의-Context-분리" class="headerlink" title="Renderer Proces와 Main Process 간의 Context 분리"></a>Renderer Proces와 Main Process 간의 Context 분리</h1><p>Remote Code Execution(RCE) 취약점을 해결하기 위해서는 <code>Renderer Process와 Main Process의 Context를 기본적으로 분리</code>해야 한다. 이러한 역할을 하기 위해서는 BrowserWindow 객체 생성 시 <strong>nodeIntegration은 기본값인 false, 그리고 contextIsolation 옵션 역시 기본값 true</strong>로 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">webPreferences</span>: &#123;<br>  <span class="hljs-attr">nodeIntegration</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">contextIsolation</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>contextIsolation</code>은 Electron API와 지정된 스크립트를 별도의 Javascript 컨텍스트에서 실행할지 여부이며, Renderer Process에서 스크립트를 실행할 수 있는 컨텍스트는 오로지 <strong>preload</strong>를 통해서만 접근이 가능하다.</p><p>preload 는 HTML DOM 과 Node.js 및 Electron API의 제한된 하위 집합에 모두 액세스할 수 있다. 쉽게 말하면 분리된 Renderer Process와 Main Process 모두 접근할 수 있는 컨텍스트에서 실행된다.</p><p><code>nodeintegration: false</code>로 인한 <code>require is not defined</code> 오류는 이 preload 통해 해결할 수 있다.</p><p><strong>preload.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123;ipcRenderer, contextBridge&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br>contextBridge.<span class="hljs-title function_">exposeInMainWorld</span>(<span class="hljs-string">&#x27;api&#x27;</span>, &#123;<br>  <span class="hljs-attr">send</span>: <span class="hljs-function">(<span class="hljs-params">channel, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> channels = [<span class="hljs-string">&#x27;channel&#x27;</span>] <span class="hljs-comment">// ipc 채널</span><br><br>    <span class="hljs-keyword">if</span> (channels.<span class="hljs-title function_">incluse</span>(channel)) &#123;<br>      ipcRenderer.<span class="hljs-title function_">send</span>(channel, data)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">receive</span>: <span class="hljs-function">(<span class="hljs-params">channel, func</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> channels = [<span class="hljs-string">&#x27;onChannel&#x27;</span>] <span class="hljs-comment">//ipc 채널</span><br><br>    <span class="hljs-keyword">if</span> (channels.<span class="hljs-title function_">include</span>(channel)) &#123;<br>      ipcRenderer.<span class="hljs-title function_">on</span>(channel, <span class="hljs-function">(<span class="hljs-params">event, ...args</span>) =&gt;</span> <span class="hljs-title function_">func</span>(event, ...args))<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Electron의 <code>contextBridge</code>는 Renderer Process에서 구동되며, 격리된 컨텍스트 간에 양방향 통신을 할 수 있도록 해준다. ContextBridge의 <code>exposeInMainWorld</code>는 Main Process 코드가 실행되는 javascript 컨텍스트로 Renderer Process에서 <strong>window 객체</strong>를 통해 접근할 수 있다.</p><p><code>preload.js</code>에 정의된 <code>send</code>와 <code>receive</code>는 쉽게 생각하면 Interceptor로 볼 수 있다. Renderer Process 또는 Main Process에서 ipcRenderer를 호출하는 대신 이 <code>send</code>와 <code>receive</code>를 호출하면 해당 메소드에서 ipcRenderer를 호출하게 된다.</p><p>이렇게 정의한 <code>preload.js</code>를 BrowserWindow 객체를 생성할 때 webPreference의 옵션으로 지정한다.</p><p><strong>index.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span>, ipcMain &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createWindow</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,<br>    <span class="hljs-attr">webPreferences</span>: &#123;<br>      <span class="hljs-attr">preload</span>: <span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./preload.js&#x27;</span>)<br>    &#125;<br>  &#125;)<br><br>  win.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br>&#125;<br><br>app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">createWindow</span>()<br>&#125;) <br><br>ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;channel&#x27;</span>, <span class="hljs-function"><span class="hljs-params">evt</span> =&gt;</span> &#123;<br>  evt.<span class="hljs-title function_">reply</span>(<span class="hljs-string">&#x27;onChannel&#x27;</span>, <span class="hljs-string">&#x27;Main World!!&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>index.js</code>는 Main Process에 해당하기 때문에 가장 하단에 보면 <code>ipcMain</code>을 통해 <code>channel</code>을 호출한다. 이후 callback이 완료되면 다시 <code>onChannel</code>을 호출한다. 이때 <code>evt.reply</code>를 호출하게 되면 preload.js의 <code>receive</code>를 호출한다.</p><p>이제 Renderer Process 부분에서 UI를 구성해 보자.</p><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text-box&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Change Text<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>js&#x2F;script.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><br>  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">api</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;channel&#x27;</span>)<br>  &#125;)<br><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">api</span>.<span class="hljs-title function_">receive</span>(<span class="hljs-string">&#x27;onChannel&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt, text</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> titleBox = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text-box&#x27;</span>)<br><br>    titleBox.<span class="hljs-property">innerText</span> = text<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>js/script.js</code>를 보면 <code>window.api.send(&#39;channel&#39;)</code>로 preload.js에 선언된 <code>send</code>를 호출하고 있고, <code>index.js</code>에서 <code>evt.reply(&#39;onChannel&#39;)</code>에 대해 <code>window.api.receive(&#39;onChannel&#39;)</code>을 통해 수신하고 있다.</p><p>전반적인 통신의 흐름을 보면 다음과 같다.</p><p><img src="/2023/09/28/electron-rce/rce-flow.png" alt="rce-flow"></p><hr><p>이처럼 preload 와 nodeInegration을 적절하게 사용하여 Renderer Process와 Main Process 간의 Context를 분리하면 Remote Code Execution(RCE) 취약점을 해결할 수 있다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2023/09/28/electron-rce/">[Electron] ContextBridge를 사용한 Electron RCE(Remote Code Execution) 보안 취약점 수정</a><br><a href="https://kdydesign.github.io/2020/12/23/electron-ipc-communication/">Electron IPC 모듈로 Electron 통신 방법 파헤치기</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> electron </category>
          
          <category> 보안 취약점 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> electron </tag>
            
            <tag> rce </tag>
            
            <tag> remote code execution </tag>
            
            <tag> electron 보안 취약점 </tag>
            
            <tag> contextbridge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Performant NPM - PNPM</title>
      <link href="/2023/09/25/pnpm-tutorial/"/>
      <url>/2023/09/25/pnpm-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2023/09/25/pnpm-tutorial/performant-npm-tutorial-cover.png" alt="performant-npm-tutorial-cover"></p><p>과거 웹 서비스는 텍스트와 이미지를 통해 정보를 전달하는 단순한 역할만 하였기 때문에 서비스의 규모가 그렇게 크지는 않았다.</p><p>이후 시간이 갈수록 HTML과 JavaScript, CSS와 같은 웹 기술의 발전으로 웹에서 제공되는 서비스의 규모가 점차 커졌지만, 이 역시도 2000년대 초반의 2세대 웹에서는 HTML이나 JavaScript의 파일 크기도 상대적으로 작았으며, 서비스를 유지하는 데 큰 무리가 없었다.</p><p>하지만 JavaScript의 계속되는 발전에 웹 서비스의 규모도 점차 커져갔으며, 관리되는 리소스나 HTML, 그리고 JavaScript 파일의 규모와 개수도 서비스의 규모와 비례하여 점차 증가해 갔다. 이때부터는 단순히 정보를 출력해주는 문서가 아닌 복잡한 처리가 가능한 하나의 애플리케이션에 가까웠다. 이에 따라 과거에 자주 사용되던 JavaScript의 <code>순차적 로드 방식</code>은 각 JavaScript 파일 간 스코프(scope)가 구분되지 않는 문제로 인해 서로 다른 JavaScript 파일들을 오염시키거나 충돌이 일어나는 경우 많아지면서 <strong>CJS(Common JS)</strong>, <strong>AMD(Asynchronous Module Definition)</strong>, <strong>UMD(Universal Module Definition)</strong>, <strong>ESM(ECMAScript Module)</strong> 과 같은 <code>JavaScript의 모듈화가 등장하기 시작</code>했다.</p><p>이렇게 JavaScript의 모듈화는 Node.js와 NPM, 그리고 ES6의 등장으로 더욱 활발해졌으며, 이 모듈을 관리하는 패키지 매니저인 NPM은 모듈화 또는 패키지화에 큰 변화를 주었다. 하지만 Node.js와 NPM 역시 빠른 속도로 발전해 나가는 JavaScript 생태계를 따라잡기에는 역부족이었을까? </p><p>단일 모듈의 개수들과 서로 종속된 모듈들의 개수는 폭발적으로 증가하였고 이에 따라 성능, 모듈이 차지하는 디스크의 용량과 종속된 모듈 간의 호환성, 그리고 보안 측면인 문제가 발생하기 시작했고 이를 해결하기 위해 <code>YARN</code>, <code>PNPM</code>과 같은 개선된 패키지 매니저가 나오기 시작했다.<br>이 중 NPM과 YARN은 이미 널리 알려진 패키지 매니저이기에 이 포스팅에서는 최근 많은 주목을 받는 <strong>Performant NPM</strong> 이라 불리는 <strong>PNPM</strong>을 소개해 보고자 한다.</p><p><em>22년 회사에서 세미나 후 자료는 준비했지만 게으른 탓에 이제서야 포스팅을하게 된다.</em></p><h1 id="Package-Manager의-지속적인-발전"><a href="#Package-Manager의-지속적인-발전" class="headerlink" title="Package Manager의 지속적인 발전"></a>Package Manager의 지속적인 발전</h1><p><code>PNPM의 장점</code>은 곧 기존 패키지 매니저들이 가지고 있는 단점을 해결한 것이기에 PNPM을 소개하기 전 근본의 NPM을 넘어 새로운 패키지 매니저가 왜 자꾸 나오는지 알아보자.</p><p>최초의 패키지 매니저는 NPM으로 10년이 넘는 시간 동안 존재해 왔다. 이렇게 오랜 시간 자리매김하고 있는 NPM을 넘어 왜 자꾸만 <code>YARN</code>, <code>PNPM</code>과 같은 새로운 패키지 매니저가 등장하는 것일까?</p><p>이 질문에 정확한 답변은 존재하지 않는다. 언제나 그렇듯 JavaScript의 생태계에서는 A보다 나은 B가 나오기 마련이기 때문이다. 하지만 굳이 꼽자면 몇 가지 이유를 들 수 있겠다.</p><h2 id="1-node-modules"><a href="#1-node-modules" class="headerlink" title="1. node_modules"></a>1. node_modules</h2><p>과거 <strong>NPM@2</strong> 까지의 node_modules의 구조는 단순하였다. </p><p><code>A → B → C </code>라는 패키지가 있다면 <strong>종속 깊이에 따라 순차적으로 종속된 모듈을 설치해 나가는 단순한 방식</strong>이었다. 이런 방식은 서로 종속된 모듈 간 분리가 명확했기에 일관성이 유지되었고 각 모듈 간의 오염과 충돌은 적었다.<br>하지만 종속된 모듈이 많아지면서 디렉토리 계층 구조의 깊이는 더 깊어져 갔고 이로 인한 문제점(<em>Windows Max Path 260자</em>)과 종속성 그래프를 생성하는 시간 역시 길어져만 갔다.</p><p>Node.js를 개발한 <code>Ryan Dahl</code>은 <code>Design Mistakes in Node</code>에서 node_modules에 대해 모듈 간 종속성 관리, 모듈 간 문제 해결 알고리즘을 매우 복잡하게 만든다고도 하였으며, 아래와 같이 말하기도 하였다.</p><hr><p style="text-align: center;font-weight: bold">It's my fault and I'm very sorry.</p><p style="text-align: center;font-weight: bold">Unfortunately it's impossible to undo now.</p><hr><p>이런 문제점은 고질적으로 설계 자체의 문제로 <code>Ryan Dahl</code>은 <a href="https://deno.land/">Deno</a>를 개발하기도하였다. <code>Deno</code>에 대해서는 <a href="https://kdydesign.github.io/2022/02/17/deno-tutorial/">[Deno] Node.js의 대안!! Deno 알아보기</a>를 참고하도록 하자.</p><h2 id="2-디스크-효율"><a href="#2-디스크-효율" class="headerlink" title="2. 디스크 효율"></a>2. 디스크 효율</h2><p>우리가 <a href="https://kdydesign.github.io/2017/11/04/webpack-tutorial/">webpack</a>, <a href="https://kdydesign.github.io/2020/09/23/parcel-intro/">parcel</a>과 같은 번들링 도구로 애플리케이션을 번들링 시 명시된 devDependencies는 포함되지 않는다. 하지만 로컬 PC와 같은 우리의 개발 환경에서는 <code>모든 종속된 모듈들이 디스크의 용량을 차지</code>한다. 무심코 지나갔을 수 있지만 규모가 큰 애플리케이션의 경우 종속된 모듈의 용량은 은근히 크다. 물론 현 시대의 하드웨어에 무리가 갈 정도로 침범하진 않지만 말이다.</p><p>특히 과거의 NPM인 경우 중복되는 종속성이 여러 모듈에 종속된 <a href="https://rushjs.io/pages/advanced/npm_doppelgangers/">NPM 도플갱어</a>로 인해 모듈이 많으면 많을수록 폭발적으로 용량이 증가한다. 이러한 문제점은 디스크 효율성도 떨어뜨리지만, 종속된 모듈이 증가하기 때문에 종속성 그래프를 생성하는 시간 역시 길어지는 이유 중 하나이다.</p><h2 id="3-호이스팅-Hoisting"><a href="#3-호이스팅-Hoisting" class="headerlink" title="3. 호이스팅(Hoisting)"></a>3. 호이스팅(Hoisting)</h2><p>위에서 node_modules를 설명할 때 <strong>NPM@2</strong>의 종속성 구조는 매우 단순하다고 하였다. 하지만 이와 연관되어 <a href="https://rushjs.io/pages/advanced/npm_doppelgangers/">NPM 도플갱어</a>가 발생하고 또 이에 따라 디스크 효율성이 떨어지는데 NPM은 이를 해결하기 위해 <strong>NPM@3</strong>부터 동작 방식을 변경하였다.</p><p>바로 종속성을 설치할 때 <strong>연관 관계에 따라 모듈을 디렉토리 계층 구조의 최상위로 호이스팅(Hoisting)하는 방식</strong>이다. 이 방식은 현재까지도 유지되고 있으며, 우리가 node_modules 디렉토리를 보았을 때 하나로 나열된 것을 확인해 볼 수 있다.</p><p>NPM은 호이스팅으로 인해 <strong>NPM@3</strong>부터는 위에서 설명된 <code>node_modules</code>와 <code>디스크 효율</code>이 좋아졌지만, <code>보안적 측면에서 문제</code>가 생기기 시작했다. Chrome V8 자체는 매우 좋은 보안 샌드박스였지만 Node.js는 사용자가 액세스할 수 있는 모든 것에 접근할 수 있으며, 이는 보안 측면에서 매우 취약하다. 특히나 모든 종속성 구조를 최상위로 호이스팅 한다면 사용자뿐만 아니라 코드 또는 커맨드와 같은 다른 방식으로도 접근할 수 있게 되고 수정까지 가능하게 된다.</p><p>이러한 문제로 과거에는 아래와 같은 보안적 이슈가 존재하기도 했었다.</p><blockquote><p><a href="https://github.com/npm/npm/issues/19883">Linux OS에서 sudo NPM 명령을 통한 시스템 파일의 소유권 변경</a><br><a href="https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident">NPM package event-stream에 악성 패키지를 내포한 비트코인 탈취 시도</a></p></blockquote><p>이 문제는 YARN 역시 동일한데 현재는 <code>lock</code> 파일을 통해 패키지에 대한 무결성 검증으로 많이 안정화되었다.</p><h2 id="4-Mono-Repo"><a href="#4-Mono-Repo" class="headerlink" title="4. Mono Repo"></a>4. Mono Repo</h2><p>과거 Github에서는 <code>1 Project 당 1 Repository</code> 방식인 <strong>Multi Repo</strong> 방식을 많이 사용하였다. 하지만 점차 <code>core</code>, <code>cli</code>, <code>ui</code> 등 하나의 패키지와 연관된 기능들이 많아지고 이에 비례하여 증가하는 레포지토리의 관리는 너무나 비효율적이었다. <code>lint</code>와 같은 각 프로젝트 별 공통된 패키지를 여러 레파지토리에 설치를 해줘야 하니 말이다.</p><p>그러면서 <strong>YARN의 workspace</strong>와 <a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna</a> 같은 <strong>Mono Repo</strong> 도구가 나오면서 <code>하나의 레포지토리 안에 여러 패키지를 관리</code>하는 메커니즘이 나오기 시작하였다. 현재는 대부분 프로젝트에서 <code>Mono Repo</code> 구조로 개발을 진행하고 있으며, 큰 효과를 보고 있다.</p><div class="alert more no-icon"><p><strong>Multi Repo</strong>: 여러 Repository에 패키지를 분산하여 관리<br><strong>Mono Repo</strong>: Multi Repo와 반대로 여러 패키지를 하나의 Repository에서 관리</p></div><p>하지만 Mono Repo는 하나의 레포지토리 안에서 여러 패키지를 관리하다 보니 종속된 모듈들이 오히려 문제가 되기 시작했다.</p><p>예를 들어 하나의 레파지토리 안에 서로 다른 A, B, C의 패키지가 존재한다면 각각의 패키지에서 공통으로 사용되는 Lint를 최상위 패키지로 설치는 하지만 결국 Lint에 종속된 특정 모듈은 B 패키지에 있는 모듈 중에서도 종속될 가능성이 있는 것이다. 이로 인해 안 그래도 복잡한 알고리즘을 가진 종속성 모듈을 더욱 복잡하게 만드는 경우이기도 하다.</p><hr><p>큰 카테고리로 패키지 매니저가 발전하는 이유 4가지인 <code>node_modules</code>, <code>디스크 효율성</code>, <code>호이스팅(Hoisting)</code>, <code>Mono Repo</code>에 대해서 알아보았다. 사실 이 내용들은 PNPM에서 해결된 문제점이기도 하고 PNPM이 최근 많은 관심을 받는 이유이기도 하다.</p><p>서론이 너무 길었다. 이제 본론으로 들어가 <code>Performant NPM</code>인 PNPM에 대해 알아보도록 하자.</p><hr><h1 id="Performant-NPM-PNPM"><a href="#Performant-NPM-PNPM" class="headerlink" title="Performant NPM - PNPM"></a>Performant NPM - PNPM</h1><p>PNPM은 <code>Performant Node Package Manager</code>를 의미하는 NPM의 대체 패키지 관리자이다.</p><p>PNPM의 주요 목적은 <strong>모든 패키지를 중앙 집중식 저장 형태로 관리</strong>하고 <strong><a href="https://en.wikipedia.org/wiki/Hard_link">하드 링크</a>와 심볼릭 링크를 통해 프로젝트에서 패키지를 참조</strong>함으로써 <code>빠른 속도</code>와<code> 프로젝트 간 동일 버전의 종속성 유지</code> 및 <code>디스크 공간 절약</code>을 목적으로 두고 있다.</p><div class="alert more no-icon"><p><strong>Hard Link (ln)</strong> : 원본 파일과 inode가 동일하여 원본이 수정되면 <a href="https://en.wikipedia.org/wiki/Hard_link">하드 링크</a>된 파일도 수정이 되고 원본이 삭제되더라도 <a href="https://en.wikipedia.org/wiki/Hard_link">하드 링크</a>된 파일은 유지된다.<br><strong>Symbolic Link&#x2F;Soft Link (ln -s)</strong> : 윈도우의 바로가기와 같으며, 단순한 원본 파일의 위치 정보(point)만을 가지고 있다.</p></div><h2 id="현재-오픈-소스의-PNPM-활용"><a href="#현재-오픈-소스의-PNPM-활용" class="headerlink" title="현재 오픈 소스의 PNPM 활용"></a>현재 오픈 소스의 PNPM 활용</h2><p>최초 필자가 PNPM을 접하게 된건 vue의 Github에서이다. 하지만 <a href="https://pnpm.io/ko/users">이외에 많은 이름있는 프로젝트에서 PNPM을 사용</a>하고 있다.</p><p><img src="/2023/09/25/pnpm-tutorial/use-pnpm.png" alt="use-pnpm"></p><h2 id="2022-state-of-js-Monorepo-tools-부분"><a href="#2022-state-of-js-Monorepo-tools-부분" class="headerlink" title="2022 state of js - Monorepo tools 부분"></a>2022 state of js - Monorepo tools 부분</h2><p><a href="https://2022.stateofjs.com/en-US/libraries/monorepo-tools/">2022 state of js - MonoRepo Tools 부분</a>을 보면 PNPM의 인기를 확인할 수 있다.</p><p><img src="/2023/09/25/pnpm-tutorial/2022-stateofjs-pnpm-1.png" alt="2022-stateofjs-pnpm-1"><br><img src="/2023/09/25/pnpm-tutorial/2022-stateofjs-pnpm-2.png" alt="2022-stateofjs-pnpm-2"><br><img src="/2023/09/25/pnpm-tutorial/2022-stateofjs-pnpm-3.png" alt="2022-stateofjs-pnpm-3"></p><h2 id="PNPM의-특징"><a href="#PNPM의-특징" class="headerlink" title="PNPM의 특징"></a>PNPM의 특징</h2><p>PNPM의 종속성 관리는 NPM의 기본 메커니즘을 따라가지만, 별도의 중앙 <strong>집중화된 관리(virtual-store)</strong> 와 <strong><a href="https://en.wikipedia.org/wiki/Hard_link">하드 링크</a></strong>, <strong>심볼릭 링크</strong>가 핵심적이다. 이 개념 하나로 빠른 성능과 디스크의 효율성을 높였다.</p><p>또한 진화된 NPM@3 방식의 <code>flat node_modules</code> 구조가 아닌 반대로 NPM@2의 <code>non-flat node_modules</code> 구조를 따라감으로써 전반적인 보안적 취약점이 해결되었다.</p><p>PNPM의 특징은 크게 4가지로 나누어 볼 수 있다.</p><h3 id="1-성능"><a href="#1-성능" class="headerlink" title="1. 성능"></a>1. 성능</h3><p>YARN은 NPM보다 빠른 성능을 보이지만 사실상 규모가 큰 시나리오에서는 큰 차이를 나타내지 못한다. 하지만 PNPM은 기타 패키지 관리자보다<code> 최대 2배 빠른 속도</code>를 보인다.</p><p><a href="https://pnpm.io/ko/benchmarks">PNPM의 벤치 마킹에 따른 성능 비교 분석</a>을 보게 되면 여러 케이스에서 PNPM이 다른 패키지 매니저보다 우수한 성능을 나타내는 것을 볼 수 있다.</p><p><strong>PNPM 벤치마킹에 따른 성능 비교</strong></p><p><img src="/2023/09/25/pnpm-tutorial/pnpm-benchmark-1.png" alt="pnpm-benchmark-1"><br><img src="/2023/09/25/pnpm-tutorial/pnpm-benchmark-2.png" alt="pnpm-benchmark-2"></p><h3 id="2-디스크-공간의-효율적-사용"><a href="#2-디스크-공간의-효율적-사용" class="headerlink" title="2. 디스크 공간의 효율적 사용"></a>2. 디스크 공간의 효율적 사용</h3><p>NPM과 YARN은 모듈을 설치할 경우 node_modules 경로에 모두 설치되고 만약 같은 모듈을 사용하는 100개의 프로젝트가 있다면 똑같이 100개 프로젝트에 같은 모듈을 설치해야 한다. 이렇게 설치되면 <code>디스크 사용량은 폭발적으로 증가</code>할 것이고 100번의 설치 과정을 걸쳐야 하는 번거로움이 있지만(또는 복사하거나), <strong>PNPM의 경우 모든 종속된 모듈은 특정 디스크 위치(.pnpm-store)에 저장</strong>된다. 이후 프로젝트에서 특정 패키지가 필요한 경우 해당 패키지를 프로젝트에 <a href="https://en.wikipedia.org/wiki/Hard_link">하드 링크</a>(.pnpm)되어 추가 디스크 공간을 사용하지 않기 때문에 디스크 사용이 효율적이고 패키지의 재사용 효율이 높다.</p><p>또한 다른 버전의 종속된 모듈이 필요하다면 모든 100개의 프로젝트를 업데이트할 필요 없이 중앙에 관리되는 패키지만 업데이트가 되며 이 한 번의 업데이트로 같은 패키지를 사용하는 프로젝트에서 같은 버전의 패키지를 사용할 수 있다.</p><h3 id="3-Non-Flat-node-modules"><a href="#3-Non-Flat-node-modules" class="headerlink" title="3. Non-Flat node_modules"></a>3. Non-Flat node_modules</h3><p>위에서 <code>NPM@2</code>의 메커니즘은 단순하다고 하였으며, <code>non-flat node_modules</code>구조로써 얻는 이점들이 있다고 설명하였다. 하지만 <code>NPM@3</code>부터는 루트 경로로 호이스팅을 하는 <code>flat node_modules</code> 구조를 사용하였다.</p><p>NPM과 YARN의 경우 모든 종속성 설치할 때 모든 패키지는 모듈 디렉토리의 로트로 호이스팅을 하고 결과적으로 소스 코드를 통해 종속되지 않은 모듈에도 접근할 수 있다. 하지만 PNPM은 <a href="https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way">Flat node_modules의 문제를 해결하기 위한 유일한 방법이 아니라고 설명</a>하고 오히려 <code>non-flat node_modules</code>를 지향하고 <code>NPM@2</code>의 메커니즘을 사용하였다.</p><p>그렇다면 PNPM도 <code>NPM@2</code>의 문제점을 가지고 있을까? </p><p>이에 대한 답은 <code>아니오</code>이다. PNPM은 <code>NPM@2</code>의 <code>non-flat node_modules</code> 즉 루트로 호이스팅을 하지 않는 대신 종속된 모든 모듈은 <a href="https://en.wikipedia.org/wiki/Hard_link">하드 링크</a> 방식과 심볼릭 링크 방식을 사용함으로써 <code>NPM@2</code>의 문제를 해결하였는데 이런 하드링크와 심볼릭 링크 방식으로 종속성 수와 종성 그래프의 깊이에 관계없이 유지된다.</p><h3 id="4-보안"><a href="#4-보안" class="headerlink" title="4. 보안"></a>4. 보안</h3><p>위에서 설명했듯 PNPM은 애초부터 종속된 모듈들을 루트로 호이스팅을 하지 않기 때문에 <code>호이스팅으로 인한 보안적 문제(모듈에 대한 엑세스)</code>는 없을 뿐더러 YARN과 동일하게 PNPM에는 설치된 모든 패키지의 체크섬이 포함된 파일이 존재하여 코드가 실행되기 전 설치된 모든 <code>패키지의 무결성을 확인</code>한다.</p><h3 id="5-Mono-Repo"><a href="#5-Mono-Repo" class="headerlink" title="5. Mono Repo"></a>5. Mono Repo</h3><p>초창기 Lerna는 Mono repo로서 사용자도 많으며 유명 프로젝트에서 많이 사용되었지만, 많은 것을 스스로 알아야 했고 현재도 그렇다. 버전업도 많이 진행되고 개선되었으며, 과거보다는 안정되었지만, 소문에 의하면 <code>메인 개발자의 번아웃으로 유지보수에 어려움을 겪는다고 한다.</code></p><p>Lerna 이외에 YARN을 사용하여 Mono Repo를 구축할 수도 있다. <code>YARN Classic(YARN 1)</code>은 17년도 Lerna와 같은 Mono Repo를 지원하기 시작하였고, <code>YARN Berry(YARN 2)</code>는 <code>YARN Classic</code>의 개념을 기반으로 개선된 Mono Repo를 지원한다.</p><p>PNPM의 경우에도 역시나 Mono Repo를 지원하며, YARN Berry와 유사하다. 즉, <strong>PNPM은 Lerna와 YARN을 대체할 수 있는 Mono Repo를 제공</strong>한다.</p><p>Lerna에 관한 내용은 아래 내용을 참고하자.</p><blockquote><p><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a></p></blockquote><hr><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>PNPM의 설치 방식에는 <code>독립 실행형 설치</code> 방법과 <code>[Corepack](https://nodejs.org/api/corepack.html)</code>,<code> NPM을 통한 설치</code>를 제공한다.</p><h3 id="독립-실행형"><a href="#독립-실행형" class="headerlink" title="독립 실행형"></a>독립 실행형</h3><p><strong>Windows PowerShell</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">iwr https://get.pnpm.io/install.ps1 -useb | iex<br></code></pre></td></tr></table></figure><p><strong>POSIX systems - curl</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">curl -fsSL https://get.pnpm.io/install.sh | sh -<br></code></pre></td></tr></table></figure><p><strong>POSIX systems - wget</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">wget -qO- https://get.pnpm.io/install.sh | sh -<br></code></pre></td></tr></table></figure><h3 id="Corepack"><a href="#Corepack" class="headerlink" title="Corepack"></a>Corepack</h3><p>Node.js v16.13부터는 패키지 관리자를 위해 <a href="https://nodejs.org/api/corepack.html">Corepack</a>을 출시하였다. v16에서는 실험적 기능으로 <code>PNPM과 YARN을 지원</code>하고, 해당 기능을 활성화하면 PNPM을 사용할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">corepack <span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure><p>이후 최신 버전의 PNPM을 사용하려면 아래와 같은 명령어를 사용한다.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Node.js v16.17 &gt;</span></span> <br>corepack prepare PNPM@&lt;version&gt; --activate<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Node.js v16.17 &lt;=</span></span><br>corepack prepare PNPM@latest --activate<br></code></pre></td></tr></table></figure><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>PNPM도 NPM과 동일한 패키지 매니저이지만 NPM을 통해서 설치할 수 있다.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install -g pnpm<br></code></pre></td></tr></table></figure><h2 id="Node-js-지원-버전"><a href="#Node-js-지원-버전" class="headerlink" title="Node.js 지원 버전"></a>Node.js 지원 버전</h2><p>PNPM은 2023년 09월 기준으로 v8까지 출시된 상태이고 최소 버전은 PNPM v5이다. v5의 경우 Node.js v12 이상부터 지원하며 v7은 Node.js v18까지 지원한다.</p><p><em>(22년도 해당 포스팅을 준비할 때에는 v7까지 출시된 상태였고 최소 버전은 v4였으며, v4의 경우 Node.js v10 이상부터 지원이었다. 이런 과정을 보면 하상 Node.js 버전업에 맞게 업데이트를 꾸준히 해야겠다는 생각을 다시끔 한다.)</em></p><table><thead><tr><th>Node.js</th><th>PNPM 5</th><th>PNPM 6</th><th>PNPM 7</th><th>PNPM 8</th></tr></thead><tbody><tr><td>Node.js v12</td><td>✔️</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>Node.js v14</td><td>✔️</td><td>✔️</td><td>✔️</td><td>❌</td></tr><tr><td>Node.js v16</td><td>?</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>Node.js v18</td><td>?</td><td>️✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>Node.js v20</td><td>️?</td><td>️ ?</td><td>✔️</td><td>✔️</td></tr></tbody></table><h2 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h2><p>PNPM의 실행 방식은 YARN과 비슷하며 크게 다를 것이 없다.</p><p>PNPM의 CLI는 <a href="https://pnpm.io/cli/add">PNPM cli 공식 문서</a>에서 확인 할 수 있다. 몇 가지 가장 많이 사용하는 CLI를 알아보자.</p><p><strong>pnpm install</strong></p><ul><li><code>aliases</code>: <code>i</code><br><code>PNPM install</code>은 프로젝트의 모든 종속성을 설치한다.</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">pnpm install<br></code></pre></td></tr></table></figure><p><strong>pnpm add <package></strong><br><code>pnpm add</code>는 패키지와 패키지가 의존하는 모든 패키지를 설치한다. 기본적으로 모든 새로운 패키지는 프로덕션 종속성(dependencies)으로 설치된다.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">pnpm add [option] &lt;package&gt;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>pnpm add <package></td><td>dependencies 설치</td></tr><tr><td>pnpm add -D<package></td><td>devDependencies 설치</td></tr><tr><td>pnpm add -O<package></td><td>optionalDependencies 설치</td></tr><tr><td>pnpm add -g<package></td><td>global 설치</td></tr><tr><td>pnpm add <package>@[version]</td><td>버전 지정 설치</td></tr></tbody></table><p><strong>pnpm update</strong></p><ul><li><code>aliases</code>: <code>up</code>, <code>upgrade</code><br><code>PNPM update</code>는 지정된 범위에 따라 패키지의 버전을 업데이트한다.</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">pnpm update &lt;package&gt;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>pnpm update</td><td>모든 종속성 업데이트</td></tr><tr><td>pnpm update <package>@[version]</td><td>특정 패키지를 특정버전으로 업데이트</td></tr><tr><td>pnpm update “@babel&#x2F;*”</td><td>패키지 scope 내 모든 종속성 업데이트</td></tr><tr><td>pnpm update !<package></td><td>특정 패키지를 제외한 모든 종속성 업데이트</td></tr></tbody></table><p><strong>pnpm remove</strong></p><ul><li><code>aliases</code>: <code>rm</code>, <code>uninstall</code>, <code>un</code><br><code>PNPM remove</code>는 프로젝트 내 패키지를 제거한다.</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">PNPM remove [option]<br></code></pre></td></tr></table></figure><table><thead><tr><th>Command</th><th>Aliases</th><th>Description</th></tr></thead><tbody><tr><td>pnpm remove –recursive</td><td>-r</td><td>Mono Repo의 Workspace 내에서 사용되는 경우 모든 작업 공간의 패키지에서 종속성 제거</td></tr><tr><td>pnpm remove –global</td><td>-g</td><td>전역 패키지 제거</td></tr><tr><td>pnpm remove –save-dev</td><td>-D</td><td>devDependencies 에서 종속성 제거</td></tr><tr><td>pnpm remove –save-optionval</td><td>-O</td><td>optionalDependencies 에서 종속성 제거</td></tr><tr><td>pnpm remove –save-prod</td><td>-P</td><td>dependencies 에서 종속성 제거</td></tr><tr><td>pnpm remove –filter <package_selector></td><td></td><td><a href="https://pnpm.io/filtering">Filtering</a>을 통한 특정 하위 집합으로 제거</td></tr></tbody></table><hr><h1 id="NPM의-대체로-가능한가"><a href="#NPM의-대체로-가능한가" class="headerlink" title="NPM의 대체로 가능한가?"></a>NPM의 대체로 가능한가?</h1><p>확실히 성능적인 부분과 디스크 효율적인 부분으로 따지면 PNPM이 승자이며, 하나의 프로젝트에 여러 그룹이 진행하거나 여러 프로젝트를 mono Repo로 관리를 한다면 PNPM은 유용하다.</p><p>그렇다고 쉽사리 현재 진행되고 있는 프로젝트 또는 진행 될 프로젝트에 반영하기는 쉽지 않을 것이다. 언제나 그렇듯 JavaScript의 생태계에서는 <code>A보다 좋다는 B가 나와도</code> 근본이 있기 때문이며, 여기서 근본은 NPM이기 때문이다.</p><p>수십 년간 Node.js와 NPM은 유지가 되어왔고 이를 개선한 새로운 오픈 소스가 출시해도 NPM과 YARN 역시 이에 뒤처지지 않게 발전해 왔으며, 문제점도 해결해 왔다. 물론 가장 효율적인 방법으로 초기 설계부터 진행해 온 것과 그렇지 않은 것의 차이는 있지만 NPM을 유지한다고 문제가 생기는 것은 아니다.</p><p>다만 <code>현재 본인이 겪고 있는 문제점이 PNPM으로 해결이 된다면 PNPM을 사용</code>하는 것이 옳다고 생각한다.</p><hr><p>PNPM이 NPM보다 우월하다는 관점에서 보기보다는 <code>NPM이 과거에 어떤 문제가 있었고 왜 패키지 매니저가 발전</code>해 왔는지 알아보았다. 무심코 우리는 패키지를 설치 및 업데이트와 같이 단순하게 사용을 해왔지만, 이러한 단순한 도구가 왜 계속 발전해 왔는지 파악할 수 있었으며, PNPM이라는 새로운 패키지 매니저에 대해 배워보았다.</p><p>개인적으로는 NPM이 아닌 PNPM을 사용하려고 노력하고 있지만 PNPM 역시 오픈 소스이기 때문에 문제 발생에 대한 두려움도 있기에 실무적으로 프로덕션이 필요한 경우에는 사용을 자제하고 있지만 확실히 빠른 속도로 개발적 효율은 향상했다고 느껴진다.</p><p>앞으로 또 어떤 패키지 매니저가 나올지 모르지만, 다양한 내용을 알아 둔다면 나중에 분명 도움이 되는 날이 올 것으로 생각한다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/02/17/deno-tutorial/">[Deno] Node.js의 대안!! Deno 알아보기</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a><br><a href="https://kdydesign.github.io/2020/09/23/parcel-intro/">불꽃 튀게 빠른 번들러 Parcel 개념잡기!</a><br><a href="https://kdydesign.github.io/2020/09/16/nvm-for-windows/">NVM으로 Windows 환경에서 Node 버전 관리하기</a><br><a href="https://kdydesign.github.io/2020/08/28/NPM-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-NPM-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> PNPM </category>
          
          <category> YARN </category>
          
          <category> NPM </category>
          
          <category> monorepo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> PNPM </tag>
            
            <tag> YARN </tag>
            
            <tag> NPM </tag>
            
            <tag> monorepo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</title>
      <link href="/2022/03/04/firebase-pwa-tutorial/"/>
      <url>/2022/03/04/firebase-pwa-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-pwa-tutorial-cover.png" alt="firebase-pwa-tutorial-cover"></p><p>예전부터 <code>Firebase</code>를 겉핥기식으로나마 다뤄보고 싶었지만 회사 업무 및 특성상 Firebase를 사용해 볼 기회가 없었다. 그러다보니 손을 놓고 있었지만 최근 다시 관심이 생겨서 규모가 작지만 <code>PWA(Progressive Web App)</code>을 만들어 Firebase에 올려보면서 실제로 사용해보기로 하였다. 이러한 과정에서 습득한 내용을 간단하게 공유해보고자한다.</p><p><code>Firebase</code> 개념만 파악하고 이것만 사용하기에는 피부로 와 닿지 않는 부분이 있어서 실제 업무에 적용해 본다는 느낌으로 간단한 PWA(Progressive Web App)를 만들어 Firebase에 올려보기로 하였다. 이 과정에서 Firebase의 간단한 개념과 PWA(Progressive Web App)에 대한 개념을 알아야하지만, 이런 개념보다는 <strong>실제로 PWA 애플리케이션을 만들고, 외부 CI와 연동하여 자동으로 빌드하고, 배포 및 호스팅</strong>까지 할수 있는 <code>Firebase와 PWA(Progressive Web App)을 바로 사용</code>할 수 있는 방법을 중점으로 포스팅하겠다.</p><p>해당 포스팅에서 다룰 내용은 간략하게 아래와 같다.</p><blockquote><ol><li>Firebase 파악하기</li><li>PWA(Progressive Web App) 파악하기</li><li>Vue를 사용하여 Prototype 만들기</li><li>Firebase의 Realtime Database를 활용한 PWA 애플리케이션 데이터 저장하기</li><li>Firebase의 Storage를 활용한 이미지 저장하기</li><li>PWA 애플리케이션을 CircleCI와 연동하여 빌드 및 배포하기</li><li>Firebase를 사용하여 PWA 애플리케이션 호스팅하기</li><li>PWA 애플리케이션을 App Store(Android, IOS)에 업로드하지 않고 모바일에 설치하기</li><li>호스팅된 PWA 애플리케이션을 Google Ananlytics를 통하여 서비스 분석하기</li></ol></blockquote><p>다룰 내용이 많아보이지만 하나의 흐름으로 흘러가기 때문에 사실상 많지는 않다.</p><p>이제 하나하나 따라해보도록 하자. 여기서 PWA의 개발은 <code>Vue</code>를 사용하였지만 <code>React</code>나 <code>Angular</code>와 같은 다른 프레임워크를 사용해도 상관없다. <code>Vue</code>에 대해서 아는 바가 없다면 <a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a>를 참고핮.</p><p>위 과정만 잘 파악한다면 앞으로 Firebase를 사용한 애플리케이션 서비스는 쉽게 할 수 있을 것이다.</p><p>그럼 이제 차근차근 보도록 하자.</p><h1 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h1><hr><p style="text-align: center;font-weight: bold">Firebase가 성공적인 앱을 빌드하고 실행하도록 도와줍니다.</p><hr><p><code>Firebase</code>는 2011년도 Firebase 사(Firebase. inc)에서 개발되어 2014년도 Google에 인수된 모바일&#x2F;웹 서비스 구축에 필요한 도구들의 모음이라고 할 수 있다. 대표적인 기능으로는 <code>사용자 인증(Authentication)</code>, <code>실시간 데이터 베이스(Realtime Database)</code>, <code>리소스 저장소(Storage)</code>, <code>호스팅(Hosting)</code>, <code>단일 함수(Functions)</code> 등이 있다.</p><p>보통 웹을 구축할 때 필요한 지식은 <code>Front-End</code>, <code>Back-End</code>, <code>Database,</code> <code>Publishing</code>, <code>Design</code> 등등으로 방대해야하지만 Firebase를 사용한다면 이 중 일부를 손쉽게 사용할 수 있다. 고도의 서버 구축 지식이 없어도 되며, 특정 OS의 커맨드를 몰라된다. 특히, 웹 서비스에 필요한 도메인 호스팅 역시 제공하므로 별도의 비용을 내면서 도메인을 구입할 필요가 없다.</p><h2 id="플랫폼"><a href="#플랫폼" class="headerlink" title="플랫폼"></a>플랫폼</h2><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-platform.png" alt="firebase-platform"></p><p>Firebase가 지원하는 플랫폼이다. Web을 포함하여 Android, IOS까지 지원하므로 웹 애플리케이션과 모바일 애플리케이션까지 지원하기에 부족함이 없다.</p><p>우리는 이번 포스팅에서 PWA(Progressive Web App)을 만들 것이기 때문에 <code>Web</code>을  사용할 것이다.</p><h2 id="Firebase의-기능"><a href="#Firebase의-기능" class="headerlink" title="Firebase의 기능"></a>Firebase의 기능</h2><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-features.png" alt="firebase-features"></p><p><code>AWS(Amazon Web Services)</code>에 비해서는 비교적 적은 기능들이지만 명확한 카테고리들로 구성되어있다.</p><p><code>Firebase</code>의 기능을 덩어리로 보자면, 앱을 개발&#x2F;구축 및 배포에 필요한 <code>Build(빌드)</code>와 애플리케이션 품질 향상에 필요한 <code>Release &amp; Monotoring(앱 품질 향상)</code> 그리고 서비스의 잠재고객, 유입, 색인 등 비즈니스 적 앱 성장에 필요한 <code>Engage(비즈니스 성장 도구)</code>로 나눌 수 있다.</p><p>하나하나 다 훑어보기에는 양이 꽤 있고 우리는 바로 배워서 바로 써 먹어야하기 때문에 <code>Build(빌드)</code> 항목만 가볍게 보기로 하자.</p><p><strong>Cloud Functions</strong></p><blockquote><ul><li>Back-End 처리시 사용되며, REST API 제작 가능</li><li>데이터 베이스 제어, 사진 및 동영상 변환, 푸시 전송</li></ul></blockquote><p><strong>Authentication</strong></p><blockquote><ul><li>사용자 계정 인증 및 등록 기능 제공</li><li>E-Mail, 전화, SNS 로그인 등의 로그인 방식 제공</li></ul></blockquote><p><strong>Hosting</strong></p><blockquote><ul><li>웹 애플리케이션 호스팅 제공</li><li>CI와 연동하여 배포 가능</li></ul></blockquote><p><strong>Cloud Storage</strong></p><blockquote><ul><li>사진 및 동영상 파일 저장 제공</li><li>기본 5GB 제공</li></ul></blockquote><p><strong>Realtime Database</strong></p><blockquote><ul><li>실시간 NoSQL 데이터 베이스 제공</li><li>연경된 모든 클라이언트와 실시간 동기화 제공</li></ul></blockquote><h1 id="PWA-Progressive-Web-App"><a href="#PWA-Progressive-Web-App" class="headerlink" title="PWA (Progressive Web App)"></a>PWA (Progressive Web App)</h1><p>모바일 영역도 웹과 같이 빠른 성장을 보이고 있다. <code>Native App</code> 부터 <code>PWA</code>까지 그 사이에는 수많은 모바일 애플리케이션은 위한 기술과 프레임워크들이 존재한다. PWA 역시 이에 속하며 엄연히 기술이라기 보다는 개념으로 보는 것이 옳다.</p><p>PWA를 설명하기 전에 몇 가지 모바일 애플리케이션을 보고 넘어가자.</p><div class="alert info no-icon"><p><strong>Native Application</strong><br><code>Native Application</code>은 모바일에 최적화 된 앱이며 앱이 구동되는 플랫폼과 밀착관계에 있다. Android는 SDK를 이용한 Java 언어로 개발되며 IOS는 IOS 기반 SDK를 이용하여 Swift로 개발된다. 여타 다른 형태의 애플리케이션보다 플랫폼과 밀착관계에 있으므로 높은 성능을 보이지만 반대로 플랫폼 및 개발 언어가 한정적이고 하나의 애플리케이션을 두 플랫폼에서 서비스하기 위해서는 중복적으로 개발을 해야한다는 단점이 있다. Native 애플리케이션은 각 플랫폼 Store에 배포하며 서비스를 하기 위해서는 플랫폼에 설치가 필요하다.</p></div><div class="alert info no-icon"><p><strong>Mobile Web Application</strong><br><code>Mobile Web Application</code>은 <code>Mobile Web</code>과 <code>Native App</code>의 장점을 가져다 만든 개념이다. 플랫폼의 브라우저를 통해 웹을 실행하는 방식으로 반응형 앱이 인기를 끌었으며, <code>SPA (Single Page Application)</code> 방식 도입으로 페이지 간 전환이 라우팅을 통해 빠르게 전환될 수 있다. 웹 앱을 실행을하므로 Native App과는 다르게 플랫폼에 설치가 불필요하다.<br>모든 클라이언트(PC, Mobile)와 브라우저 접근이 가능헀지만 Native App과 같은 친화적 터치 이벤트 구현에 어려움이 있었으며, Native App과 같이 플랫폼과 친화적이지 않기 때문에 카메라와 같은 플랫폼 API 사용에 제한이 있다.</p></div><div class="alert info no-icon"><p><strong>Hybrid Application</strong><br><code>Hybrid Application</code>은 <code>Native App</code>과 <code>Web App</code>을 합쳐놓은 것과 같다. Native App의 <code>webview</code>를 사용하여 동작되며 Native App 및 Web의 API를 사용하여 다양한 개발이 가능하다. 하지만 두 API를 사용해야하는 것과 같이 Native App 및 Web 기술 지식을 필요로한다.<br>Hybrid Application은 Webview를 사용함으로써 Native App과 다르게 하나의 개발로 모든 플랫폼 및 디바이스에서 사용이 가능하지만 퍼포먼스는 Webview의 성능과 비례한다.</p></div><p>다시 본론으로 들어가 <code>PWA (Progressive Web App)</code>에 대해 알아보자.</p><p>PWA는 <strong>Progressive Web App</strong>으로 처음에 설명했지만 <strong>PWA는 하나의 특정 기술로 생성된 새로운 기술이 아닌 일부 패턴, API, 기타 기능을 포함하는 웹 앱을 구축하는 새로운 철학</strong>으로 볼 수 있다.</p><p><code>Native App</code>과 <code>Web App</code>의 장점만 결합된 App으로 <code>Hybrid App</code>과 유사하다. 하지만 엄연히 PWA는 PWA만의 특징을 가지고 있는데 <strong>오프라인 동작</strong>, <strong>설치가 가능한 App</strong>, <strong>푸쉬 알림</strong>, <strong>쉬운 동기화</strong> 등 있으며 이러한 기능이 구현되었을 때 비로소 <code>PWA (Progressive Web App)</code>으로 볼 수 있다.</p><h2 id="PWA-특징"><a href="#PWA-특징" class="headerlink" title="PWA 특징"></a>PWA 특징</h2><p>위에서 PWA만의 특징을 몇가지 나열하였는데 가볍게 PWA의 특징에 대해서 알아보자.</p><p><strong>Secure (보안)</strong></p><blockquote><p>PWA는 HTTPS 프로토콜에서만 동작되므로 기본적 안정성 확보</p></blockquote><p><strong>Manifest</strong></p><blockquote><p><code>Manifest</code>를 통하여 애플리케이션을 홈 화면 추가함으로써 별도의 설치 없이 Native App의 사용감을 제공</p></blockquote><p><strong>Service Worker</strong></p><blockquote><p><code>Service Worker</code>를 사용하여 오프라인에서도 동작되며 백그라운드 동작으로 애플리케이션을 최신 업데이트 상태로 유지 및 캐시 상태로 빠른 리소스 로딩</p></blockquote><p><strong>Native Resource</strong></p><blockquote><p>카메라, 푸쉬 알림 등 Native App의 API 사용 제공</p></blockquote><p><strong>Performance (성능)</strong></p><blockquote><p>일반적으로 PWA를 채택하고 사용함으로써 애플리케이션 성능이 최대 300% 향상</p></blockquote><p><strong>Lightweight (경량화)</strong></p><blockquote><p>경량화</p></blockquote><p><strong>Push Notifications (푸쉬 알림)</strong></p><blockquote><p>Native App과 같은 푸쉬 알림 기능으로 사용자 경험 제공</p></blockquote><p><strong>Offline Browsing (오프라인 동작)</strong></p><blockquote><p><code>Service Worker</code> 브라우저 캐싱으로 오프라인 동작</p></blockquote><p><strong>Home Screen (홈 화면 추가)</strong></p><blockquote><p>Manifest를 통해서 설치없이 Native App과 같이 홈 화면에 추가</p></blockquote><p><strong>Platform</strong></p><blockquote><p>플랫폼에 관계없이 모든 사용자에게 동일한 사용자 경험 제공</p></blockquote><p><strong>Update</strong></p><blockquote><p><code>Service Worker</code>로 실시간으로 능동적 애플리케이션 업데이트</p></blockquote><h2 id="PWA-Success-Stories"><a href="#PWA-Success-Stories" class="headerlink" title="PWA Success Stories"></a>PWA Success Stories</h2><p>– PWA success stories 사진 –<br>PWA 개념이 나온 당시에는 <code>빠른 성능</code>이 대표되는 특징이었지만 많은 애플리케이션들이 PWA를 도입하진 않았다. 하지만 이 대표되는 특징 하나로 인해 나비효과와 같이 많은 성공을 나타내는 사례들이 생기면서 점차 서비스 되는 애플리케이션을 PWA로 전향하고 있다.</p><p>기업들 역시 Native App&#x2F;Hybrid App에서 PWA로 전환하면서 많은 이점을 얻었다.</p><div class="alert info no-icon"><p><strong>기업이 PWA 사용으로 인하여 얻은 이점</strong></p><ul><li>페이지 전환율 증가</li><li>향상된 사용자 경험</li><li>애플리케이션 유지 비용 감소</li><li>사용자 참여도 상승</li><li>홈 화면에 앱 저장</li></ul><p><strong>위 이점으로 인한 기업 수익 증가</strong></p></div><hr><p>여기까지 <code>Firebase</code>와 <code>PWA (Progressive Web App)</code>에 대한 개념을 알아보았다. 이제 애플리케이션을 만들어서 서비스를 해보도록 하자.</p><h1 id="To-Do-List-Application-만들기"><a href="#To-Do-List-Application-만들기" class="headerlink" title="To-Do List Application 만들기"></a>To-Do List Application 만들기</h1><p>만들 애플리케이션은 제일 만만한 <code>To-Do List</code>이다.</p><p>사용자 입장의 애플리케이션 기능은 다음과 같다.</p><p><strong>Features</strong></p><ol><li>사용자는 URL을 통해 애플리케이션에 접속한다. (Firebase - Hosting)</li><li>사용자는 금일 날짜의 To-Do 항목을 생성하고 적당한 타이틀 이미지를 업로드한다. (Firebase - Realtime Database &#x2F; Storage)</li><li>생성한 To-Do 항목에 할 일을 기록&#x2F;편집&#x2F;삭제한다. (Firebase - Realtime Database)</li><li>사용자는 애플리케이션에 자주 접속하기 위해 홈 화면에 추가한다 (PWA - Home Screen)</li></ol><p>그리고 개발자 입장의 개발 순서는 다음과 같다.</p><p><strong>Flow</strong></p><ol><li>애플리케이션 개발 (Manifest, ServiceWorker)</li><li>Firebase 프로젝트 생성</li><li>외부 CI 연동</li><li>Firebase hosting</li><li>Firebase Realtime Database 및 Storage 생성 및 애플리케이션 API 연동</li></ol><p>애플리케이션 예시는 To-Do List 이지만 굳이 따라하지 않고 원하는대로 해도 되며, 예제 코드는 <a href="https://github.com/kdydesign/blog-firebase-pwa-sample">firebase-pwa-sample</a>을 참고하도록하며, <strong>내부 소스 중 firebase 설정에 필요한 ID는 직접 입력</strong>하도록 하자.</p><p>소스코드에 대한 설명은 넘어가고, <code>2.Firebase 프로젝트 생성</code> 부터 진행하도록 하겠다.</p><h2 id="Firebase-프로젝트-생성"><a href="#Firebase-프로젝트-생성" class="headerlink" title="Firebase 프로젝트 생성"></a>Firebase 프로젝트 생성</h2><h3 id="Firebase-설정"><a href="#Firebase-설정" class="headerlink" title="Firebase 설정"></a>Firebase 설정</h3><p><a href="https://firebase.google.com/">Firebase 공식</a> 사이트에 접속하고 프로젝트를 생성하자.</p><p>처음 프로젝트를 생성 시 적당한 프로젝트 이름을 입력하자. 이후 필요시 애플리케이션 또는 사이트의 분석을 위해 Google Analytics 연동하자.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-1.png" alt="firebase-tutorial-1"><br><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-2.png" alt="firebase-tutorial-2"><br><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-3.png" alt="firebase-tutorial-3"></p><p>이렇게 3단계의 설정만 진행하면 하나의 프로젝트를 만들 수 있다. </p><p>프로젝트를 생성하였으니 이제 이 프로젝트에 추가할 앱을 설정하자. <code>IOS</code>, <code>Android</code>, <code>Web</code> 중 우리는 <code>Web</code>을 선택하도록 하자.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-4.png" alt="firebase-tutorial-4"></p><p>그러면 애플리케이션에 대한 닉네임, 호스팅 주소, Firebase SDK, Firebase CLI 설치 등 정보를 입력할 수 있다. </p><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-5.png" alt="firebase-tutorial-5"><br><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-6.png" alt="firebase-tutorial-6"></p><p>여기서 <code>Firebase SDK</code>의 경우 apikey, project Id 등 애플리케이션에 필요한 정보가 들어 있다. 이 정보를 예제 코드인 <a href="https://github.com/kdydesign/blog-firebase-pwa-sample">firebase-pwa-sample</a>에서 아래와 같이 입력하자.</p><p><strong>firebase.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">apiKey</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">authDomain</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">databaseURL</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">projectId</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">storageBucket</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">messagingSenderId</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">appId</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">measurementId</span>: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>이제 로컬에서 firebase를 컨트롤하기 위해 절차대로 Firebase CLI인 <code>firebase-tools</code>를 설치하자.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-7.png" alt="firebase-tutorial-7"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm i -g firebase</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm i -g firebase-tools</span><br></code></pre></td></tr></table></figure><p>Firebase CLI를 설치하였다면 명령 프롬프트를 통해서 firebase에 로그인이 가능하다. </p><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-8.png" alt="firebase-tutorial-8"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">firebase login</span><br></code></pre></td></tr></table></figure><p>예제를 생성한 프로젝트에서 <code>firebae init</code>을 통해 Firebase 프로젝트로 초기화하도록하자.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">firebase init</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/firebase-pwa-tutorial/cli-1.png" alt="cli-1"><br><img src="/2022/03/04/firebase-pwa-tutorial/cli-2.png" alt="cli-2"><br><img src="/2022/03/04/firebase-pwa-tutorial/cli-3.png" alt="cli-3"></p><p>기본적으로 <code>.firebaserc</code> 와 <code>database.rules.json</code>, <code>firebase.json</code>, <code>storage.rules</code> 파일이 생성되었을 것이다.</p><p>우리가 사용할 기능은 <code>Realtime Database</code>, <code>Hosting</code>, <code>Storage</code> 이기 때문에 각 파일들을 설정해주도록 하자.</p><p><strong>.firebaserc</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;projects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;default&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;todo-tutorial-4ccd2&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>database.rules.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;.read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;.write&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>firebase.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;database&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;database.rules.json&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;hosting&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;site&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pwa-todo-tutorial&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;public&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ignore&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;firebase.json&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;**/.*&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;**/node_modules/**&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rewrites&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;**&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;destination&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/index.html&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;storage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;storage.rules&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>여기까지 진행하였다면 웹 애플리케이션이 생성되었을 것이고 여기서 프로젝트 정보 및 애플리케이션 정보와 위에서 입력한 Firebase API 정보를 볼 수 있다.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-9.png" alt="firebase-tutorial-9"><br><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-10.png" alt="firebase-tutorial-10"><br><img src="/2022/03/04/firebase-pwa-tutorial/firebase-tutorial-11.png" alt="firebase-tutorial-11"></p><h3 id="Hosting"><a href="#Hosting" class="headerlink" title="Hosting"></a>Hosting</h3><p>호스팅의 경우 애플리케이션을 배포 할 경우 자동으로 호스팅이 된다. 또한 위에서 호스팅을 위해 배포 할 시 배포되는 정보를 <code>firebase.json</code>에 입력하였었다.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/hosting-1.png" alt="hosting-1"><br><img src="/2022/03/04/firebase-pwa-tutorial/hosting-2.png" alt="hosting-2"><br><img src="/2022/03/04/firebase-pwa-tutorial/hosting-3.png" alt="hosting-3"></p><p>배포는 아래 명령어로 실행할 수 있지만 우리는 외부 CI와 연동 할 것이다.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">firebase deploy --only hosting: pwa-todo-tutorial</span><br></code></pre></td></tr></table></figure><h2 id="Realtime-Database"><a href="#Realtime-Database" class="headerlink" title="Realtime Database"></a>Realtime Database</h2><p>Firebase에서 Realtime Database 메뉴에 접속하여 데이터베이스를 생성하자.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/realtimedatabase-1.png" alt="realtimedatabase-1"><br><img src="/2022/03/04/firebase-pwa-tutorial/realtimedatabase-2.png" alt="realtimedatabase-2"><br><img src="/2022/03/04/firebase-pwa-tutorial/realtimedatabase-3.png" alt="realtimedatabase-3"><br><img src="/2022/03/04/firebase-pwa-tutorial/realtimedatabase-4.png" alt="realtimedatabase-4"></p><p>설정을 어떻게 하여도 테스트 용도이기에 무방하지만 설정 이후 <strong>Rules</strong> 탭에서 규칙을 아래와 같이 수정하도록하자.<br>권한을 주지 않으면 이후 테스트 중 데이터베이스를 사용할 수 없다.</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;.read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;.write&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>Storage 역시 데이터베이스와 동일하게 설정하고 <strong>Rules</strong> 탭에서 규칙을 수정하도록하자.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/storage-1.png" alt="storage-1"><br><img src="/2022/03/04/firebase-pwa-tutorial/storage-2.png" alt="storage-2"><br><img src="/2022/03/04/firebase-pwa-tutorial/storage-3.png" alt="storage-3"><br><img src="/2022/03/04/firebase-pwa-tutorial/storage-4.png" alt="storage-4"></p><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">rules_version = &#x27;2&#x27;;<br>service firebase.storage &#123;<br>  match /b/&#123;bucket&#125;/o &#123;<br>    match /&#123;allPaths=**&#125; &#123;<br>      allow write: if true;<br>      allow read: if true;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>여기까지 진행하였다면 Firebase의 호스팅, Realtime Database, Storage를 모두 사용할 수 있다. 예제 프로젝트이기에 설정이 매우 간편한 편이다.</p><p>배포가 궁금하다면 미리 배포 후 URL로 접속해보도록하자.</p><h2 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h2><p>애플리케이션을 매번 수정 후 배포할 수 없기에 보통 Jenkins, Travis CI, Circle CI 등 CI의 도움을 받아 자동으로 빌드하여 배포하도록 한다.</p><p>이 포스트에서는 <a href="https://circleci.com/vcs-authorize/?return-to=https://app.circleci.com/projects/project-dashboard/github/kdydesign/">Circle CI</a>를 사용할 것이다. </p><p>Circle CI 가입 후 프로젝트를 연동해보자. CI를 사용할 때는 애플리케이션 프로젝트 경로에 <code>.circleci</code> 폴더가 있고 안에는 <code>config.yml</code>로 CircleCI에 대한 동작 방식들을 지정할 수 있다.</p><p><strong>.circleci&#x2F;config.yml</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">docker:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">circleci/node:14.9.0</span><br>    <span class="hljs-attr">working_directory:</span> <span class="hljs-string">~/repo</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">checkout</span><br>      <span class="hljs-bullet">-</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">restore_cache:</span><br>          <span class="hljs-attr">keys:</span> <span class="hljs-string">v1-dependencies-&#123;&#123;</span> <span class="hljs-string">checksum</span> <span class="hljs-string">&quot;package.json&quot;</span> <span class="hljs-string">&#125;&#125;</span><br>          <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>          <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>          <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">save_cache:</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">v1-npm-deps-&#123;&#123;</span> <span class="hljs-string">checksum</span> <span class="hljs-string">&quot;package-lock.json&quot;</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">paths:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">./node_modules</span><br>            <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>          <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>          <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">Firebase</span> <span class="hljs-string">Deploy</span><br>          <span class="hljs-attr">command:</span> <span class="hljs-string">./node_modules/.bin/firebase</span> <span class="hljs-string">deploy</span> <span class="hljs-string">--token</span> <span class="hljs-string">&quot;$FIREBASE_TOKEN&quot;</span> <span class="hljs-string">--only</span> <span class="hljs-string">hosting:pwa-todo-tutorial</span><br></code></pre></td></tr></table></figure><p>위 설정에서 맨 마지막 <code>./node_modules/.bin/firebase deploy --token &quot;$FIREBASE_TOKEN&quot; --only hosting:pwa-todo-tutorial</code> 코드를 보게 되면 빌드 후 FIREBASE에 배포하게 된다. 하지만 외부 CI에서 배포이기에 CircleCI에서 Firebase에 접근할 수 있는 권한을 줘야하기 때문에 <code>$FIREBASE_TOKEN</code>을 사용한다. 토큰은 뒤에서 설명하기로하고 우선 CircleCI와 Github를 연동하도록하자.</p><p><code>Set Up Project</code>를 클릭하여 프로젝트 설정을 진행하자.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/ci-1.png" alt="ci-1"></p><p>위에서 설명한 <code>.circleci</code> 설정을 git에 올렸다면 기존 설정을 사용할 수 있다.<br><img src="/2022/03/04/firebase-pwa-tutorial/ci-2.png" alt="ci-2"></p><p>연동이 끝나면 아래와 같이 <code>config.yml</code>에 명시한 <code>jobs</code>대로 빌드와 배포를 진행하게 된다. 하지만 위에서 설명하였듯 아직 <code>$FIREBASE_TOKEN</code>을 CircleCI에 정의하지 않았기 때문에 빌드는 실패 할 것이다.<br><img src="/2022/03/04/firebase-pwa-tutorial/ci-3.png" alt="ci-3"></p><h3 id="FIREBASE-TOKEN"><a href="#FIREBASE-TOKEN" class="headerlink" title="FIREBASE TOKEN"></a>FIREBASE TOKEN</h3><p>아래 명령어를 통해서 ci token을 생성할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">firebase ci:login<br></code></pre></td></tr></table></figure><p>웹을 통해 로그인 시 아래와 같이 token 정보가 생성된다.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-login-ci-token.png" alt="firebase-login-ci-token"></p><p>이 토큰을 Circle CI의 프로젝트 설정에 환경 변수로 지정하도록하자.</p><p><img src="/2022/03/04/firebase-pwa-tutorial/firebase-ci-token-1.png" alt="firebase-ci-token-1"><br><img src="/2022/03/04/firebase-pwa-tutorial/firebase-ci-token-2.png" alt="firebase-ci-token-2"></p><p>이렇게 되면 ci를 통해 빌드 후 Firebase에 배포까지 완료된다.</p><h2 id="PWA-workbox-설치"><a href="#PWA-workbox-설치" class="headerlink" title="PWA workbox 설치"></a>PWA workbox 설치</h2><p><a href="https://developer.chrome.com/docs/workbox/">PWA의 workbox</a>는 pwa의 service-worker 또는 캐싱 기능을 편리하게 구현할 수 있도록 지원해주는 PWA의 라이브러리이다. </p><p>workbox-cli를 통해서 기본적인 pwa의  </p><p><strong>설치</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install workbox-cli -g<br></code></pre></td></tr></table></figure><p><strong>사용</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">workbox wizard<br>workbox generateSW ./workbox-config.js<br>workbox injectManifest ./workbox-config.js<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/firebase-pwa-tutorial/workbox-1.png" alt="workbox-1"><br><img src="/2022/03/04/firebase-pwa-tutorial/workbox-2.png" alt="workbox-2"></p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/02/17/deno-tutorial/">[Deno] Node.js의 대안!! Deno 알아보기</a><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2023/09/28/electron-rce/">[Electron] ContextBridge를 사용한 Electron RCE(Remote Code Execution) 보안 취약점 수정</a><br><a href="https://kdydesign.github.io/2020/10/06/spa-route-tutorial/">Vanilla JS에서 SPA 라우팅 시스템 구현하기</a><br><a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> pwa </category>
          
          <category> firebase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> firebase </tag>
            
            <tag> pwa </tag>
            
            <tag> progressive web app </tag>
            
            <tag> aws </tag>
            
            <tag> android </tag>
            
            <tag> mobile </tag>
            
            <tag> ios </tag>
            
            <tag> web </tag>
            
            <tag> google </tag>
            
            <tag> native app </tag>
            
            <tag> mobile web app </tag>
            
            <tag> hybrid app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Deno] Node.js의 대안!! Deno 알아보기</title>
      <link href="/2022/02/17/deno-tutorial/"/>
      <url>/2022/02/17/deno-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2022/02/17/deno-tutorial/deno-tutorial-cover.png" alt="deno-tutorial-cover"></p><p>Deno를 알게 된 것은 컨퍼런스였으며, 이후 회사 업무에 녹여 넣을 수 있을지 고민하면서 Deno에 접근하게 되었다. 결론적으로 현재 회사 환경과 업무에 사용할 수는 없지만 Deno라는 기술적 가치가 매력적으로 느끼기에 사내 세미나를 진행하고 공유하게 되었다. 이렇게 공유된 내용을 Deno를 처음 접하는 사람에게도 공유하고자 포스팅을 하였다.</p><p>현재 <code>Node.js</code>는 <strong>V8 기반의 JavaScript Runtime</strong>으로 오랜 시간 자리매김해 왔으며, 그 생태계는 수셥년동안 안정화되고 확장되면서 성장해왔다. 하지만 이렇게 성장해오고 현재 JavaScript runtime의 기준이라 할 수 있는 이 Node.js에는 몇 가지 결함을 보완해야 할 점들이 있었다. 그로 인해 이러한 문제점을 이미 알고 있는 Node.js 개발자인 <code>Ryan Dahl</code>은 2018년도 <code>JSConf EU</code>에서 Node.js 설계 당시의 문제점들을 지적했고 이를 보완하는 새로운 Runtime인 <code>Deno</code>를 개발하기 시작하였다.</p><p><code>Deno</code>는 현재 1.18 버전까지 릴리즈된 상태로 활발한 개발이 이어지고 있고, 앞으로 Node.js의 대체로 사용될 가능성은 작지만 <strong>Node.js의 대안으로써 사용될 가능성이 높으며 현재 Node.js의 생태계만큼 성장할 가치가 높은 Runtime</strong>이라 생각한다.<br>Deno를 검색하게 되면 Node.js와 비교하는 글들이 많은데 같은 Runtime이며, 같은 개발자가 개발하였기에 비교 대상이 될 수밖에 없다.</p><p>이번 포스트에서도 Node.js와 Deno에 대해 알아보고 Deno의 API 사용법보다는 Deno라는 Runtime이 Node.js와 무엇이 다르고 Node.js의 문제점이 무엇이었길래 Deno로써 다시 개발되었는지 알아보도록 하자.</p><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p>Deno를 먼저 알기 전 Node.js에 대해서 알아보도록 하자.</p><p>Node.js는 워낙 유명하기기도하고 JavaScript를 다루는 개발자라면 한번은 필수로 접하는 Runtime이기에 간단하게만 설명하면 Node.js는 <strong>Chrome V8 JavaScript 엔진으로 빌드된 JavaScript Runtime</strong>이다. JavaScript 기반으로 구성된 서버 사이드 서비스를 JavaScript로 구현할 수 있게 만든 런타임이며, 추가로 <code>npm</code>은 Node.js 기반의 모듈을 모아둔 집합 저장소로 <code>Node Package Manager</code>로 볼 수 있다.</p><p>Node.js의 자세한 설명은 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념 잡기</a>를 참고하도록 하고, npm에 대해서는 <a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a>를 살펴보도록 하자.</p><p>이러한 Node.js는 대표적으로 <code>C++</code>과 <code>JavaScript</code>가 개발에 사용된 베이스 언어이다. 개발된 언어를 언급하는 것은 이 부분에서 Deno와 차이를 보이기 때문이고 해당 내용은 뒤에서 설명하도록 하겠다.</p><h1 id="Design-Mistakes-in-Node-js"><a href="#Design-Mistakes-in-Node-js" class="headerlink" title="Design Mistakes in Node.js"></a>Design Mistakes in Node.js</h1><p>Node.js 개발자 이자 Deno 개발자인 <code>Ryan Dahl</code>은 2018년 유럽에서 열린 JavaScript 컴퍼런스 인 <code>JSConf EU - 2018</code>에서 <a href="https://tinyclouds.org/jsconf2018.pdf">Design Mistakes in Node</a>라는 주제로 발표하였다. 발표 내용인 즉슨, 그가 Node.js를 개발하면서 설계에 대한 실수와 문제점에 관한 내용이었다. </p><p>그는 2012년도에 회사를 퇴사 할 때까지만 해도 Node.js는 친숙한 프레임워크로써 목표를 달성했다고 생각했다.</p><div class="alert info no-icon"><p><strong>2012년도 Node.js 목표</strong></p><ul><li>Node.js Core는 HTTP, SSL 등의 많은 프로토콜을 지원</li><li>Windows(IOCP 사용), Linux(epoll) 및 Mac(kqueue)에서 작동</li><li>비교적 작은 Core로 안정적인 API를 제공</li><li>NPM을 통해 Node.js의 외부 모듈 생태계를 성장</li></ul></div><p>하지만 점차 시간이 지나고 Node.js의 규모가 커지면서 문제점을 발견하게 되었다. 수많은 시간 동안 현재의 Node.js를 만들었지만, 본질적인 문제는 설계부터였고 되돌릴 수 없는 문제점들까지 존재하였다.</p><p>Deno는 이런 문제점들을 보완하고 해결하면서 설계된 새로운 Runtime으로 볼 수 있다. </p><p>그럼 Node.js의 문제점이 무엇이었는지 <code>Design Mistakes in Node</code>의 내용을 살펴보도록 하자. (일부 내용은 번역된 내용)</p><h2 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1. Promise"></a>1. Promise</h2><p><code>Promise</code>는 async&#x2F;await 추상화에 필수적인 요소였으며, Node.js에서 Promise의 통일된 사용은 표준화 및 async&#x2F;await 제공을 더 빠르게 진행할 수 있었다. 하지만 Node.js 개발 당시 2009년도에 Promise를 추가했지만 이후 2010년도에 Promise를 삭제하였다.</p><p>최초 Promise를 추가하였다면 하나의 통일된 API로 사용되었을 것이고 이로 인해 더욱더 빠른 속도를 제공할 수도 있었을 것이다. 그 <strong>결과 현재 <code>Node Async API</code>가 노후화</strong>되었다고 한다.</p><h2 id="2-Security"><a href="#2-Security" class="headerlink" title="2. Security"></a>2. Security</h2><p>Chrome V8 자체는 매우 좋은 보안 샌드박스였다. 하지만 Node.js는 사용자가 액세스 할 수 있는 모든 것에 엑세스가 가능하면 이는 <strong>보안 측면에서 매우 취약</strong>했다.</p><h2 id="3-Build-System-GYP"><a href="#3-Build-System-GYP" class="headerlink" title="3. Build System (GYP)"></a>3. Build System (GYP)</h2><p><code>Chrome의 V8</code> 엔진은 <code>GYP</code>를 사용하기 시작했고 Node.js 역시<code> GYP</code>를 채택하여 사용하였지만, 이후 2016년도 Chromium 프로젝트는 <code>GYP</code>에서 <code>GN</code>으로 변경하였지만 Node.js는 빌드 구성을 위해 GYP에 의존하는 현재 기본 모듈 에코시스템으로 인해 GN 채택 보류하였다. 이와 관련된 이슈는 <a href="https://github.com/nodejs/node/issues/21410">#21410 - Build node with GN</a>에서도 확인할 수 있다.</p><p>결국, Node.js는 2017년도에 GYP를 중단하게 되었으며, 현재는 <code>node-gyp</code>나 <code>node-gn</code>과 같은 애드온 빌드 도구를 이용하게 되었다.</p><blockquote><p><strong>GYP</strong><br>빌드 자동화 도구이며 파이썬으로 작성된 메타빌드 시스템</p></blockquote><blockquote><p><strong>GN</strong><br>메타빌드 시스템으로 GYP보다 20배 빠르며 모듈별 의존성을 명확하게 파악</p></blockquote><h2 id="4-package-json"><a href="#4-package-json" class="headerlink" title="4. package.json"></a>4. package.json</h2><p>Node.js는 NPM을 포함하면서 현재의 Node.js를 만들었다고도 볼 수 있다. 하지만 <strong>package.json은 너무 불필요한 정보를 포함</strong>하고 있다. <code>License</code>, <code>Repository</code>, <code>Description</code>과 같은 정보는 Boilerplate에서 필요한 정보는 아니었다. 실제로 패키지를 가져올 때 파일과 URL만 사용된 경우 이 URL 경로가 버전을 정의한다. 그러므로 종속성을 나열할 필요가 없었다. 이것은 <strong>탈중앙화를 뜻하며 Deno의 개념</strong>이기도 하였다.</p><h2 id="5-node-modules"><a href="#5-node-modules" class="headerlink" title="5. node_modules"></a>5. node_modules</h2><p><code>node_modules</code>는 모듈 간 종속성 관리, 모듈 간 문제 해결 알고리즘을 매우 복잡하게 만든다.</p><h2 id="6-js가-없는-require-“modules”-필요"><a href="#6-js가-없는-require-“modules”-필요" class="headerlink" title="6. .js가 없는 require(“modules”) 필요"></a>6. .js가 없는 require(“modules”) 필요</h2><p>js 확장자가 없는 require()는 명시적이지 않으며, js 확장자가 없다면 브라우저에서는 JavaScript가 동작하지 않는다. 즉, 스크립트 태그 src 특성에서 .js를 생략할 수는 없다. 하지만 우리는 webpack의 loader와 같은 도구를 사용하여 확장자를 명시적으로 제거할 수 있지만 이러한 모듈 로더는 사용자가 의도한 바를 추측하기 위해 여러 위치에서 파일 시스템을 쿼리해야한다.</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.some-page.com/some-package.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="7-index-js"><a href="#7-index-js" class="headerlink" title="7. index.js"></a>7. index.js</h3><p>모듈의 시작점으로 볼 수 있는 index.js는 모듈 로딩 시스템을 불필요하도록 복잡하게 만들었다. 특히 <code>package.json</code>에는 <code>main</code> 속성을 통해 모듈의 시작점이 되는 파일을 명시하므로 <code>package.json</code>을 지원하면서부터는 더욱 불필요하게 되었다.</p><p>이는 그저 <code>index.html</code>로부터 시작된 발상이었다.</p><hr><p>여기까지 Node.js와 Node.js 개발 시 실수에 대한 몇 가지를 간단하게 알아보았고 이제 이 내용을 상기하면서 Deno를 알아보도록 하자.</p><h1 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h1><p>2020년도 05월에 V1이 릴리즈되었으며 현재 버전 v1.18.x 버전으로 아직은 따끈따끈한 오픈소스이다.</p><p>Deno는 Chrome V8 엔진을 기반으로 하는 JavaScript와 TypeScript 런타임이며, Node.js의 개발자인 <code>Ryan Dahl</code>에 의해 Node.js의 내재된 많은 문제 해결을 중점적으로 설계되었고 개발되고 있다.</p><p>Node.js와는 다른 게 <code>Rust</code>로 구축되어 안전하고 빠른 것을 장점으로 꼽을 수 있다. 특히 <code>TypeScript</code>를 지원하므로 TypeScript를 사용할 시 별다른 도구 없이 바로 사용할 수 있다.</p><p>여담으로 Deno 이름의 유래는 Node의 단어를 앞뒤로 바꿔서 Deno라고 부른다고 한다.</p><h1 id="Trend"><a href="#Trend" class="headerlink" title="Trend"></a>Trend</h1><h2 id="State-of-JavaScript-award"><a href="#State-of-JavaScript-award" class="headerlink" title="State of JavaScript award"></a>State of JavaScript award</h2><p>2021 state of javascript의 JavaScript Runtime 부문을 보면 생각대로 Node.js가 압도적인 것을 알 수 있다.</p><p>Deno의 경우 고작 <code>5.6%</code>의 응답밖에 없지만 릴리즈 시기로 본다면 적은 표는 아니라고 생각한다.</p><p><img src="/2022/02/17/deno-tutorial/2021-stateofjs.png" alt="2021-stateofjs"></p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>Github의 경우를 보면 Deno의 경우 <code>Start: 80.3k</code>, <code>Fork: 4.3k</code>이며, 이에 반해 Node.js는 <code>Start: 85.5k</code>, <code>Fork: 22.8k</code>이다.</p><p>이걸로 유추해 볼 만한 정보는 크지 않지만 Deno가 릴리즈 대비 Start 수를 보면 많은 개발자들이 눈여겨 볼만큼 관심도가 높다는 걸 알 수 있다.</p><table><thead><tr><th></th><th>Deno</th><th>Node.js</th></tr></thead><tbody><tr><td>Star</td><td>80.3K</td><td>85.5K</td></tr><tr><td>Fork</td><td>4.3K</td><td>22.8K</td></tr></tbody></table><h1 id="Deno-VS-Node-js"><a href="#Deno-VS-Node-js" class="headerlink" title="Deno VS Node.js"></a>Deno VS Node.js</h1><p>Deno와 Node.js를 비교해보자.</p><p>사실 이 두 Runtime은 비교 대상이 아니다. 위에서 설명했듯이 이미 Deno 자체가 Node.js로부터 파생했다고 볼 수 있기 때문이다. 설계 자체로 본다면 잘못된 부분을 개선한 것이 Deno라고 하였지만 사실상 문제점은 Node.js 내부에서도 해결이 된 것이기 때문이다. 하지만 엄연히 두 Runtime은 기술적으로 차이를 보이기 때문에 각 Runtime의 목적성이나 개념을 뒤로하고 기술적인 차이만 보자.</p><table><thead><tr><th></th><th>Node.js</th><th>Deno</th></tr></thead><tbody><tr><td>Base Language</td><td>C++, JavaScript</td><td>Rust, TypeScript</td></tr><tr><td>Language</td><td>JavaScript</td><td>JavaScript, TypeScript</td></tr><tr><td>Package Manager</td><td>NPM</td><td>URL (.ts&#x2F;.js modules)</td></tr><tr><td>importing Package</td><td>CommonJS</td><td>ES Modules</td></tr><tr><td>Async</td><td>CallBacks(no plans to upgrade)</td><td>Promises(modern ECMAScript)</td></tr><tr><td>Security</td><td>Full Access</td><td>Permissioned Access</td></tr><tr><td>TypeScript Support</td><td>Not Built In</td><td>Built In</td></tr><tr><td>Upgrade</td><td>Installer</td><td>Command</td></tr></tbody></table><blockquote><p>** Base Language &#x2F; Language **<br>Deno의 베이스가 되는 언어는 Rust와 TypeScript이다. Rust는 다른 언어에 비해 러닝 커브가 길고 까다롭긴 하지만 매우 안정적이고 빠르다는 장점이 있다. 그렇기 때문에 Deno는 Node.js보다 안정적으로 볼 수 있으며 보안 측면에서도 보완이 되었다. 또한 TypeScript로 작성함으로써 자연스럽게 TypeScript까지 지원하도록 설계되었다.</p></blockquote><blockquote><p>** Package Manager **<br><code>Design Mistakes in Node</code>에서 언급한 <code>package.json</code>과 <code>node_modules</code>의 대안으로 Deno는 패키지 관리 시스템이 없고, URL로 처리하게 된다. 물론 뒤에 확장자는 포함한다. 이 URL의 경로가 버전 정보가 되기 때문에 package.json과 같은 명세서가 불필요하다.</p></blockquote><blockquote><p>** importing Package **<br>Deno의 목표 중 하나는 항상 최신 브라우저와의 호환성을 목표로 하며, 최신 Modern ECMAScript 기능을 지원한다. 그렇기 때문에 Deno의 모듈 import 방식은 <code>require()</code>가 아닌 ES Module을 사용하며 <code>import</code> 방식으로 사용한다.</p></blockquote><blockquote><p>** Async **<br>비동기 방식 역시 <code>Design Mistakes in Node</code>에서 언급한 내용이다.<br>Node.js의 비동기 방식은 크게 CallBacks 메커니즘으로 되어 있으며 이에 대해서 이제는 업데이트할 예정이 없다. 하지만 Deno의 경우 애초에 설계부터 Promise 방식을 지원하고 모든 비동기 작업은 Promise를 반환한다.</p></blockquote><blockquote><p>** Security **<br>가장 이슈가 되고 화두 되었던 항목이 바로 보안이다.<br>Node.js의 경우 모든 사용자가 모든 정보에 Access 할 수 있다. 하지만 Deno는 실행 환경이 되는 샌드박스 안에서 코드를 실행하는 방식으로 분리하여 권한별 접근을 허용하고 있다.</p></blockquote><div class="alert info no-icon"><p><strong>Security</strong></p><ul><li>local node_modules는 로컬 내 실행되고 로컬 내 정보에 접근할 수 있기 때문에 보안에 취약</li></ul></div><blockquote><p>** TypeScript Support **<br>Deno는 일부 TypeScript로 작성되었으며, TypeScript 지원에 필요한 도구들을 내장하고 있다. 즉, TypeScript를 사용하기 위해서 별도 외부의 모듈이 필요 없다.</p></blockquote><blockquote><p>** Upgrade **<br>Node.js의 경우 상위 버전으로 업그레이드를 하기 위해서는 설치 파일을 다운로드하여 설치하는 방법과 버전 관리 모듈인 <code>n</code>을 설치하여 업그레이드를 해야 하지만 Deno의 경우 <code>upgrade</code> 명령어를 통해서 손쉽게 업그레드할 수 있다.<br>** Deno Upgrade **</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">deno upgrade<br>deno upgrade -version &lt;new version&gt;<br></code></pre></td></tr></table></figure><h1 id="Deno의-특징"><a href="#Deno의-특징" class="headerlink" title="Deno의 특징"></a>Deno의 특징</h1><p>Deno의 특징은 결국 <code>Design Mistakes in Node</code>를 해결한 내용이다.</p><p>추가로 Deno만의 특징을 살펴보면.</p><ul><li>단일 실행 파일 제공 및 배포</li><li><strong>~25MB</strong> 압축 실행 파일만 있으면 실행 가능</li><li>Code Formatter &#x2F; Linter &#x2F; Test Runner와 같은 Utility 내장</li><li>모듈 로드를 위해 URL 사용</li><li>최초 모듈 실행 시 모듈을 캐싱하기 때문에 이후 <strong>오프라인에서도 동작</strong></li><li>Bash 또는 Python으로 작성되었을 수 있는 Utility Script 대체 가능</li><li>안정적인 Scripting과 항상 최신 브라우저와의 호환이 목표</li></ul><h1 id="Deno-Echo-System"><a href="#Deno-Echo-System" class="headerlink" title="Deno Echo System"></a>Deno Echo System</h1><p>Deno의 단점이라 하면 에코 시스템 및 커뮤니티가 부족하다는 점이다. 이는 아직 릴리즈가 얼마 안 되었기에 시간이 해결해줄 문제이다.</p><p>에코 시스템과 커뮤니티의 활성화는 개발자의 개별 개발 능력과 개발 처리 속도에 많은 영향을 주기 때문에 <strong>현재로서는 처음부터 Deno에 접근하기에는 러닝 커브가 높다.</strong></p><p>보통 Deno의 Strandard 모듈은 <a href="https://deno.land/std@0.125.0">Denoland</a>에서 직접 확인하고 사용할 수 있으며, 처음으로 시작하는 사람을 위해 몇 가지 레퍼런스를 남기겠다.</p><h2 id="Official"><a href="#Official" class="headerlink" title="Official"></a>Official</h2><ul><li><a href="https://deno.land/">Official Site</a></li><li><a href="https://doc.deno.land/builtin/stable">Deno API Reference</a></li><li><a href="https://doc.deno.land/builtin/unstable">Deno Unstable API Reference</a></li><li><a href="https://deno.land/std@0.125.0">Deno Standard Library</a></li><li><a href="https://deno.land/x">Deno Third Party Libraray</a></li></ul><h2 id="Community"><a href="#Community" class="headerlink" title="Community"></a>Community</h2><ul><li><a href="https://project-awesome.org/denolib/awesome-deno">Awesome Deno</a></li><li><a href="https://denobeginner.com/">Denobeginner.com</a></li><li><a href="https://denocode.com/">Denocode.com</a></li></ul><hr><p>여기까지 Deno에 대해서 알아보았다.</p><p>이제 Deno의 설치부터 기본적인 동작과 몇 가지 라이브러리 사용법을 알아보자.</p><h1 id="Deno-설치"><a href="#Deno-설치" class="headerlink" title="Deno 설치"></a>Deno 설치</h1><p>Deno는 종속성 없는 단일 실행 파일로 제공되며, 운영체제별 여러 설치 방법이 있다.</p><p>이외에 바이너리 파일로 설치를 원한다면 <a href="https://github.com/denoland/deno/releases">Releases Page</a>에서 다운로드하여 설치하면 된다.</p><p><strong>Shell(Mac, Linux)</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">curl -fsSL https://deno.land/install.sh | sh<br></code></pre></td></tr></table></figure><p><strong>PowerShell (Windows)</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">iwr https://deno.land/install.ps1 -useb | iex<br></code></pre></td></tr></table></figure><p><strong><a href="https://formulae.brew.sh/formula/deno">Homebrew</a> (Mac)</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew install deno<br></code></pre></td></tr></table></figure><p><strong><a href="https://community.chocolatey.org/packages/deno">Chocolatey</a> (Windows)</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">choco install deno<br></code></pre></td></tr></table></figure><p><strong><a href="https://scoop.sh/">Scoop</a> (Windows)</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">scoop install deno<br></code></pre></td></tr></table></figure><p><strong><a href="https://crates.io/crates/deno">Cargo</a></strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cargo install deno --locked<br></code></pre></td></tr></table></figure><p>Deno 설치에 있어서 필요한 기타 설치 옵션은 <a href="https://github.com/denoland/deno_install">Deno Install</a>에서 확인하자.</p><h1 id="Deno-실행"><a href="#Deno-실행" class="headerlink" title="Deno 실행"></a>Deno 실행</h1><p>설치를 완료하였으면 <code>deno</code>를 통해 확인해 보자.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno --version<br></code></pre></td></tr></table></figure><p><strong>Result</strong><br><img style="margin: 0 !important;" alt="deno-version" src="./deno-version.png"/></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno<br><br>console.log(&#x27;Hello World!&#x27;)<br></code></pre></td></tr></table></figure><p><strong>Result</strong><br><img style="margin: 0 !important;" alt="deno-hello-world" src="./deno-hello-world.png"/></p><p>Deno의 버전 또는 log가 찍힌다면 정상적으로 설치된 것이다.</p><p>이제 간단한 예제를 활용해 보자.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Deno를 설명 할 때 Deno는 패키지 관리가 없다. 모든 게 <strong>URL 기반</strong>으로 동작한다. Deno <code>std</code> 라이브러리의 예제를 실행해 보도록 하자.</p><div class="alert danger no-icon"><p>Deno는 URL 기반으로 HTTPS 프로토콜로 동작한다. 만약 <strong>실행 환경에 따라 SSL 인증이 되지 않는 경우 SSL 인증서를 무시하는 옵션</strong>을 붙여 줘야 한다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">deno run --unsafely-ignore-certificate-errors https://deno.land/std/examples/welcome.ts <br></code></pre></td></tr></table></figure></div><p><strong>welcome.ts</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno run https://deno.land/std/examples/welcome.ts<br></code></pre></td></tr></table></figure><p><strong>결과</strong><br><img style="margin: 0 !important;" alt="deno-welcome" src="./deno-welcome.png"/></p><p><code>Deno run</code>을 통해 실행하며 별다른 TypeScript 설정 없이 <code>https://deno.land/std/examples/welcome.ts</code>를 실행하였다. <code>https://deno.land/std/examples/welcome.ts</code>로 접속해 보면 실행되는 코드를 볼 수 있다.<br>Deno의 명령어는 <code>Deno -h</code>를 통해서 확인할 수 있다.</p><img alt="deno-help" src="./deno-help.png"/><h2 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h2><p>Deno는 Node.js와는 달리 <strong>실행 환경이 되는 샌드박스 안에서 코드를 실행하는 방식으로 분리하여 권한별 접근을 허용</strong>한다고 하였다.</p><p>권한별 허용이 어떻게 동작되는지 예제를 통해서 살펴보자. 예제는 <code>express</code>와 같은 간단한 로컬 서버를 실행시키는 예제이다.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno run https://deno.land/std/examples/echo_server.ts<br></code></pre></td></tr></table></figure><p><strong>결과</strong><br><img src="/2022/02/17/deno-tutorial/deno-allow-net.png" alt="deno-allow-net"></p><p>위 내용처럼 <code>error: Uncaught PermissionDenied</code> 오류가 발생할 것이다. 이는 특정 네트워크에 접근하기 위해서는 권한이 필요하다는 내용이다.</p><p>Deno는 기본적으로 안전하다. 따라서 특별히 특정 기능을 활성화하지 않는 한은 Deno로 실행되는 프로그램은 파일, 네트워크 또는 환경에 액세스할 수 없다.<br>보안에 민감한 기능에 액세스하려면 커맨드 옵션 또는 런타임 권한 프롬프트를 통해 실행 스크립트에 권한이 부여되어야 한다.</p><p>아래 명령어로 다시 실행해보도록 하자.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno run --allow-net https://deno.land/std/examples/echo_server.ts<br></code></pre></td></tr></table></figure><p><strong>결과</strong><br><img style="margin: 0 !important;" alt="deno-allow-net2" src="./deno-allow-net2.png"/></p><p><code>--allow-net</code>을 통해 네트워크 접근에 대한 권한을 부여함으로써 실행할 수 있다는 것을 알 수 있다.</p><p>Deno에는 <code>--allow-net</code>과 같이 권한을 부여하는 플래그 몇 가지를 가지고 있다. 확인해보도록 하자.</p><p><strong>Permissions list</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno run [PERMISSION FLAG] URL<br></code></pre></td></tr></table></figure><table><thead><tr><th>OPTIONS</th><th>Description</th></tr></thead><tbody><tr><td>–allow-env</td><td>환경 변수 접근 권한 허용</td></tr><tr><td>–allow-hrtime</td><td>고해상도 시간 측정 권한 허용</td></tr><tr><td>–allow-ffi</td><td>동적 라이브러리 로드 권한 허용</td></tr><tr><td>–allow-read</td><td>파일 시스템 읽기 권한 허용</td></tr><tr><td>–allow-write</td><td>파일 시스템 쓰기 권한 허용</td></tr><tr><td>–allow-run</td><td>하위 프로세스 실행 권한 허용</td></tr><tr><td>–allow-net</td><td>네트워크 접근 권한 허용</td></tr><tr><td>–allow-all, -A</td><td>모든 권한 허용</td></tr></tbody></table><p>권한과 관련된 자세한 내용은 <a href="https://deno.land/manual@v1.18.2/getting_started/permissions">Deno Permission</a>에서 확인하자.</p><h1 id="Deno-Standard-Modules"><a href="#Deno-Standard-Modules" class="headerlink" title="Deno Standard Modules"></a>Deno Standard Modules</h1><p>Deno 공식 페이지에는 <a href="https://deno.land/std@0.126.0">Standard Library</a>가 있다. 이는 외부 종속성이 없으며 Deno Core 팀에서 검토하고 반영하는 표준 모듈의 저장소이다. 기여자로서 충분히 PR(Pull Request)를 보낼 수 있으며 언제든지 사용할 수 있다. 다만 완벽하게 안정적인 버전이 아니며, API가 변경되는 항목들이 많기 때문에 Deno 버전과 맞게 호환되도록 마이그레션이 자주 필요하다.</p><p>공식 모듈에서 몇 가지를 가지고 사용하는 방법을 알아보자. 사용 방법은 복잡하지 않기 때문에 누구나 쉽게 사용할 수 있을 것이다. 참고로 <a href="https://deno.land/std@0.126.0">Standard Library</a>경로에서 <a href="https://deno.land/std@0.126.0/examples">example</a>에는 예제들이 있으니 확인해보기 바란다.</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://deno.land/std@0.126.0/http">HTTP</a> 모듈은 HTTP 클라이언트와 서버 구현을 제공하는 모듈이며, 서버, 파일 서버, HTTP 상태 코드 등 여러 항목을 제공한다.</p><p><strong>http-server.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; serve &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/std@0.126.0/http/server.ts&quot;</span>;<br><br><span class="hljs-title function_">serve</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>));<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;http://localhost:8000/&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>run</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno run --allow-net http-server.js<br></code></pre></td></tr></table></figure><p><code>http://localhost:8000</code> 접속하여 확인해보자.</p><h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><p>Node.js의 <code>fs</code> 모듈과 같은 개념이다. <a href="https://deno.land/std@0.126.0/fs">fs</a> 모듈은 파일 시스템을 조작할 수 있다.<br>파일 읽기(<code>--allow-read</code>) 및 쓰기(<code>--allow-write</code>) 권한을 필요로 한다.</p><p><strong>file.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;emptyDirSync&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;https://deno.land/std@0.126.0/fs/mod.ts&#x27;</span><br><br><span class="hljs-title function_">emptyDirSync</span>(<span class="hljs-string">&#x27;./foo&#x27;</span>) <span class="hljs-comment">// void</span><br></code></pre></td></tr></table></figure><p><strong>run</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno run --allow-read --allow-write file.js<br></code></pre></td></tr></table></figure><div class="alert danger no-icon"><p>Deno는 URL 기반으로 HTTPS 프로토콜로 동작한다. 만약 <strong>실행 환경에 따라 SSL 인증이 되지 않는 경우 SSL 인증서를 무시하는 옵션</strong>을 붙여 줘야 한다.<br><code>--unsafely-ignore-certificate-errors</code></p></div><p>해당 경로에 <code>foo</code>라는 빈 폴더가 생성되는 것을 확인할 수 있다.</p><h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p><a href="https://deno.land/std@0.126.0/datetime">datetime</a>은 날짜와 시간 구문을 생성 또는 변환하는 도구이다.</p><p><strong>datetime.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;format&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;https://deno.land/std@0.126.0/datetime/mod.ts&#x27;</span><br><br><span class="hljs-keyword">const</span> date = <span class="hljs-title function_">format</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date)<br></code></pre></td></tr></table></figure><p><strong>run</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno run datetime.js<br></code></pre></td></tr></table></figure><h1 id="Third-Party-Library"><a href="#Third-Party-Library" class="headerlink" title="Third Party Library"></a>Third Party Library</h1><p>Deno에서도 외부 모듈을 사용할 수 있다. <a href="https://deno.land/x">Third Party Library</a>는 Deno 스크립트용 호스팅 서비스로 Github에 저장된 오픈 소스 모듈의 릴리스를 캐시하고 하나의 기억하기 쉬운 도메인으로 제공한다.</p><p><code>https://deno.land/x/IDENTIFIER@VERSION/FILE_PATH</code>가 기본 형식이며, 버전을 생략하면 모듈의 가장 최신 버전이 기본적으로 사용된다.</p><p>가장 흔히 사용할 수 있는 <code>lodash</code> 모듈을 사용해보자. lodash가 제공하는 URL을 Import하여 사용해보자.</p><p><strong>deno-lodash.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;https://deno.land/x/lodash@4.17.19/lodash.js&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">max</span>([<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]))<br></code></pre></td></tr></table></figure><p><strong>run</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deno run deno-lodash.js<br></code></pre></td></tr></table></figure><h2 id="Deno-Built-In-Tooling"><a href="#Deno-Built-In-Tooling" class="headerlink" title="Deno Built-In Tooling"></a>Deno Built-In Tooling</h2><p>Deno는 TypeScript 지원에 필요한 도구들이 내장되어있어서 Deno에서 TypeScript를 사용 시 외부 도구를 추가할 필요가 없다고 하였다. TypeScript뿐만 아니라. compiler, runner, linter 등 몇 가지 도구들을 내장하고 있다.</p><table><thead><tr><th>Built-In</th><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://deno.land/manual@v1.19.0/tools/bundler">bundler</a></td><td>deno <code>bundle</code> [URL]</td><td>모든 종속성을 포함하는 단일 파일 출력</td></tr><tr><td><a href="https://deno.land/manual@v1.19.0/tools/compiler">compiling executables</a></td><td>deno <code>compile</code> [–output <OUT>] <SRC></td><td>실행 파일로 컴파일</td></tr><tr><td><a href="https://deno.land/manual@v1.19.0/tools/script_installer">installer</a></td><td>deno <code>install</code> [–output <OUT>] <SRC></td><td>실행 가능한 코드 설치 및 배포</td></tr><tr><td><a href="https://deno.land/manual@v1.19.0/tools/documentation_generator">documentaion generator</a></td><td>deno <code>doc</code></td><td>JSDoc 문서</td></tr><tr><td><a href="https://deno.land/manual@v1.19.0/tools/dependency_inspector">dependency inspector</a></td><td>deno <code>info</code> [URL]</td><td>모든 종속성 검사</td></tr><tr><td><a href="https://deno.land/manual@v1.19.0/tools/formatter">formatter</a></td><td>deno <code>fmt</code></td><td>코드 포맷터</td></tr><tr><td><a href="https://deno.land/manual@v1.19.0/tools/formatter">repl</a></td><td>deno <code>relp</code></td><td>대화식 스케폴딩 도구</td></tr><tr><td><a href="https://deno.land/manual@v1.19.0/testing">test runner</a></td><td>deno <code>test</code></td><td>javascript, typescript 단위 테스트 실행기</td></tr><tr><td><a href="https://deno.land/manual@v1.19.0/tools/linter">linter</a></td><td>deno <code>lint</code></td><td>코드 Syntax 검사</td></tr></tbody></table><hr><p>Deno에 대해 기술적으로 깊이 다루지는 않았으며, Deno의 히스토리와 기본적인 사용법에 대해 알아보았다.</p><p>Deno에 대한 결혼부터 말하자면 이 포스트의 제목과 같다.</p><hr><p style="text-align: center;font-weight: bold">Deno는 Node.js의 대체가 아닌 대안</p>- - -<p>앞으로 Deno가 어떻게 성장하고 JavaScript와 TypeScript의 생태계에 어떤 영향을 줄지는 아직 모른다.</p><p>이미 많은 생태계를 생성한 Node.js와는 다르게 이제 새싹을 핀 Deno이기 때문이다. Node.js 생태계는 수십년동안 이어져왔기 때문에 그만큼 안정적이고 진보되었다. 또한, 긴 시간 동안 많은 프로젝트에 채택되고 사용되어 왔기 때문에 사실상 표준에 가깝다.</p><p>물론 Deno의 철학과 기능은 매우 뛰어나지만, 아직 초기 단계에 불과하므로 프로젝트 진행에 필요한 기술로 채택되기는 부담이 있다. 하지만 <strong>점차적으로 많은 프로젝트가 TypeScript를 채택함과 사용 빈도가 증가함에 따라 자연스럽게 Node.js의 대안으로 사용</strong>될 것으로 생각된다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2023/09/28/electron-rce/">[Electron] ContextBridge를 사용한 Electron RCE(Remote Code Execution) 보안 취약점 수정</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/09/23/parcel-intro/">불꽃 튀게 빠른 번들러 Parcel 개념잡기!</a><br><a href="https://kdydesign.github.io/2020/09/16/nvm-for-windows/">NVM으로 Windows 환경에서 Node 버전 관리하기</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-SCOPE 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2019/04/15/electron-tutorial/">[Electron] Electron 개념부터 데스크탑 앱 만들기</a><br><a href="https://kdydesign.github.io/2020/12/23/electron-ipc-communication/">[Electron] Electron IPC 모듈로 Electron 통신 방법 파헤치기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> typescript </category>
          
          <category> nodejs </category>
          
          <category> v8 </category>
          
          <category> deno </category>
          
          <category> test framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> runtime </tag>
            
            <tag> deno </tag>
            
            <tag> nodejs </tag>
            
            <tag> typescript </tag>
            
            <tag> modern runtime </tag>
            
            <tag> v8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] Vuex VS Event Bus</title>
      <link href="/2021/01/14/vue-eventbus-vs-vuex/"/>
      <url>/2021/01/14/vue-eventbus-vs-vuex/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2021/01/14/vue-eventbus-vs-vuex/vue-eventbus-vs-vuex-cover.png" alt="vuex"></p><p>Vue에서 컴포넌트 간 통신은 <code>props</code>와 <code>emit</code>을 통해서 주고받는다.</p><p>보통 이런 관계는 상위 컴포넌트인 부모 컴포넌와 하위 컴포넌트인 자식 컴포넌트에서 가지는데 자식 컴포넌트의 깊이에 따라 <code>props</code>와 <code>emit</code>이 많아지므로 관리에 어려움이 있거나 부모-자식 관계가 아닌 전혀 다른 컴포넌트에게 파라미터 또는 값을 전달할 수가 없다는 문제점이 있다. 이런 문제점을 해결하기 위해서는 흔히 우리는 두 가지 방법을 사용한다.</p><p>첫 번째는 가장 많이 사용되는 상태 관리 패턴 라이브러리인 <strong>Vuex</strong>이다.<br><code>Vuex</code>는 Flux의 아키텍처를 따라가고 있으며, 중앙 집중식 저장소 역할을 한다. <code>Vuex</code>에 대해서는 <a href="https://kdydesign.github.io/2019/05/09/vuex-tutorial/">[Vue.JS] Vuex 개념부터 실무에서의 사용까지 배우기!!</a>를 참고하자.</p><p>두 번째 방법은 <strong>Event Bus</strong>이다.<br><code>Event Bus</code>는 특정 라이브러리나 특정 개념 또는 모듈 이름이 아닌 Vue 객체 그대로이다. Vue 객체 인스턴스를 통하여 <code>$on</code>, <code>$off</code>, <code>$emit</code> API를 사용하여 N 개의 이벤트를 등록, 호출 할 수 있는 형태이기 때문에 Bus라는 단어가 붙는다. vue에서는 이를 <code>Global Event Bus</code> 또는 <code>Global Event Hub</code>이라고 부른다.</p><p>두 방식의 공통점은 별도의 위치에서 상태를 관리하므로 <strong>비 부모-자식 간 컴포넌트 통신</strong>이 가능하다. Vuex의 경우는 중앙 집중식 상태 관리 패턴이므로 어느 컴포넌트에서나 접근이 가능하고, Event Bus의 경우 Global Event로 등록되기 때문에 역시 어느 컴포넌트에서도 접근이 가능하다.</p><p><strong>그럼 이 두 방식 중 어떤 것을 사용해야 할까?</strong></p><p>이 질문에 대한 내용을 이번 포스트에 작성해보고자 한다.</p><h2 id="Vuex-VS-Event-Bus"><a href="#Vuex-VS-Event-Bus" class="headerlink" title="Vuex VS Event Bus"></a>Vuex VS Event Bus</h2><p>결론부터 말하자면 <strong>무조건 Vuex를 사용하자</strong>. 이다.</p><p>보통 Vuex와 Event Bus와 관련된 글을 보게 되면 이런 글이 많다.</p><hr><p style="text-align: center;font-weight: bold">애플리케이션의 크기가 크면 Vuex를 사용하고 규모가 작으면 Event Bus를 사용하는 것이 좋다.</p>- - -<p>다른 블로그의 글과 개념이 틀렸다는 것이 아니다. 위의 문구 역시 맞는 말이다. 애플리케이션의 규모가 클수록 Event Bus를 사용하기엔 무리가 있다. 그럼에도 불구하고 앱의 규모가 작더라도 <strong>무조건 Vuex를 사용하자</strong>. 이제 무조건 Vuex를 사용해야 하는 몇 가지 이유를 보자.</p><h3 id="Vuex-설정의-번거로움"><a href="#Vuex-설정의-번거로움" class="headerlink" title="Vuex 설정의 번거로움"></a>Vuex 설정의 번거로움</h3><p>과거 <a href="https://cli.vuejs.org/">Vue-CLI</a>가 활성화되기 전에는 Vue 프로젝트를 생성할 때 Vuex 모듈 설치부터 파일 생성까지 하나하나 해줘야 했다. 이러다 보니 규모가 작은 애플리케이션의 경우에는 Vuex 설정보다 더 간편한 Event Bus를 추천하고는 했다. 하지만 현재에서는 Vue-CLI를 사용하면 Vuex의 구조를 잡아준다.</p><p><img src="/2021/01/14/vue-eventbus-vs-vuex/vue-cli-vuex.png" alt="vue-cli-vuex"></p><p>Vue-CLI를 통해서 vue 프로젝트를 scaffolding 할 때 이런 과정에서 Vuex 항목만 선택하면 자동으로 설치해 주는데 앱의 규모가 작더라도 Event Bus를 사용하겠는가?</p><h3 id="상태-추적"><a href="#상태-추적" class="headerlink" title="상태 추적"></a>상태 추적</h3><p>가장 중요한 부분이다.</p><p>Vuex와 Event Bus는 컴포넌트와는 별개로 전혀 다른 위치인 전역 형태로 생성된다. 그러므로 모든 컴포넌트가 접근할 수 있고 모든 컴포넌트가 수정할 수 있으며, 모든 컴포넌트가 삭제할 수도 있다. 하지만 Vuex와 Event Bus의 차이점이라면 상태 추적이다.</p><p>Vue를 다루는 개발자라면 <a href="https://github.com/vuejs/vue-devtools">vue-devtools</a>를 사용한다. 개발자 도구를 통해서 부모-자식 간의 컴포넌트를 파악하고 Vuex store의 저장 상태를 조회하고 변경 이력을 추적한다. 이 도구를 이용하면 어느 컴포넌트에서 Vuex를 사용하든 어느 정도의 추적이 가능하지만, Event Bus는 알 수가 없다. Event Bus는 상태 관리가 아닌 말 그대로 <code>event</code>에 필요한 정보를 담고 있기 때문에 패턴을 추적할 순 없다. 추적이 가능하다면 아마도 그건 vue-devtools에서 <code>Events</code> 탭 항목일 것이지만 모든 <code>$emit</code> 이벤트를 기록하기 때문에 사실상 값의 변화를 추적하기는 어렵다.</p><p><img src="/2021/01/14/vue-eventbus-vs-vuex/vue-devtool-call-event.png" alt="vue-devtool-call-event"></p><p>이렇게 상태를 추적하기 힘든 이유로 인해 애플리케이션의 규모가 작을 경우에 Event Bus를 사용하라는 것이다. 애플리케이션의 규모가 클수록 Event Bus로는 변이를 관찰하기 어렵기 때문이다.</p><h3 id="Vue-Documents"><a href="#Vue-Documents" class="headerlink" title="Vue Documents"></a>Vue Documents</h3><p>이전에 <a href="https://vuejs.org/">Vue 공식 사이트</a>에는 부모-자식 컴포넌트 간의 통신 방법의 하나로서 Event Bus를 기록하고 있었다. 하지만 현재 영문으로 되어 있는 문서에서는 Event Bus에 대한 기록이 없다.</p><p>Vue 도큐먼트는 한글로 번역된 자료가 있는데 이 자료에는 <a href="https://kr.vuejs.org/v2/guide/components.html#%EB%B9%84-%EB%B6%80%EB%AA%A8-%EC%9E%90%EC%8B%9D%EA%B0%84-%ED%86%B5%EC%8B%A0">비 부모-자식간 통신</a> 항목으로 내용이 기록되어있는 것을 확인 할 수 있다. 하지만 이 자료 역시 위에서 말한 과거 이전의 내용이다.</p><p>유추해보자면 이전에는 비 부모-자식 컴포넌트 간의 통신으로 Event Bus를 설명하고 있지만, 시간이 지나감에 따라 해당 내용을 뺐기 때문에 굳이 추천하는 방법은 아니라는 것을 생각해 볼 수 있다.</p><h3 id="Vue-Style-Guide"><a href="#Vue-Style-Guide" class="headerlink" title="Vue Style Guide"></a>Vue Style Guide</h3><p><a href="https://vuejs.org/v2/style-guide/#Rule-Categories">Vue Style Guide</a>를 보게되면 이곳에도 Event Bus에 대한 언급이 있다.</p><p><a href="https://vuejs.org/v2/style-guide/#Non-flux-state-management-use-with-caution">Non-flux state management</a>를 보게 되면 <strong>비 플럭스 상태 관리의 우선순위 규칙은 D로 주의해서 사용</strong>해야한다는 내용이다. </p><p>Global Event Bus가 대부분의 애플리케이션에 적합하지 않다고 경고하고 있으며, 상태 관리는 Vuex를 사용하기를 유도하고 있다.</p><p><img src="/2021/01/14/vue-eventbus-vs-vuex/vue-style-guide.png" alt="vue-style-guide"></p><hr><p>Vuex 대신 Event Bus를 사용한다고 하더라도 애플리케이션에 큰 변화를 가져오는 것은 아니다. 하지만 항상 애플리케이션을 개발할 때 고도화와 유지 관리를 생각해야 한다. 시작은 작은 규모의 애플리케이션 일지라도 마지막은 규모가 큰 애플리케이션이 될 수도 있다. 그때서야 Event Bus를 Vuex로 포팅하기엔 이미 <code>$emit</code>, <code>$on</code>, <code>$off</code>의 Hell이 되어있을 것이다. 이런 걸 고려하더라도 Vuex를 사용하는 것이 좋을 것이다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vue-store-state/">Vuex Store의 state를 효율적으로 초기화하기</a><br><a href="https://kdydesign.github.io/posts/vue-component.html">Vue.JS Component 개념을 익히고 만들어보자!!</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2020/11/13/vuejs-provide-inject/">Vue Component provide&#x2F;inject 이해하기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> framework </category>
          
          <category> vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> vue.js </tag>
            
            <tag> vuex </tag>
            
            <tag> vuex tutorial </tag>
            
            <tag> vue.js tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Electron] Electron IPC 모듈로 Electron 통신 방법 파헤치기</title>
      <link href="/2020/12/23/electron-ipc-communication/"/>
      <url>/2020/12/23/electron-ipc-communication/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/12/23/electron-ipc-communication/electron-ipc-communication-cover.png" alt="cover"></p><p>Electron의 IPC 개념은 Electron에서 자주 사용되는 기술이다.</p><p><code>ipcMain</code>과 <code>ipcRenderer</code>를 사용하여 <code>Main 프로세스</code>와 <code>Renderer 프로세스</code> 간에 통신을 할 수 있기 때문이다.</p><p>이런 개념을 빗대어 보자면 웹 기술에서 Back-End와 Front-End 간 통신을 하기 위해서 그에 맞는 특정 모듈과 기술이 필요하다. Electron에서도 이러한 개념을 담당하는 것이 <code>IPC</code> 모듈이다. 다른 예로 Vue를 다뤄본 사람이라면 <code>Event Bus</code> 개념이나 <code>Props</code> 개념을 알고 있을 텐데 이때 <code>@event(&#39;eventName&#39;)</code>으로 이벤트를 수신하고 <code>$emit(&#39;eventName&#39;)</code>으로 이벤트를 송신하는 것을 볼 수 있는데 이와 비슷한 개념으로 볼 수 있다.</p><p>Electron 공식 문서의 용어 정리 부분을 보면 <code>IPC</code>에 대하여 이렇게 기록하고 있다.</p><hr><p style="text-align: center;font-weight: bold"> IPC는 프로세스 간 통신을 의미한다. </p><p style="text-align: center;font-weight: bold">Electron은 IPC를 사용하여 Main 프로세스와 Renderer 프로세스 간에 직력화 된 JSON 메시지는 동기적 또는 비동기적으로 통신한다.</p>- - -<p>통신이란 의미는 글로만 봐서는 파악하기 힘들다.</p><p>이번 포스트에서는 이 IPC 모듈에 관한 내용을 알아보고 실제로 간단한 앱을 만들면서 파악해보도록 하자.</p><hr><h2 id="IPC-모듈"><a href="#IPC-모듈" class="headerlink" title="IPC 모듈"></a>IPC 모듈</h2><p><code>IPC</code>는 위에서 설명했듯이 프로세스 간 통신을 의미한다. 여기서 프로세스란 <code>Main 프로세스</code>와 <code>Renderer 프로세스</code>를 의미한다.</p><p>예를 들어 Main 프로세스는 서버로 생각하고 Renderer 프로세스는 브라우저라고 생각한다면 서버와 브라우저 간 통신을 하기 위한 규약이 필요하다. 이를 Electron에서는 <code>IPC</code>가 처리하고 있다.</p><p>IPC는 <code>on</code>을 통해 메시지 또는 이벤트를 수신하고 <code>send</code>를 통해 메시지 또는 이벤트를 전달한다. 이 점을 기억하도록 하자.</p><p><img src="/2020/12/23/electron-ipc-communication/ipc-process.png" alt="electron-ipc-process"></p><p><strong>ipcMain에서 <code>on</code>을 통한 이벤트 수신</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;CHANNEL_NAME&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt, payload</span>) =&gt;</span> &#123; &#125;)<br></code></pre></td></tr></table></figure><p><strong>ipcRenderer에서 <code>send</code>을 통한 이벤트 송신</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">ipcRenderer.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;CHANNEL_NAME&#x27;</span>, <span class="hljs-string">&#x27;message&#x27;</span>)<br></code></pre></td></tr></table></figure><p>여기서 <code>Main 프로세스</code>와 <code>Renderer 프로세스</code>의 정의만 잠깐 짚고 넘어가자.</p><h3 id="Main-Processor"><a href="#Main-Processor" class="headerlink" title="Main Processor"></a>Main Processor</h3><p><code>Main 프로세스</code>는 일반적으로 우리가 Electron으로 개발할 때 생성하는 <code>main.js</code>로 볼 수 있다.<br><strong>이는 Electron 앱의 진입점이기도 하며, 앱의 Life Cycle을 관리</strong>한다. 뿐만 아니라 애플리케이션에서 사용되는 메뉴, Dock, 트레이와 같은 네이티브 요소를 관리하며 Main 프로세스는 앱에서 각각의 새로운 Renderer 프로세스를 생성한다.</p><p>Chromium에서 이러한 개념을 Browser 프로세스라 하며, Electron에서는 <strong>Renderer 프로세스와 혼동을 피하고자 Main 프로세스</strong>라 명명한다. 즉, Main 프로세스는 Electron 시스템 내 동작하는 애플리케이션을 제어하는 프로세스로 볼 수 있다.</p><p>현재 Electron 11.x 버전에서는 아래와 같은 Main 프로세스 모듈이 존재한다.</p><blockquote><ul><li>app</li><li>autoUpdater</li><li>BrowserView</li><li>contentTracing</li><li>dialog</li><li>globalShortcut</li><li>inAppPurchase</li><li><strong>ipcMain</strong></li><li>Menu</li><li>MenuItem</li><li>net</li><li>netLog</li><li>nativeTheme</li><li>Notification</li><li>powerMonitor</li><li>powerSaveBlocker</li><li>protocol</li><li>screen</li><li>session</li><li>systemPreferences</li><li>TouchBar</li><li>Tray</li><li>webContents</li><li>webFrameMain</li></ul></blockquote><h3 id="Renderer-Processor"><a href="#Renderer-Processor" class="headerlink" title="Renderer Processor"></a>Renderer Processor</h3><p><code>Renderer 프로세스</code>는 Electron 앱의 Chromium 기반의 브라우저 창을 관리하는 모듈이다.</p><p><strong>Main 프로세스와 달리 Renderer 프로세스는 여러 개가 존재할 수 있으며, Main 프로세스와는 1:N의 관계를 맺는다.</strong></p><p>현재 Electron 11.x 버전에서는 아래와 같은 Main 프로세스 모듈이 존재한다.</p><blockquote><ul><li>desktopCapturer</li><li><strong>ipcRenderer</strong></li><li>remote</li><li>webFrame</li></ul></blockquote><hr><p>이제 다시 돌아와서 <code>IPC</code>에 대해 알아보자.</p><p>위에서 설명했듯이 <code>IPC</code>는 <code>ipcMain</code>과 <code>ipcRenderer</code> 모듈 두 가지로 구분된다.</p><h2 id="ipcMain"><a href="#ipcMain" class="headerlink" title="ipcMain"></a>ipcMain</h2><p><code>ipcMan</code> 모듈은 Renderer 프로세스(웹 페이지)가 보내는 메시지 또는 이벤트를 동기적 혹은 비동기적으로 처리한다. 즉, 웹 페이지를 처리하는 프로세스인 Renderer 프로세스가 보내는 메시지를 Main 프로세스는 수신하여 처리하게 된다.</p><p>아래에서 <code>ipcRenderer</code>를 보면 알겠지만 보통 <strong>ipcMain에서는 IPC 통신을 할 때 수신만 할 수 있다.</strong><br>위에서 이벤트 수신은 <code>on</code>이며 송신은 <code>send</code>라 하였지만, ipcMain에서는 <code>on</code>으로 송신을 하며 <code>send</code>가 아닌 <code>reply</code>로 회신하는 것이다.</p><p>아래 예제를 보자.</p><p><strong>ipcMain에서 <code>on</code>을 통한 이벤트 수신</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; ipcMain &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br><span class="hljs-comment">// ipcMain에서의 이벤트 수신</span><br>ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;CHANNEL_NAME&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt, payload</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(payload)<br>  <br>  evt.<span class="hljs-title function_">reply</span>(<span class="hljs-string">&#x27;IPC_RENDERER_CHANNEL_NAME&#x27;</span>, <span class="hljs-string">&#x27;message&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>위 예제에서 <code>CHANNEL_NAME</code>은 메시지를 송신할 이름을 말하며 <code>channel</code>이라고 한다. 어느 ipcRenderer 프로세스에서 <code>CHANNEL_NAME</code>으로 메시지를 수신하였고 ipMain 프로세스는 ‘CHANNEL_NAME’로 송신하였다. 그리고 다시 <code>reply</code>를 통하여 송신 후 다시 응답하였다.</p><p>이 응답의 <code>channel</code> 이름은 <code>IPC_RENDERER_CHANNEL_NAME</code>이다. 이렇게 응답을 하였기에 어느 ipcRenderer 프로세서는 <code>on</code>을 통하여 <code>IPC_RENDERER_CHANNEL_NAME</code> 채널로 수신할 것이다.</p><p>기능 측면에서 <code>send</code>의 개념도 가능하다. 하지만 ipcMain 프로세스는 ipcRenderer와 같은 <code>send</code> 메소드를 가지고 있진 않다. <code>send</code>를 하기 위해서는 <a href="https://www.electronjs.org/docs/api/web-contents#contentssendchannel-args">webContents.send</a>를 이용해야 한다.</p><p><strong>webContents.send를 이용한 send 방식</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br>app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123; <br>    <span class="hljs-comment">// options </span><br>  &#125;)<br>  <br>  win.<span class="hljs-property">webContents</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;IPC_RENDERER_CHANNEL_NAME&#x27;</span>, <span class="hljs-string">&#x27;message&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>ipcMain이 될 수 있는 <code>main.js</code>에서 <code>IPC_RENDERER_CHANNEL_NAME</code> 채널명으로 수신하고 있다. 이는 어느 ipcRenderer에서 <code>IPC_RENDERER_CHANNEL_NAME</code> 채널명으로 송신을 받고 이후의 처리를 할 수 있을 것이다.</p><p>이렇게 되면 ipcMain에서도 ipcRenderer와 동일하게 메시지를 송신할 수 있다.</p><h2 id="ipcRenderer"><a href="#ipcRenderer" class="headerlink" title="ipcRenderer"></a>ipcRenderer</h2><p><code>ipcRenderer</code> 모듈은 Renderer 프로세스(웹 페이지)에서 Main 프로세스로 동기 또는 비동기 메시지를 보낼 수 있다. Main 프로세스에서 webContents.send 로 메시지를 보냈다면 수신 역시 가능하다.</p><p>보통 웹 페이지 딴에서 HTTP 통신을 통해 받아온 데이터를 보내거나 Main 프로세스를 호출할 경우 사용되며, <code>send</code>를 통해 송신하고 <code>on</code>을 통해 수신한다.</p><p><strong>ipcRenderer에서 <code>send</code>을 통한 이벤트 송신</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; ipcRenderer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br><span class="hljs-keyword">const</span> payload = <span class="hljs-string">&#x27;message&#x27;</span><br><br><span class="hljs-comment">// ipcRenderer에서의 이벤트 송신</span><br>ipcRenderer.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;CHANNEL_NAME&#x27;</span>, payload)<br></code></pre></td></tr></table></figure><p>지금까지 IPC 통신 방법 중 수신이 가능한 <code>on</code>과 송신이 가능한 <code>send</code>에 대해서 설명만 했지만, 이외에도 IPC와 관련된 API들은 많다. 이것에 대해서는 <a href="https://www.electronjs.org/docs/api/ipc-main">Electron API 문서 - ipcMain</a>와 <a href="https://www.electronjs.org/docs/api/ipc-renderer">Electron API 문서 - ipcRenderer</a>를 참고하도록 하자.</p><h2 id="예제-만들기"><a href="#예제-만들기" class="headerlink" title="예제 만들기"></a>예제 만들기</h2><p>이제 실제로 예제를 만들면서 <code>ipcMain</code>과 <code>ipcRenderer</code> 모듈이 어떻게 동작하는지 알아보도록 하자.</p><p>예제의 동작은 최초 Electron이 구동되면 <code>WenContent.send</code>를 통해서 Renderer 프로세스(웹 페이지)에 정보를 보낼 것이다. 이후 웹 페이지에서는 값을 입력하고 버튼을 클릭하면 입력된 값을 다시 Main 프로세스로 전달할 것이다. 이렇게 전달받은 값은 다시 변형하여 Renderer 프로세스로 전달하는 과정을 만들 것이다.</p><h3 id="환경-구축"><a href="#환경-구축" class="headerlink" title="환경 구축"></a>환경 구축</h3><p>가장 빠른 방법. <code>electron-quick-start</code> boilerplate를 통해서 구축하자.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/electron/electron-quick-start<br><br>cd electron-quick-start<br>npm install<br>npm run start<br></code></pre></td></tr></table></figure><h3 id="코드-수정"><a href="#코드-수정" class="headerlink" title="코드 수정"></a>코드 수정</h3><p>먼저 <code>index.html</code>을 열어 아래와 같이 수정하자.</p><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./renderer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">     <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text-input&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>computed input value =&gt; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><br><span class="hljs-tag">     <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text-box&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span></span><br><span class="hljs-tag">  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>간단하게 input과 button 그리고 텍스트를 출력할 수 있는 영역을 두었다.</p><p>그다음 <code>renderer.js</code>를 수정하자.</p><p><strong>renderer.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; ipcRenderer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> btnEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><br>  btnEl.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> inputValue = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text-input&#x27;</span>).<span class="hljs-property">value</span><br><br>    <span class="hljs-comment">// onInputValue 이벤트 송신</span><br>    ipcRenderer.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;onInputValue&#x27;</span>, inputValue)<br>  &#125;)<br><br>  <span class="hljs-comment">// replyInputValue에 대한 응답 수신</span><br>  ipcRenderer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;replyInputValue&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt, payload</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text-box&#x27;</span>).<span class="hljs-property">textContent</span> = payload<br>  &#125;)<br><br>  <span class="hljs-comment">// onWebcontentsValue에 대한 이벤트 수신</span><br>  ipcRenderer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;onWebcontentsValue&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt, payload</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text-box&#x27;</span>).<span class="hljs-property">textContent</span> = payload<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>최초 페이지가 로드되면 <code>onWebcontentsValue</code>를 통해서 텍스트를 설정할 것이다. 이후 input에 값을 입력하고 버튼을 클릭하면 해당 값이 <code>onInputValue</code>를 통해서 Main 프로세스로 송신될 것이다. 이렇게 송신된 이벤트는 Main 프로세스에서 값을 가공하여 <code>replyInputValue</code>를 통해 응답할 것이고 Renderer 프로세스에서는 이를 받아 텍스트를 출력할 것이다.</p><p>이제 Main 프로세스에서 송신과 수신을 지정하자.</p><p><strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span>, ipcMain &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWindow</span> () &#123;<br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,<br>    <span class="hljs-attr">webPreferences</span>: &#123;<br>      <span class="hljs-attr">preload</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;preload.js&#x27;</span>),<br>      <span class="hljs-attr">nodeIntegration</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;)<br><br>  mainWindow.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br><br>  <span class="hljs-comment">// 웹 페이지 로드 완료</span><br>  mainWindow.<span class="hljs-property">webContents</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;did-finish-load&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// onWebcontentsValue 이벤트 송신</span><br>    mainWindow.<span class="hljs-property">webContents</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;onWebcontentsValue&#x27;</span>, <span class="hljs-string">&#x27;on load...&#x27;</span>)<br>  &#125;)<br>&#125;<br><br>app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">createWindow</span>()<br><br>  app.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">BrowserWindow</span>.<span class="hljs-title function_">getAllWindows</span>().<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-title function_">createWindow</span>()<br>  &#125;)<br><br>  <span class="hljs-comment">// onInputValue 이벤트 수신</span><br>  ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;onInputValue&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt, payload</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;on ipcMain event:: &#x27;</span>, payload)<br><br>    <span class="hljs-keyword">const</span> computedPayload = payload + <span class="hljs-string">&#x27;(computed)&#x27;</span><br><br>    <span class="hljs-comment">// replyInputValue 송신 또는 응답</span><br>    evt.<span class="hljs-title function_">reply</span>(<span class="hljs-string">&#x27;replyInputValue&#x27;</span>, computedPayload)<br>  &#125;)<br>&#125;)<br><br>app.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;window-all-closed&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">platform</span> !== <span class="hljs-string">&#x27;darwin&#x27;</span>) app.<span class="hljs-title function_">quit</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p>위와 같이 수정 후 아래 코드를 보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">mainWindow.<span class="hljs-property">webContents</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;did-finish-load&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// onWebcontentsValue 이벤트 송신</span><br>  mainWindow.<span class="hljs-property">webContents</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;onWebcontentsValue&#x27;</span>, <span class="hljs-string">&#x27;on load...&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>이 코드는 Renderer 프로세스에서 웹 페이지가 완료 후에 호출되는 이벤트이다. 이때 Main 프로세스에서는 <code>webcontents.send</code>를 통해서 최초에 ipc 통신을 하는 것이다.<br>이와 같이 Main 프로세스에서도 <code>reply</code>가 아닌 <code>send</code>를 통해서 ipc 통신 시 송신이 가능하다.</p><p>위 코드에서 <code>BrowserWindow</code>객체를 생성 시 <code>nodeIntegration: true</code>를 지정한 이유는 <code>renderer.js</code>에서 <code>require</code>를 통해 electron 모듈을 호출하기 위해서이다.</p><h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><p><code>main.js</code>를 수정하였으므로 <code>npm run start</code>를 통해 다시 구동해보자.</p><p><img src="/2020/12/23/electron-ipc-communication/electron-run.png" alt="electron-run"></p><p><code>webcontent.send</code>를 통해서 최초에 값을 전달 했기 때문에 <code>on load</code>가 출력되는 것을 볼 수 있다.</p><p>이제 input 박스에 값을 입력하고 버튼을 클릭해 보자.</p><p><img src="/2020/12/23/electron-ipc-communication/electron-input-run.png" alt="electron-input-run"></p><p>예제에서는 <code>test</code>를 입력하고 버튼을 클릭하니 결과값은 <code>test(computed)</code>로 출력되었다. 이는 Main 프로세스에서 수신받은 payload를 가공하여 다시 송신하였기 때문이다.</p><p><strong>수신받은 payload를 가공하여 응답</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// onInputValue 이벤트 수신</span><br>  ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;onInputValue&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt, payload</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;on ipcMain event:: &#x27;</span>, payload)<br><br>    <span class="hljs-keyword">const</span> computedPayload = payload + <span class="hljs-string">&#x27;(computed)&#x27;</span><br><br>    <span class="hljs-comment">// replyInputValue 송신 또는 응답</span><br>    evt.<span class="hljs-title function_">reply</span>(<span class="hljs-string">&#x27;replyInputValue&#x27;</span>, computedPayload)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>여기서 console.log를 남겼기 때문에 콘솔을 확인해보자.</p><p><img src="/2020/12/23/electron-ipc-communication/computed-ondata.png" alt="computed-data"></p><p>콘솔 로그를 보면 입력된 값이 그대로 출력되는 것을 확인할 수 있다.</p><hr><p>이렇게 Electron에서 <code>IPC</code> 통신에 대해서 개념과 예제를 통해서 알아보았다.</p><p>정리를 하면 <code>IPC</code>는 Electron에서 프로세스 간의 통신 방법을 말하며, 모듈에는 <code>icpMain</code>과 <code>Renderer 프로세스가</code>가 있다. 서로 간의 이벤트 수신은 <code>on</code>이며, 송신은 <code>send</code>이다. 이외에 <code>webContents.send</code>가 있다.</p><p>IPC 통신은 프로세스 간 통신 방법이기에 많이 사용된다. 하지만 중요한 건 Electron은 웹 애플리에션에서 하나의 애플리케이션에 REST API가 같이 있는 격이다. 파일별 분리. API의 설계. 등 구조적으로 잘 관리가 되지 않으면 복잡해질 수 있다.<br>정리가 되지 않고 구조적이지 않으면 이후에 수만은 IPC 모듈에서 수신 및 송신의 코드 추적이 어려워진다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2023/09/28/electron-rce/">[Electron] ContextBridge를 사용한 Electron RCE(Remote Code Execution) 보안 취약점 수정</a><br><a href="https://kdydesign.github.io/2019/04/15/electron-tutorial/">Electron 개념부터 데스크탑 앱 만들기</a>)<br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> npm </category>
          
          <category> electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> electron </tag>
            
            <tag> electron.js </tag>
            
            <tag> electron 배우기 </tag>
            
            <tag> electron 튜토리얼 </tag>
            
            <tag> electron tutorial </tag>
            
            <tag> electron framework </tag>
            
            <tag> electron 설치 </tag>
            
            <tag> electron ipc 통신 </tag>
            
            <tag> electron ipcMain </tag>
            
            <tag> electron ipcRenderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA를 사용하여 페어 프로그래밍(Pair Programming)하기!</title>
      <link href="/2020/12/03/intellij-pair-programming/"/>
      <url>/2020/12/03/intellij-pair-programming/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/12/03/intellij-pair-programming/intellij-pair-programming-cover.png" alt="intellij-pair-programming-cover"></p><p>IntelliJ가 이번 2020-12-01에 <code>2020.03</code> 버전이 배포되었다. 이번 버전이 출시되면서 추가된 기능 중 하나가 <strong>공동 개발</strong> 항목이다. 타이틀은 <code>Code Width Me(EAP) 지원</code>이다.</p><p><code>Code Width Me(EAP)</code>는 IDE에 열려 있는 프로젝트를 다른 사람과 공유하며 실시간으로 공동 작업을 수행할 수 있다. 즉, 이를 사용하며 <code>페어 프로그래밍(Pair Programming)</code>이 가능하다. 이번 포스팅에서 이 **IntelliJ를 사용하여 페어 프로그래밍(Pair Programming)**을 하는 방법을 알아보려 한다.</p><h2 id="지원-버전"><a href="#지원-버전" class="headerlink" title="지원 버전"></a>지원 버전</h2><p>사실상 지원되는 버전은 <code>2020.03</code>버전이다. 이는 IntelliJ 뿐만 아니라 <code>Pycham</code>, <code>WebStorm</code> 등 <code>JetBrains</code> 제품군 모두 같다. 하지만 2020.03 이하 버전에도 플러그인 형태로 사용이 가능하다. 현재 안정된 버전인 <code>2020.02</code>에 <code>Code With Me</code> 플러그인이 도입되어 있어서 플러그인으로 설치 후 사용할 수 있다.</p><p>자세한 내용은 <a href="https://blog.jetbrains.com/blog/2020/10/23/code-with-me-jetbrains-ides-v2020-3/">Code With Me Adds Support for JetBrains IDEs v2020.3</a>를 참고하자.</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>먼저 intellij 2020.03으로 업데이트 했어도 플러그인 형태로 설치하면 된다.</p><p><strong><em>File &gt; Settings &gt; Plugins &gt; Marketplace</em></strong>로 이동하여 <code>Code With Me</code>를 검색하여 설치 후 IDE를 재실행하자.</p><p><strong>Plugins</strong><br><img src="/2020/12/03/intellij-pair-programming/intellij-plugin.png" alt="intellij-plugins"></p><p>또는 <a href="https://plugins.jetbrains.com/plugin/14896-code-with-me">Code With Me</a>에서 브라우저를 통해 설치할 수 있다.</p><h2 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h2><p>플러그인을 설치하고 재시작을 했다면 상단에 아이콘이 추가되었을 것이다.</p><p><strong>Code With Me</strong><br><img src="/2020/12/03/intellij-pair-programming/code-with-me-icon.png" alt="code-with-me-icon"></p><p>이제 이 아이콘을 통해서 내 IDE에 접속을 허용하거나 다른 IDE에 접속할 수 있다.</p><p>기능을 확인해 보자.</p><div class="alert info no-icon"><ul><li><strong>Enable Access and Copy Invitation Link</strong> : 내 IDE를 활성화하여 접근할 수 있도록한다.</li><li><strong>Join Another IDE as Participant</strong> : 다른 IDE에 접속한다.</li><li><strong>Submit ‘Code With Me’ Feedback</strong> : Code With Me에 대한 Log를 전송한다.</li><li><strong>Permissions</strong> : 내 IDE 접속 권한 설정을 한다.</li></ul></div><p><strong>Enable Access and Copy Invitation Link</strong>를 클릭하게 되면 접속 권한 설정창이 활성화된다.</p><p><img src="/2020/12/03/intellij-pair-programming/code-with-me-permission.png" alt="code-with-me-permission"></p><p>여기서 내 IDE에 접속할 권한을 설정하는데 읽기모드부터 모든 권한까지 설정 할 수 있다. 본인이 원하는 권한을 설정 후 <code>Enable Access</code>를 클릭하자. 예제에서는 Full Access로 진행하겠다.</p><p><img src="/2020/12/03/intellij-pair-programming/access-code-with-me.png" alt="access-code-with-me"></p><p>code-with-me를 활성화하게 되면 <code>Copy Invitation Link</code>와 <code>Turn Off Access and Disconnect All</code> 메뉴가 활성화된다.</p><p><code>Copy Invitation Link</code>를 클릭하면 현재 내 IDE 고유 키가 복사된다. 이 키들은 JetBrains에 로그인한 사용자의 고유 URL이며, <code>Join Another IDE as Participant</code>를 통해 다른 IDE에 접속할 때 입력하여 사용하게 된다.</p><p>여기서 특이한 점은 JetBrains 제품이 없더라도 <strong>이 URL을 브라우저에 입력하면 <code>Code With Me</code> 실행기를 다운로드하여 실행까지 가능</strong>하다.</p><p><img src="/2020/12/03/intellij-pair-programming/code-with-me-browser.png" alt="code-with-me-browser"></p><p>실행하게 되면 접속이 된 상태이며, IDE 접속은 1:N으로 접속이 되고 접속 시 접속된 사용자가 No one Joined 영역에 표시된다.</p><p><img src="/2020/12/03/intellij-pair-programming/join-user.png" alt="join-user"></p><p>여기서 접속 사용자를 누르게 되면 현재 접속된 사용자 커서가 어느 파일 어느 소스에 위치하고 있는지 Jump가 가능하다.</p><p><img src="/2020/12/03/intellij-pair-programming/jump-to-source.png" alt="jump-to-source"></p><hr><p>페어 프로그래밍(Pair Programming) 위한 도구와 방법은 많지만, 조직이나 그룹에서 JetBrains 제품을 사용하면 사용하는 도구를 가지고 바로 사용하기 때문에 다른 애플리케이션을 이용하지 않아도 된다. 사용하다 보면 생각보다 성능도 나쁘지 않기 때문에 페어 프로그래밍이 필요한 경우 사용하면 좋을 듯하다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a><br><a href="https://kdydesign.github.io/2020/09/16/nvm-for-windows/">NVM으로 Windows 환경에서 Node 버전 관리하기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
          <category> intellij </category>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> intellij </tag>
            
            <tag> tools </tag>
            
            <tag> pair programming </tag>
            
            <tag> intellij 2020.03 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</title>
      <link href="/2020/11/27/lerna-changelog/"/>
      <url>/2020/11/27/lerna-changelog/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/11/27/lerna-changelog/lerna-changelog-cover.png" alt="lerna-changelog-cover"></p><p><code>Mono-Repo</code>를 생성할 수 있는 도구인 <code>Lerna</code>에서 <code>CHANGELOG</code>를 생성하는 방법에 대하여 알아보자.</p><p>Mono-Repo 구조에서는 패키지가 다르기 때문에 서로 다른 CHANGELOG를 생성해야 한다. 이를 위해서 lerna의 명령어인 <code>lerna version</code>을 사용하여 생성할 수 있다. 물론 이를 더 쉽게 생성해 줄 수 있는 <a href="https://github.com/lerna/lerna-changelog">lerna-changelog</a>라는 훌륭한 오픈 소스가 있지만 이번 포스트에서 순수하게 <code>lerna version</code>을 사용하여 내 입맛대로 릴리즈 노트를 작성하는 방법에 대해 말해보려 한다.</p><p>lerna를 사용하여 직접 Mono-Repo 구조를 생성하고 수정과 commit, 그리고 push를 통하여 Git에 반영 후 CHANGELOG를 생성하는 방법을 배워보자.</p><p>먼저 이번 포스팅을 보기 전 Mono-Repo와 Lerna에 대한 설명은 <a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a>와 <a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a> 참고하도록 하자.</p><h1 id="예제-프로젝트-생성"><a href="#예제-프로젝트-생성" class="headerlink" title="예제 프로젝트 생성"></a>예제 프로젝트 생성</h1><p>예를 위해 간단하게 Mono-Repo 구조를 가진 프로젝트와 패키지를 생성하고 기본적으로 필요한 모듈을 설치해보도록 하겠다. 그리고 <strong>실제 Github에 commit과 push가 필요하므로 적당한 Repository를 하나 생성해 놓도록 하자.</strong></p><p>먼저 <code>lerna</code> 사용을 위해 설치를 진행하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g lerna<br></code></pre></td></tr></table></figure><p>그리고 <code>lerna-changelog-example</code> 폴더를 생성한 다음 해당 경로에서 prompt를 열고 git을 먼저 연동하자. </p><div class="alert info no-icon"><p>lerna는 기본적으로 git과 연동된 상태에서 사용할 수 있다.</p></div><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git init<br>git remote add origin [REPOSITORY_URL]<br></code></pre></td></tr></table></figure><p>git을 사용할 준비가 되었다면 <code>.gitignore</code>를 생성하여 commit을 제외하도록 하자.</p><p><strong>.gitignore</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">.idea<br>node_modules<br></code></pre></td></tr></table></figure><p><code>package.json</code>과 <code>lerna.json</code>을 수정하자.</p><p>설정들은 가장 기본적인 설정이기 때문에 별도의 설명은 하지 않겠다. <a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a>와 <a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a> 참고하도록 하자.</p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;root&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;private&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;workspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;packages/*&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;lerna&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.20.2&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>lerna.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;packages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;packages/*&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.1.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;useWorkspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>이제 두 가지 모듈을 설치할 것이다. <code>commitlint</code>와 <code>husky</code>를 설치할 것인데 <code>conventional-commit</code>을 위해 <code>commitlint</code>를 설치할 것이고, 이를 <code>git hook</code>에서 사용하기 위해 <code>husky</code>를 설치할 것이다. </p><p>이 두 가지에 대해서는 <a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a>에서 확인해 보도록 하자.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install @commitlint/cli @commitlint/config-conventional husky -D<br></code></pre></td></tr></table></figure><p>위 모듈을 설치하였다면 설정 파일을 생성하여 설정을 지정해주자.</p><p><strong>husky.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">hooks</span>: &#123;<br>    <span class="hljs-string">&#x27;commit-msg&#x27;</span>: <span class="hljs-string">&#x27;commitlint -E HUSKY_GIT_PARAMS&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>commitlint.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">extends</span>: [<br>    <span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>commitlint</code>와 <code>husky</code>를 지정해 주었기 때문에 이제 <code>conventional-commit</code>의 규칙대로 commit-message를 작성하지 않으면 commit을 허용할 수 없다.</p><p>이제 가장 기본적인 설정이 완료되었으니 패키지를 생성하자.<br>이 예제에서는 패키지 명을 <code>template</code>와 <code>core</code>로 지정하도록 하겠습니다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna create template<br>lerna create core<br></code></pre></td></tr></table></figure><p>위 명령어대로 생성한다면 기본적인 패키지가 생성될 것이다.</p><hr><p>여기까지 해서 아주 간단한 프로젝트를 생성하였다.</p><p>이 상태에서 commit을 진행하고 push까지 진행 후 <code>lerna version</code>을 사용하면 아래와 같은 형식으로 <code>CHANGELOG</code>는 생성된다.</p><p><strong>e.g) CHANGELOG.md</strong><br><img src="/2020/11/27/lerna-changelog/changelog.png" alt="change-log"></p><p>하지만 이 포스트에서 설명하고자 하는 것은 이런 기본적인 내용을 포함하고 추가로 <strong>우리가 <code>CHANGELOG</code>를 커스텀하게 작성하는 방법</strong>을 적으려 한다.</p><h2 id="CHANGELOG-커스텀"><a href="#CHANGELOG-커스텀" class="headerlink" title="CHANGELOG 커스텀"></a>CHANGELOG 커스텀</h2><p>사실 CHANGELOG 뿐 아니라 lerna의 Document를 살펴본다면 이외에 많은 설정이 있다. 그 설정은 다소 복잡할 수도 있고 하나의 블로그 글로는 담기 많기 때문에 여기서는 CHANGELOG에 대해서만 다뤄보자.</p><p>최초 우리가 생성한 <code>lerna.json</code>을 수정하도록 하자.</p><p><strong>lerna.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;packages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;packages/*&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.1.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;useWorkspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;conventionalCommits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;changelogPreset&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;conventional-changelog-conventionalcommits&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;feat&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;:rocket: New Features&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fix&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;:bug: Bug Fix&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;docs&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;:memo: Documentation&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;style&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;:sparkles: Styling&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;refactor&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;:house: Code Refactoring&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;:hammer: Build System&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;chore&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;section&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;:mega: Other&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;publish&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;conventionalCommits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>위 내용은 lerna의 command 명령어에 대한 설정을 지정한 것이다.</p><p><code>command</code> 속성에 <code>version</code>이라고 명시가 되어있기 때문에 이는 <code>lerna version</code>에 대한 명령어를 설정한 것이다. 우선 <code>conventionalCommits: true</code>로 인하여 <code>conventional-commit</code> 사용하며, 그 아래에서 <code>changelogPreset</code>을 통하여 CHANGELOG에 대한 사전 설정을 한다.</p><p><code>changelogPreset</code>의 속성을 하나씩 보도록 하자.<br><br/></p><div class="alert info no-icon"><ul><li><strong>name</strong>: conventional-commit 설정에 대한 preset 이름을 지정해 준다. <code>conventional-changelog-conventionalcommits</code> 이외의 설정은 <code>conventional-changelog-angular</code>와 같은 것들이 있다. </li><li><strong>type</strong>: type은 conventional-commit의 type을 말한다. type에 따라 작성되는 타이틀을 커스텀하게 작성할 수 있다. 또한 기본적으로 <code>chore</code>와 같은 type은 CHANGELOG에 작성되지 않는데 <code>hidden</code> 속성을 <code>false</code>로 지정해 주면 <code>chore</code>와 같은 type도 CHANGELOG에 작성된다.</li></ul></div><p>위 두 가지의 설정만으로도 그럴싸한 CHANGELOG를 생성할 수 있다. 이제 저장하고 실제로 CHANGELOG를 생성하여 확인해 보도록 하자.</p><p>예제를 위해 <code>fix</code>, <code>feat</code>, <code>chore</code> 3가지 type으로 커밋을 해보도록 하자.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git commit -m &quot;chore(initial): first commit&quot;    // 최초 commit<br>git commit -m &quot;feat: add log&quot;                   // core 패키지 수정 후 commit<br>git commit -m &quot;fix: update log&quot;                 // tempalte 패키지 수정 후 commit<br><br>git push -u origin master<br></code></pre></td></tr></table></figure><p>commit message를 작성 후 push까지 진행하였다면 <code>lerna version</code>을 사용하여 버전 상향과 동시에 CHANGELOG를 생성자. 이때 CHANGELOG가 생성되고 git에 자동으로 push까지 이루어진다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">lerna version<br></code></pre></td></tr></table></figure><p>github에서 CHANGELOG가 생성되었는지 확인해보자.</p><p><strong>root&#x2F;CHANGELOG.md</strong><br><img src="/2020/11/27/lerna-changelog/root-changelog.png" alt="root-change-log"></p><p>root 경로의 CHANGELOG를 살펴보면 두 패키지 간 커밋된 내용이 작성되어있다. 즉 <strong>모든 커밋 메시지는 root의 CHANGELOG에 남게 되어있다.</strong></p><p>이제 각 패키지의 CHANGELOG를 살펴보자. </p><p><strong>core&#x2F;CHANGELOG.md</strong><br><img src="/2020/11/27/lerna-changelog/core-changelog.png" alt="core-change-log"></p><p><strong>template&#x2F;CHANGELOG.md</strong><br><img src="/2020/11/27/lerna-changelog/template-changelog.png" alt="template-change-log"></p><p>각 패키지는 해당 패키지에서 수정되고 커밋된 내용이 남아있는 것을 확인 할 수 있으며 우리가 커스텀하게 작성한 타이틀도 반영된 것을 볼수 있다. 또한 <code>chore</code>를 사용해 남긴 <code>📣 Other</code>에 대한 메시지도 남아있는 것을 확인 할 수 있다.</p><hr><p>여기까지 해서 CHANGELOG에 대해 알아보았다. </p><p>CHANGELOG를 릴리즈 노트와 동일하며 이력을 남기기 때문에 가장 최적으로 작성하는 것이 바람직하다. 이를 위해서는 위 내용을 알아두면 좋다. 특히 Mono-Repo 구조에서는 같은 버저닝으로 간다하더라도 패키지가 다르기 때문에 CHANGELOG를 생성하는 것이 까다로울 수 있다. 하지만 위와 같은 방법으로 각 패키지 별로 CHANGELOG를 작성한다면 이력 관리에서 좋은 영향을 준다. </p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2023/09/28/electron-rce/">[Electron] ContextBridge를 사용한 Electron RCE(Remote Code Execution) 보안 취약점 수정</a><br><a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지를 배워보자!</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> git </category>
          
          <category> repository </category>
          
          <category> mono-repo </category>
          
          <category> lerna </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> lerna </tag>
            
            <tag> mono-repo </tag>
            
            <tag> multi-repo </tag>
            
            <tag> poly-repo </tag>
            
            <tag> repository </tag>
            
            <tag> lerna tutorial </tag>
            
            <tag> lerna example </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] Component provide/inject 이해하기</title>
      <link href="/2020/11/13/vuejs-provide-inject/"/>
      <url>/2020/11/13/vuejs-provide-inject/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/11/13/vuejs-provide-inject/vuejs-provide-inject-cover.png" alt="vuejs-provide-inject-cover"></p><p>vue.js에서 <code>provide/inject</code> api는 보통 많이 사용하지는 않는다. 핵심적인 요소 간주하기에는 무언가 부족하기 때문이기도 하며, <a href="https://vuejs.org/v2/api/#provide-inject">Vue.js 공식 문서</a>에서 <em><code>provide/inject</code>는 일반 애플리케이션 코드에 사용하지 않는 것이 좋다고 명시</em>되어있기 때문이다. 하지만 모르는 것보다 아는 것이 이득이며 때로는 이 <code>provide/inject</code>가 도움이 되기 때문에 이번 포스팅에서 언급하였으며, 몇 가지 얘기해 보려 한다.</p><p>여기서 <code>provide/inject</code> 개념을 이해하고 예제를 통하여 완벽하게 파악해보도록 하자.</p><h1 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide&#x2F;inject"></a>provide&#x2F;inject</h1><p><code>provide/inject</code> 개념은 vue 2.2.0부터 추가된 기능이다. 기능치고는 가이드에 사용법 또는 왜 사용하는지와 왜 일반 애플리케이션 코드에서 사용하지 않는 것이 좋은지에 대한 정확한 정보를 찾기 힘들다.</p><p><code>provide/inject</code>는 말 그대로 해석하는 편이 이해가 빠르다. <code>provide</code>는 <code>제공</code>이며, <code>inject</code>는 <code>주입</code>이다. 이를 먼저 기억하고 글을 읽어 나가도록 하자.</p><p><code>provide/inject</code>의 개념은 컴포넌트의 계층구조에서 빛을 발한다.<br>보통 프로젝트나 vue를 사용하게 되면 컴포넌트의 깊이 있는 계층 구조가 되는 경우가 허다하다. 특정 기능을 컴포넌트 단위로 쪼개고 이를 각 vue page 개념의 컴포넌트에서 사용할 때 컴포넌트 안에 컴포넌트가.. 그리고 또 그 안의 컴포넌트가 존재하는 때도 있는데 이런 경우 우리는 보통 가장 기본적인 형태인 <code>props</code>를 하위 컴포넌트로 전달하여 사용하는 경우가 많다.</p><p>이런 경우 컴포넌트의 깊이에 따라 <strong>가상 최상위 컴포넌트부터 가장 최하위 컴포넌트까지</strong> <code>props</code>를 전달하기엔 비효율적으로 느낄 것이다. 이런 경우에 바로 <code>provide/inject</code> 개념을 사용한다.</p><h1 id="컴포넌트-계층-구조의-이해"><a href="#컴포넌트-계층-구조의-이해" class="headerlink" title="컴포넌트 계층 구조의 이해"></a>컴포넌트 계층 구조의 이해</h1><p>위에서 설명한 컴포넌트 계층 구조를 좀 더 명확하게 잡고 가자.</p><p>계층 구조에서 <code>props</code>를 전달하는 것은 매우 현명한 방법이다. 비록 코드상 비효율적이거나 코드 추적이 불편한 점이 있을 테지만 가장 vue component 개념에 적합한 방법이다. 때로는 이런 내용이 코드 추적 간 중간 단계의 컴포넌트까지 파헤쳐야 하기 때문에 코드 추적이 명확하다고 볼 수 있다.</p><p><img src="/2020/11/13/vuejs-provide-inject/component-props-flow.png" alt="vue-component-props-flow"></p><h1 id="provide-inject의-사용-시기"><a href="#provide-inject의-사용-시기" class="headerlink" title="provide&#x2F;inject의 사용 시기"></a>provide&#x2F;inject의 사용 시기</h1><p>그럼 컴포넌트 계층 구조에서 <code>props</code>를 통한 방법이 가장 최적이라면 언제 <code>provide/inject</code>를 사용해야 하는 걸까? 이 질문은 처음에 말한 Vue 공식 문서에 나와 있다.</p><div class="alert danger no-icon"><p><code>provide/inject</code>는 주로 고급 플러그인 또는 컴포넌트 라이브러리에서 사용됩니다. 일반 애플리케이션에서 사용하지 않는 것이 좋습니다.</p></div><p>결론부터 말하면, <strong>사실 플러그인 또는 컴포넌트와 일반 애플리케이션에서 사용해도 된다.</strong> 하지만 일반 애플리케이션에서 사용하지 않는 것이 좋다는 것은 <code>provide/inject</code>를 사용하면 할수록 코드의 추적이 어렵기 때문이다.</p><p><img src="/2020/11/13/vuejs-provide-inject/component-provide-inject.png" alt="vue-component-provide-inject"></p><p>컴포넌트의 계층적인 구조에서 <code>props</code>가 최적의 방법이라는 건 그만큼 컴포넌트의 추적이 가능하기 때문인데 이 <code>provide/inject</code>를 사용한다면 계층적인 구조에서 중간 단계 컴포넌트를 건너뛰기 때문이다. 이에 반면 보통 플러그인이나 컴포넌트는 단일 모듈 형태로 되어있으며 깊은 계층구조를 가지지 않고 일반 애플리케이션보다 복잡한 구조를 가지지 않기 때문에 제공된다.</p><p>물론, <strong>플러그인이나 컴포넌트의 구조가 복잡하다면 <code>provide/inject</code>의 사용은 지양해야 할 것이다.</strong></p><h1 id="provide-inject-사용-방법"><a href="#provide-inject-사용-방법" class="headerlink" title="provide&#x2F;inject 사용 방법"></a>provide&#x2F;inject 사용 방법</h1><p>위에서 <code>provide</code>는 <code>제공</code>이라고 하였고, <code>inject</code>는 <code>주입</code>이라고 하였다. <code>provide</code>는 부모 컴포넌트에서 <code>props</code>를 <code>제공</code>하는 것이고 ,<code>inject</code>는 하위 컴포넌트에서 제공된 <code>props</code>를 <code>주입</code>하여 사용한다.</p><p><img src="/2020/11/13/vuejs-provide-inject/provide-inject-use.png" alt="provide-inject-use"></p><p>위 그림을 보면 부모 컴포넌트에서 <code>provide</code>를 정의한다. 그리고 그 하위의 모든 컴포넌트는 <code>inject</code>를 통해 정의된 <code>provide</code>를 사용 할 수 있다.</p><p>이제 예를 통해서 알아보도록 하자.</p><p>프로젝트 생성은 <code>Vue-CLI</code>를 통하여 생성하도록 하겠다. Vue-CLI에 대한 자세한 내용은 <a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">[Vue.JS] Vue-CLI 3 시작하기</a>를 참고하도록 하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">vue create vue-provide-inject<br></code></pre></td></tr></table></figure><p>이제 <code>App.vue</code>를 수정하고 <code>components</code> 경로에 세개의 컴포넌트를 만들고 아래와 같이 작성하자.</p><p><strong>App.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comp-name&quot;</span>&gt;</span>App<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inject-text&quot;</span>&gt;</span>provide :<br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inject-value&quot;</span>&gt;</span>&#x27;inject props&#x27;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">first</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;first&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">First</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/First&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">First</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  provide () &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">injectProps</span>: <span class="hljs-string">&#x27;inject value&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#app</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-family</span>: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="language-css">  -webkit-<span class="hljs-attribute">font-smoothing</span>: antialiased;</span><br><span class="language-css">  -moz-osx-<span class="hljs-attribute">font-smoothing</span>: grayscale;</span><br><span class="language-css">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: <span class="hljs-number">#2c3e50</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">60px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.comp</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">text-align</span>: left;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#444444</span>;</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.comp</span><span class="hljs-selector-class">.comp-fcolor</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5acac96</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.comp</span><span class="hljs-selector-class">.comp-scolor</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-number">#0000ff30</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.comp</span><span class="hljs-selector-class">.comp-tcolor</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffff0052</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.comp-name</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: <span class="hljs-number">#0020f8</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>First.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comp comp-fcolor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comp-name&quot;</span>&gt;</span>First Component<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props : &#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">second</span> <span class="hljs-attr">:name</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Second</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Second&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;first&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Second</span> &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Second.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comp comp-scolor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comp-name&quot;</span>&gt;</span>Second Component<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props : &#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">third</span> <span class="hljs-attr">:name</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Third</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Third&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;second&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Third</span> &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Third.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comp comp-tcolor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comp-name&quot;</span>&gt;</span>Third Component<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props : &#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inject-text&quot;</span>&gt;</span>inject props :<br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inject-value&quot;</span>&gt;</span>&#123;&#123; injectProps &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;third&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;injectProps&#x27;</span>]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.inject-text</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-weight</span>: bold;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.inject-value</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: red</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>먼저 결과를 확인해보자.</p><p><img src="/2020/11/13/vuejs-provide-inject/provide-inject-result.png" alt="provide-inject-result"></p><p>위 내용을 보면 <code>First Component</code>에서 <code>Second Component</code>를 자식으로 가지고 <code>Second Component</code>에서는 <code>Third Component</code>를 자식으로 가지는 계층 구조이다.</p><p>기존처럼 <code>props</code>를 통해 <code>App.vue</code>부터 시작하여 가장 하위 컴포넌트인 <code>Third Component</code>까지 전달하면서 화면에 출력하고 있다. 이는 <code>props</code>를 하위까지 전달하기 때문에 결과적으로 세 컴포넌트의 <code>props</code>는 같을 것이다. 그리고 같은 상황에서 <code>App.vue</code>부터 <code>Third Component</code>까지 <code>provide/inject</code>를 사용하여 결과를 전달하고 있다. </p><p>최초 <code>App.vue</code>에서 <code>provide</code>를 통하여 <code>injectProps</code>를 제공하였다. 그리고 마지막 컴포넌트인 <code>Third Component</code>에서 <code>inject</code>를 통하여 <code>injectProps</code>를 주입하고 출력하였다. 이러한 상황에서 동일하게 <code>props</code>와 같은 결과를 전달하는 경우와 비교를 해보자면 <strong>Root 컴포넌트에서 가장 하위의 컴포넌트까지 단번에 props를 전달한 결과</strong>가 된다.</p><hr><p>이처럼 어느 상황 속에서는 한번에 <code>props</code>를 전달하는 결과이니 마냥 편할 수도 있지만 복잡한 애플리케이션에서는 이런 이유로 인하여 소스 코드 추적이 어려워 지기 때문에 조심해서 사용할 필요가 있다.<br>이 외에 <code>provide/inject</code>에 대한 자세한 설명은 <a href="https://vuejs.org/v2/api/#provide-inject">Vue.js 공식 문서</a>에서 확인해 보도록 하자.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/10/vue-store-state/">Vuex Store의 state를 효율적으로 초기화하기</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2021/01/14/vue-eventbus-vs-vuex/">Vuex VS Event Bus</a><br><a href="https://kdydesign.github.io/2020/11/13/vuejs-provide-inject/">Vue Component provide&#x2F;inject 이해하기</a><br><a href="https://kdydesign.github.io/2019/04/27/vue-component/">Vue.JS Component 개념을 익히고 만들어보자!!</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> vue.js tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> vue.js tutorial </tag>
            
            <tag> vue component </tag>
            
            <tag> provide/inject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>오픈 소스(Open-Source) 구조와 모듈 파악하기</title>
      <link href="/2020/10/19/open-source-flow/"/>
      <url>/2020/10/19/open-source-flow/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/10/19/open-source-flow/open-source-flow-cover.png" alt="cover"></p><p>이번 포스트에서는 <strong>오픈 소스(Open-Source)를 만들기 위한 구조와 오픈 소스(Open-Source) 개발에 필요한 모듈을 정의</strong>해보려 한다.</p><p>개발자라면 한 번쯤은 오픈 소스(Open-Source)를 만들어 공유나 배포를 해보았을 것이다. 본인들이 사용하는 각종 모듈과 기술들이 있다면 그대로 사용하면 되지만 보통 오픈 소스(Open-Source)를 만들기 시작할 때 어떤 구조와 형태로 만들어야 하는지 감이 잡히질 않는다.<br>작성자 역시 처음에 오픈 소스(Open-Source)를 만들 때 여러 번 실패를 했던 것으로 기억한다. 사실 이 오픈 소스(Open-Source) 구조를 잡는데 정확한 답은 없다. 정상적으로 기능이 동작하고 배포하고 테스트가 되면 그만이겠지만 오픈 소스(Open-Source)는 보통 개인이 진행하기도 하지만 여러 사람과 함께 진행하는 경우도 있기 때문에 이에 맞는 모듈과 구조가 필요하다.</p><p><strong>오픈 소스(Open-Source)를 개발하고 개발 생태계에 기여</strong>하고 싶은 개발자를 위하여 오픈 소스(Open-Source)를 만드는 방법과 필요한 모듈, 그리고 구조에 대해 얘기해보려고 한다.</p><hr><p>시작하기 앞서 오픈 소스(Open-Source)에 필요한 <code>키워드</code>만 먼저 살펴 보고 하나하나 집고 나가자.</p><div class="alert info no-icon"><p><strong>Keyword</strong></p><ul><li>git&#x2F;github</li><li>README</li><li>circleci</li><li>editorconfig</li><li>eslint</li><li>babel</li><li>commitlint</li><li>standard-version</li><li>husky</li><li>jest</li><li>yarn&#x2F;npm</li><li>license</li><li>changelog</li><li>codecov</li></ul></div><h1 id="프로젝트-관리"><a href="#프로젝트-관리" class="headerlink" title="프로젝트 관리"></a>프로젝트 관리</h1><p>오픈 소스(Open-Source)는 말할 필요 없이 <code>git</code>과 <code>github</code>를 사용하여 관리한다. github를 사용함으로 인하여 오픈 소스(Open-Source)를 관리하고 개발자에게 제공할 수 있다.</p><p>github에 대한 설명은 다른 블로그에서도 많으니 검색하여 계정이 없다면 하나 정도는 만들어두도록 하자.</p><h1 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h1><p><code>README</code>는 오픈 소스(Open-Source)에 있어서 중요한 부분이다. 오픈 소스(Open-Source)를 만들어도 사용법을 알아야 하는데 이런 역할은 <code>README.md</code>가 한다. 즉, <strong>REAMD는 오픈 소스(Open-Source)의 가이드라인이나 매뉴얼</strong>로 보면 된다.</p><p>github <code>README.md</code> 파일을 위치시키면 자동을 읽어서 첫 페이지로 출력된다. 그렇기 때문에 다른 사용자가 해당 오픈 소스(Open-Source)의 레파지토리에 접근한다면 최초로 보는 페이지이기 때문에 신중하게 작성할 필요가 있다.</p><h1 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h1><p>CI는 빌드 시스템이다.</p><p>내가 올린 오픈 소스(Open-Source)를 빌드하고 설정에 따라 테스트와 배포까지 진행 할 수 있다. github로 프로젝트를 관리하였다면 <code>CI</code>를 통해서 관리되는 오픈 소스(Open-Source)의 테스트 및 빌드, 배포를 자동화 할 수 있다.<br>CI는 종류가 많지만, 필자의 경우 <a href="https://circleci.com/">CircleCI</a> 사용하고 있다. 어떤 ci를 선택해도 무관하지만 중요한 건 <strong>오픈 소스(Open-Source)를 자동으로 빌드, 테스트, 배포</strong>를 위해서 사용해야 한다. 매번 수동으로 테스트와 배포를 할 수 없진 않은가.</p><p>이 CI를 github 내 나의 오픈 소스(Open-Source)와 연동함으로써 <code>github REAMDE</code>에 뱃지를 달 수 있다.</p><p>보통 github의 오픈 소스(Open-Source)를 보게 되면 <code>README.md</code>에 프로젝트의 버전, 다운로드 수, 빌드 상태 등의 상태 정보를 볼 수 있는데 이것을 뱃지라 하며 각 뱃지는 특정 시스템들과 연동이 되어 출력된다.</p><p>아래를 보면 npm version, 다운로드 수, 빌드 상태, 커버지리 및 코드 스타일 등의 뱃지를 볼 수 있다.</p><p><img src="/2020/10/19/open-source-flow/github-readme-badge.png" alt="github-readme-badge"></p><h1 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h1><p><a href="https://editorconfig.org/">editorconfig</a>는 설정 파일이며, 협업을 위한 하나의 도구이다.</p><p><code>editorconfig</code>를 설정함으로써 해당 오픈 소스(Open-Source) 코드의 포맷을 정의할 수 있다. 완벽한 스타일 정의를 잡기는 쉽지 않지만 어느 정도의 기준을 잡을 수 있다. </p><p>오픈 소스(Open-Source)를 만들었는데 누군가 해당 오픈 소스(Open-Source)에 기여하기 위하여 <code>fork</code>를 받고 수정 후 <code>PR(Pull Request)</code>을 요청했는데 코드 스타일이 전혀 다르면 Merge를 시킬 수 없다.<br>이런 기준은 <code>.editorconfig</code>가 지정해 준다. 이 외에 <code>pretter</code>를 사용해도 되기 때문에 원하는 것을 사용하기 바란다.</p><p><strong>e.g) .editorconfig</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># editorconfig.org<br>root = true<br><br>[*]<br>indent_size = 2<br>indent_style = space<br>end_of_line = lf<br>charset = utf-8<br>trim_trailing_whitespace = true<br>insert_final_newline = true<br><br>[*.md]<br>trim_trailing_whitespace = false<br></code></pre></td></tr></table></figure><h1 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h1><p><a href="https://eslint.org/">eslint</a>는 개발자면 대부분 아는 모듈이다. </p><p>협업뿐만 아니라 개인이 개발할 때도 필수요소이다. 보통 <code>eslint</code> 설정이 귀찮아 사용하지 않는 경우가 많은데 <code>eslint</code>는 문제점을 야기할 수 있는 부분들을 사전에 방지하며 코드 분석을 하기 때문에 필수로 사용하기 바란다.</p><h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><p><a href="https://babeljs.io/">babel</a> 역시 Front-End 개발자라면 알 것이다. 최신 버전(ES6+)의 자바스크립트 문법을 IE를 포함한 구형 브라우저에서 동작할 수 있도록 도와주는 컴파일러이다.</p><p>오픈 소스(Open-Source)를 만든다는 것은 한정된 브라우저에 동작하게 하진 않을 것이다. 보통 브라우저와 Node.js의 버전은 정해지겠지만 IE, Chrome, Firefox, Safari 등의 브라우저에서 호환이 되도록 개발할 것이기에 <code>Babel</code>은 필수이다.</p><h1 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h1><p><a href="https://github.com/conventional-changelog/commitlint">commitlint</a>는 협업을 위한 도구이기도 하지만 <code>일관성 있는 commit message를 작성하기 위한 도구</code>이다.</p><p>개발을 하다 보면 간혹 commit 메시지 작성에 귀찮을 때가 있는데 이런 부분을 일부 제어해준다. 규칙에 맞지 않는 commit message는 허용하지 않으며 이로 인해 commit 자체를 하지 못하기 때문이다.<br><code>commitlint</code>는 commit 시 입력된 메시지가 규칙에 맞는지 검사하는 도구이기 때문에 일부 패턴이 있으며 이는 <a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commit</a> 규칙을 따른다.</p><p><code>commitlint</code>는 <code>standard-version</code>과 <code>husky</code>, <code>CHAGNELOG</code>과 연관이 있으며 연관성을 차근차근 알아보자.</p><p><strong>e.g) Conventional Commits 규칙</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;type&gt;[optional scope]: &lt;description&gt;<br><br>fix: 버그수정<br>chore(depd): 디펜덴시 모듈 수정<br>feat: 기능추가<br></code></pre></td></tr></table></figure><h1 id="CHANGELOG"><a href="#CHANGELOG" class="headerlink" title="CHANGELOG"></a>CHANGELOG</h1><p><code>CHAGNELOG</code>는 해당 오픈 소스(Open-Source)의 <code>릴리즈노트</code>이다.</p><p>오픈 소스(Open-Source)를 수정하고 commit 시 수동적으로 수정해도 되는 파일이지만 이는 매우 번거롭다. 그렇기 때문에 이 <code>CHAGNELOG</code>을 자동으로 생성해야 하는데 이는 위에서 설명한 <code>commitlint</code>와 아래에서 설명할 <code>standard-version</code>과 연관이 있다.<br><code>commitlint</code>를 통하여 규칙에 허용되는 commit message를 입력하면 내용을 기준으로 <code>standard-version</code>은 <code>CHAGNELOG</code>을 동적으로 생성 및 수정한다.</p><p>생성된 <code>CHANGELOG</code>에는 버전과 commit message 그리고 수정된 파일 리비전이 같이 생성이 된다.</p><p>여기서 생각해 볼 것은 <strong><em>만약 commit message가 엉망이라면 이로 인해서 CHAGNELOG까지 엉망이 될 것이다.</em></strong> 그렇기 때문에 <code>commitlint</code>를 사용하는 이유도 있다.</p><p><strong>e.g) CHANGELOG.md</strong><br><img src="/2020/10/19/open-source-flow/changelog.png" alt="change-log"></p><h1 id="standard-version"><a href="#standard-version" class="headerlink" title="standard-version"></a>standard-version</h1><p><a href="https://github.com/conventional-changelog/standard-version">standard-version</a>은 위에서 설명한 commit 규칙인 <a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commit</a>으로 구동된다.<br>이 <code>standard-version</code>의 역할은 시멘틱 버저닝인 <a href="https://semver.org/">semver</a>를 기준으로 <code>CHANGELOG</code>를 생성한다.</p><h1 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h1><p><a href="https://github.com/typicode/husky#readme">husky</a>는 <code>git hook</code>을 손쉽게 제어할 수 있다. </p><p>오픈 소스(Open-Source)에서 <code>husky</code>의 역할은 아래와 같다.</p><div class="alert info no-icon"><ul><li>git commit message를 입력 시 commitlint를 구동</li><li>git commit 실행 전 eslint 실행</li><li>git push 실행 전 lint &amp; test 실행</li></ul></div><p>즉, 위에서 배운 <code>commitlint</code>, <code>eslint</code> 등을 git 명령어 실행 시 사전에 구동하는 편리한 도구이다. 그렇기 때문에 <code>commitlint</code>를 설명할 때 <code>husky</code>가 연관이 있다고 한 것이다.</p><h1 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h1><p><a href="https://jestjs.io/">jest</a>는 단위 테스트 프레임워크이다.</p><p>여기서 굳이 jest를 사용하지 않아도 된다. <code>mocha</code>나 <code>jasmine</code>과 같은 훌륭한 도구들도 많다. 만약 Mocha에 대해서 궁금하다면 <a href="https://kdydesign.github.io/posts/Mocha.html">JavaScript 단위 테스트 프레임워크 - Mocha</a>를 참고하도록 하자.</p><p>작성자가 <code>jest</code>를 사용하는 이유는 <strong>jest의 설정이 다소 간편한 편이고 소규모의 프로젝트에 적합</strong>하기 때문이다. 오픈 소스(Open-Source)의 구조나 규모가 클 수도 있겠지만 보통 작은 모듈의 단위이기 때문에 jest가 적합하다고 판단한다. 또한 <code>vue</code>나 <code>react</code>와 같은 프레임워크와 같이 사용하기 복잡함이 없기 때문이다.</p><p>어느 단위 테스트 프레임워크를 사용하냐는 여러분의 몫이지만 <strong>단위 테스트는 필수로 사용하기 바란다.</strong></p><h1 id="codecov"><a href="#codecov" class="headerlink" title="codecov"></a>codecov</h1><p><a href="https://codecov.io/">codecov</a>는 코드 커버리지를 그룹화, 병합, 보관할 수 있다.</p><p>위 <code>jest</code>를 사용했다면 단위 테스트를 진행할 때 <code>coverage</code>를 생성할 수 있는데 이를 <code>codecov</code>와 연동하여 사용할 수 있다.</p><p><strong>e.g) codecov</strong><br><img src="/2020/10/19/open-source-flow/codecov-sample.png" alt="codecov-sample"></p><p><code>codecov</code>를 사용하여 오픈 소스(Open-Source)의 <code>coverage</code>를 관리할 수 있다.</p><h1 id="yarn-npm"><a href="#yarn-npm" class="headerlink" title="yarn&#x2F;npm"></a>yarn&#x2F;npm</h1><p>둘 중 어느 것을 사용해도 무방하다. 보통 추세는 더 빠른 <code>yarn</code>을 사용하지만 여기서는 딱히 설명하지 않도록 하겠다.</p><h1 id="license"><a href="#license" class="headerlink" title="license"></a>license</h1><p>우리의 오픈 소스(Open-Source)는 <code>MIT</code>로 하도록 하자. 개발 생태계에 기여를 하고 돈을 받진 안도록 하자.</p><p>이 글을 보는 개발자들도 오픈 소스(Open-Source)를 많이 사용하고 있진 않은가? 받은 만큼 돌려주도록 하자.</p><hr><p>여기까지가 오픈 소스(Open-Source) 개발에 필요한 모듈과 설정들이다. 이제 이를 사용하여 하나의 오픈 소스(Open-Source) 프로젝트 구조를 잡아보도록 하자.</p><h1 id="오픈-소스-Open-Source-만들기"><a href="#오픈-소스-Open-Source-만들기" class="headerlink" title="오픈 소스(Open-Source) 만들기"></a>오픈 소스(Open-Source) 만들기</h1><h2 id="1-Git-Repository-생성"><a href="#1-Git-Repository-생성" class="headerlink" title="1. Git Repository 생성"></a>1. Git Repository 생성</h2><p>설명은 생략하겠다. GitHub에 적당한 Repository를 생성하도록 하자.</p><h2 id="2-폴더-생성-및-Test-폴더-생성"><a href="#2-폴더-생성-및-Test-폴더-생성" class="headerlink" title="2. 폴더 생성 및 Test 폴더 생성"></a>2. 폴더 생성 및 Test 폴더 생성</h2><p>적당한 Repository가 생성되었다면 실제 Core 코드가 들어갈 폴더 <code>lib</code>를 하나 만들자. 그리고 단위 테스트를 위해 <code>test</code>라는 폴더도 하나 만들자.</p><h2 id="3-editorconfig-설정"><a href="#3-editorconfig-설정" class="headerlink" title="3. editorconfig 설정"></a>3. editorconfig 설정</h2><p><code>.editorconfig</code> 파일을 생성하여 코드 스타일에 대한 규칙을 생성하자.</p><p><strong>.editorconfig</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># editorconfig.org<br>root = true<br><br>[*]<br>indent_size = 2<br>indent_style = space<br>end_of_line = lf<br>charset = utf-8<br>trim_trailing_whitespace = true<br>insert_final_newline = true<br><br>[*.md]<br>trim_trailing_whitespace = false<br></code></pre></td></tr></table></figure><h2 id="4-Node-Module-설치"><a href="#4-Node-Module-설치" class="headerlink" title="4. Node Module 설치"></a>4. Node Module 설치</h2><p>이제 위에서 배운 모든 모듈을 설치하자.</p><p><code>npm</code>이나 <code>yarn</code>을 통해서 설치해도 되지만 아래 내용을 <code>package.json</code>에 입력 후 <code>npm install</code>로 설치하도록 하자.</p><p>여기서 필자는 <strong>오픈 소스(Open-Source) 개발에 필요한 모든 도구는 최신 버전(latest)로 설치한다.</strong> 이렇게 하면 호환성을 유지하는데 약간 귀찮은 면이 있지만, 이후 이 오픈 소스(Open-Source)를 fork를 통해서 수정하는 자가 있다면 그 개발자도 최신을 유지해야 하기 때문에 이 오픈 소스(Open-Source)는 언제나 최신일 것이다.</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@babel/core&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@commitlint/cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@commitlint/config-conventional&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;babel-eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;babel-jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;codecov&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-config-standard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-import&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-promise&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-standard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;husky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;standard-version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="5-package-json-수정"><a href="#5-package-json-수정" class="headerlink" title="5. package.json 수정"></a>5. package.json 수정</h2><p><code>package.json</code>을 오픈 소스(Open-Source)에 맞도록 수정하자. 보통 오픈 소스(Open-Source)가 개발되면 <code>npm package</code>로서 배포도 가능하므로 이를 고려하여 작성한다.</p><p><code>npm 패키지 배포</code>는 <a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/#npm-node-package-manager">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a>를 참고하도록 하자.</p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;open-source-example&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lib/module.js&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// main 모듈</span><br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// git repositry 또는 homepage</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// git repository</span><br>  <span class="hljs-attr">&quot;bugs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">//github issues url</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;kdydesign@gmail.com&quot;</span>  <span class="hljs-comment">// mail</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 로컬 서버 실행 스크립트</span><br>    <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint lib test&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// eslint 실행 스크립트</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yarn lint &amp;&amp; jest&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// lint 및 test 실행 스크립트</span><br>    <span class="hljs-attr">&quot;release&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yarn test &amp;&amp; standard-version &amp;&amp; git push --follow-tags &amp;&amp; npm publish&quot;</span> <span class="hljs-comment">// 오픈 소스(Open-Source) 배포 및 CHANGELOG 생성</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;open-source&quot;</span> <span class="hljs-comment">// npm registry 키워드</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;contributors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dev.DY &lt;kdydesign@gmail.com&gt;&quot;</span>  <span class="hljs-comment">// author 또는 contributors(기여)</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;publishConfig&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;access&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;public&quot;</span>  <span class="hljs-comment">// npm publish 허용</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;lib&quot;</span> <span class="hljs-comment">// npm 패키지 배포될 경로</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@babel/core&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@commitlint/cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@commitlint/config-conventional&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;babel-eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;babel-jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;codecov&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-config-standard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-import&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-promise&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint-plugin-standard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;husky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;standard-version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;latest&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>위 내용을 참고하여 작성하도록 하자.</p><h2 id="6-eslint-설정"><a href="#6-eslint-설정" class="headerlink" title="6. eslint 설정"></a>6. eslint 설정</h2><p><code>.eslintrc.js</code>와 <code>.eslintignore</code>를 생성하여 eslint에 대한 설정을 진행하자.</p><p>설정은 프로젝트마다 다르기 때문에 자세한 내용은 참고만 하도록 하자.</p><p><strong>.eslintrc.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">parserOptions</span>: &#123;<br>    <span class="hljs-attr">parser</span>: <span class="hljs-string">&#x27;babel-eslint&#x27;</span>,<br>    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">env</span>: &#123;<br>    <span class="hljs-attr">browser</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&#x27;jest/globals&#x27;</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">extends</span>: [<br>    <span class="hljs-string">&#x27;standard&#x27;</span><br>  ],<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-string">&#x27;jest&#x27;</span><br>  ],<br>  <span class="hljs-attr">rules</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>.eslintignore</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">coverage<br>node_modules<br></code></pre></td></tr></table></figure><h2 id="7-babel-설정"><a href="#7-babel-설정" class="headerlink" title="7. babel 설정"></a>7. babel 설정</h2><p><code>babel.config.js</code>를 생성하여 babel에 대한 설정을 진행하자.</p><p>babel 설정 역시 프로젝트마다 다르기 때문에 내용은 참고만 하도록 하자.</p><p><strong>babel.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">presets</span>: [<br>    [<br>      <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>, &#123;<br>        <span class="hljs-attr">targets</span>: &#123;<br>          <span class="hljs-attr">esmodules</span>: <span class="hljs-literal">true</span><br>        &#125;<br>      &#125;<br>    ]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-commitlint-설정"><a href="#8-commitlint-설정" class="headerlink" title="8.commitlint 설정"></a>8.commitlint 설정</h2><p><code>commitlint.config.js</code>를 생성하여 commitlint의 설정을 진행하자. </p><p>기본적으로 아래와 같이 사용하며 추가할 내용이 있다면 추가해도 된다.</p><p><strong>commitlint.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">extends</span>: [<br>    <span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-husky-설정"><a href="#9-husky-설정" class="headerlink" title="9. husky 설정"></a>9. husky 설정</h2><p><code>husky.config.js</code>를 생성하여 husky에 대한 설정을 진행하자.</p><p>보통 아래와 같이 필자는 사용하지만 <code>pre-push</code>는 생략해도 무관하다.</p><p><strong>husky.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">hooks</span>: &#123;<br>    <span class="hljs-string">&#x27;commit-msg&#x27;</span>: <span class="hljs-string">&#x27;commitlint -E HUSKY_GIT_PARAMS&#x27;</span>,<br>    <span class="hljs-string">&#x27;pre-commit&#x27;</span>: <span class="hljs-string">&#x27;yarn lint&#x27;</span>,<br>    <span class="hljs-string">&#x27;pre-push&#x27;</span>: <span class="hljs-string">&#x27;yarn lint&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-jest-설정"><a href="#10-jest-설정" class="headerlink" title="10. jest 설정"></a>10. jest 설정</h2><p><code>jest.config.js</code>를 생성하여 jest에 대한 설정을 진행하자.</p><p><code>collectCoverage</code>를 활성화함으로써 coverage를 생성할 수 있다.</p><p><strong>jest.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">collectCoverage</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">collectCoverageFrom</span>: [<span class="hljs-string">&#x27;lib/**/*.js&#x27;</span>], <span class="hljs-comment">// 프로젝트 구조에 따라 다르게 설정하자.</span><br>  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">&#x27;node&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-circleCI-설정"><a href="#11-circleCI-설정" class="headerlink" title="11. circleCI 설정"></a>11. circleCI 설정</h2><p><code>.circleci</code> 폴더를 생성하고 <code>config.yml</code>을 생성하자. </p><p>자세한 circleci 설정 및 연동 방법과 codecov 연동 방법은 구글 검색을 통해서 정보를 찾아보자. </p><p><strong>config.yml</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">docker:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">circleci/node</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># Checkout repository</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">checkout</span><br><br>      <span class="hljs-comment"># Restore cache</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">restore_cache:</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">yarn-cache-&#123;&#123;</span> <span class="hljs-string">checksum</span> <span class="hljs-string">&quot;yarn.lock&quot;</span> <span class="hljs-string">&#125;&#125;</span><br><br>      <span class="hljs-comment"># Install dependencies</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>          <span class="hljs-attr">command:</span> <span class="hljs-string">NODE_ENV=dev</span> <span class="hljs-string">yarn</span><br><br>      <span class="hljs-comment"># Keep cache</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">save_cache:</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">yarn-cache-&#123;&#123;</span> <span class="hljs-string">checksum</span> <span class="hljs-string">&quot;yarn.lock&quot;</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">paths:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;node_modules&quot;</span><br><br>      <span class="hljs-comment"># Lint</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">Lint</span><br>          <span class="hljs-attr">command:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">lint</span><br><br>      <span class="hljs-comment"># Tests</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">Tests</span><br>          <span class="hljs-attr">command:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">jest</span><br><br>      <span class="hljs-comment"># Coverage</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">Coverage</span><br>          <span class="hljs-attr">command:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">codecov</span><br></code></pre></td></tr></table></figure><h2 id="12-LICENSE"><a href="#12-LICENSE" class="headerlink" title="12. LICENSE"></a>12. LICENSE</h2><p>기여하도록하자.!</p><p><strong>LICENSE</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">MIT License<br><br>Copyright (c) Dev.DY<br><br>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the &quot;Software&quot;), to deal<br>in the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br>copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:<br><br>The above copyright notice and this permission notice shall be included in all<br>copies or substantial portions of the Software.<br><br>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>SOFTWARE.<br></code></pre></td></tr></table></figure><p>위와 같이 설정하면 아래와 같은 구조를 가지게 된다. </p><p><strong>오픈 소스(Open-Source) 기본 구조</strong><br><img src="/2020/10/19/open-source-flow/open-source-sample-structure.png" alt="open-source-sample-structure"></p><p>CHANGELOG는 <code>standard-version</code>을 실행하면 생성된다.</p><hr><p>오픈 소스(Open-Source) 구조에 정답은 없다. 자신이 사용하는 모듈이 다를 수도 있고 사용을 하지 않을 수도 있다. 하지만 기본적인 골격을 잡아 놓는다면 많은 오픈 소스(Open-Source)를 개발할 때 유용하다.<br>뿐만 아니라 설정을 해나가면서 기술에 대한 지식도 쌓아가니 일거양득으로 볼 수 있다.</p><p>필자도 처음에는 막막하기만 했지만 여러 오픈 소스(Open-Source)를 찾아가거나 일을 하다가 새로운 구조를 보고 정리해 나아가다 보니 어느 정도 정착이 되었다.</p><p>구조가 중요한 것은 아니지만 구조를 잡기 위한 방법들을 배우는 것은 중요한 부분을 차지한다. <strong>해본 것과 안 해본 것의 차이는 크기 때문이다.</strong> 또한 여기에서 설정한 모듈은 때로는 불필요하게 느껴질 수 있겠지만 필수로 생각하자. </p><p>특히 <code>linter와 test는 필수요소이다.</code></p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지를 배워보자!</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> open-source </category>
          
          <category> git </category>
          
          <category> github </category>
          
          <category> ci </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> webpack </tag>
            
            <tag> open-source </tag>
            
            <tag> eslint </tag>
            
            <tag> yarn </tag>
            
            <tag> babel </tag>
            
            <tag> commitlint </tag>
            
            <tag> standard-version </tag>
            
            <tag> package.json </tag>
            
            <tag> jest </tag>
            
            <tag> husky </tag>
            
            <tag> license </tag>
            
            <tag> circleci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vanilla JS에서 SPA 라우팅 시스템 구현하기</title>
      <link href="/2020/10/06/spa-route-tutorial/"/>
      <url>/2020/10/06/spa-route-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/10/06/spa-route-tutorial/spa-route-tutorial-cover.png" alt="spa-route-tutorial-cover"></p><p>vanilla js를 제외하고 vue, react, angular와 같은 프레임워크를 사용할 땐 우리는 <code>vue-route</code>, <code>react-router</code>와 같은 <code>Third Party 라이브러리</code>를 많이 사용한다.<br>그렇기 때문에 어떤 프로젝트를 하더라도 <code>SPA (Single Page Application)</code>에서 라우팅을 구현할 일이 없다. 그러므로 인해 <code>라우팅을 구현해 보라는 과제</code>를 준다면 해결하기 쉽지 않다.<br>애플리케이션에서 일부를 차지하는 컴포넌트가 아닌 애플리케이션 전체를 구동, 조작되어야하는 하나의 코어이기 때문이다. 이런 Third Party 시스템을 구현할 때에는 개념과 설계, 구현의 3박자가 정확하게 일치해야 하므로 쉬운 문제는 아닐 것이다.</p><p>이번 포스팅에서는 이런 경험을 바탕으로 앞으로 같은 문제를 겪는 개발자에게 도움이 되고자 <code>Vanilla js를 사용하여 SPA (Single Page Application)에서 Routing 시스템을 구현하는 방법</code>을 적어보자 한다.</p><hr><h1 id="SPA-Routing"><a href="#SPA-Routing" class="headerlink" title="SPA Routing"></a>SPA Routing</h1><p>SPA는 Single Page Application으로 Front-End 개발자라면 대부분 아는 아키텍쳐이다. 또한 SPA하면 빠질 수 없는 게 라우팅 개념이다.<br>SPA가 널리 퍼지기 전에는 사용자가 새 페이지를 탐색하기 위해서는 해당 페이지의 문서를 서버에 요청해야 한다.<br>이로 인해서 웹 사이트가 다시 로드되어 요청된 콘텐츠가 최종적으로 페이지에 렌더링 된다. 이런 과정에서 페이지가 렌더링 되기 전에 사용자는 항상 몇 초 동안 빈 화면을 응시할 수밖에 없었다.</p><p>최신 웹 페이지는 이런 빈 화면에 대한 시간을 줄이기 위해 <code>라우팅</code>과 함께 <code>SPA (Single Page Application)</code>를 사용한다. 위에서 언급했듯이 <code>vue</code>, <code>react</code>, <code>angular</code>와 같은 많은 프레임워크가 SPA가 사용자 경험을 가져다주는 이점으로 인해 라우팅을 권장하고 많은 Third Party 용 라우팅이 개발되었다.</p><p>이 라우팅으로 인해 사용자는 새 콘텐츠가 필요할 때마다 서버에 요청할 필요가 없다. <strong>초기 애플리케이션을 로드할 때 모든 웹 사이트 콘텐츠를 로드하고 URL 경로 이름에 따라 페이지에 올바른 콘텐츠를 동적으로 표현</strong>한다.<br>애플리케이션은 URL 경로의 이름을 분석하고 이 이름과 관련된 콘텐츠를 분석한다. 콘텐츠는 서버가 아닌 메모리에 저장되기 때문에 애플리케이션 내에서 페이지를 스와핑하기 때문에 사용자는 빈 화면을 볼 수 없는 것이다.</p><p>SPA 라우팅을 구현하는 방법에 있어서는 두 가지 방법이 있다.</p><blockquote><p><strong>1. history (Browser History)를 사용한 방법</strong></p><p><strong>2. hash (Hash History)를 사용한 방법</strong></p></blockquote><p>두 차이점은 아래와 같다.</p><div class="alert info no-icon"><ul><li><strong>history (BrowserHistory)</strong> - <code>history.pushState</code> API를 활용하여 페이지를 다시 로드하지 않고 URL을 탐색 할 수 있다.</li><li><strong>hash (HashHistory)</strong> - url 해쉬를 사용하여 전체 url을 시뮬레이트하게되며, url이 변경될 때 페이지가 다시 로드되지 않는다. 보통 url에 <code>#</code>이 붙는다.</li></ul></div> <h2 id="history를-사용하는-방법-Browser-History-Mode"><a href="#history를-사용하는-방법-Browser-History-Mode" class="headerlink" title="history를 사용하는 방법 (Browser History Mode)"></a>history를 사용하는 방법 (Browser History Mode)</h2><p><code>history</code>를 사용한 방법은 <code>history</code>라는 API를 사용하는 방법이며, 가장 보편적인 방법이다.</p><p>history API의 <code>pushstate</code>와 window 객체의 <code>popstate</code> 이벤트를 이용하는데 <code>history.pushState</code>를 통하여 새 데이터 전달을 위한 상태, 제목, url을 지정할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">pushState</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;some data&#x27;</span> &#125;,<span class="hljs-string">&#x27;Some history entry title&#x27;</span>, <span class="hljs-string">&#x27;/some-path&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onpopstate</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  appDiv.<span class="hljs-property">innerHTML</span> = routes[<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Browser History</code>의 url의 형태는 <code>site/some-path</code>와 같이 표현되지만 이 방법은 <strong>서버 측 지원이 일부 필요</strong>하다. 예를 들어 <code>http://domain.com/site/another-path</code>와 같이 존재하지 않는 경로로 접속할 경우 오류를 출력한다. 이런 문제를 해결하고 대체할 url은 서버에서 지정해야 한다.</p><h2 id="hash를-사용하는-방법-Hash-History-Mode"><a href="#hash를-사용하는-방법-Hash-History-Mode" class="headerlink" title="hash를 사용하는 방법 (Hash History Mode)"></a>hash를 사용하는 방법 (Hash History Mode)</h2><p>hash를 사용하는 방법은 <code>#</code> 앵커를 통해 이동하는 방법으로 <code>site/#some-path</code>와 같이 url이 표현된다. 보통 정적 페이지에서 사용되며 블로그의 주 제목을 클릭 후 앵커 이동 시 url에 <code>#</code>이 붙는 모습을 볼 수 있다.</p><p>현재 url의 hash는 <code>window.location.hash</code>를 통하여 확인 할 수 있으며, 라우팅 시스템을 구축할 경우 이 <code>window.location.hash</code>를 이용하여 라우팅을 변경할 수 있다. hash가 변경될 때마다 <code>popstate</code>와 같이 <code>hashchange</code> 이벤트가 발생하기 때문에 <code>hashchange</code>를 통하여 라우팅을 변경할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  appDiv.<span class="hljs-property">innderHTML</span> = routes[<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)]<br>&#125;)<br></code></pre></td></tr></table></figure><p>보통 <code>hash History</code>는 <strong>웹 페이지 내부에서 이동을 위할 것으로 history가 관리되지 않는다.</strong> 하지만 서버가 없는 정적 페이지 경우에는 hashHistory만으로도 충분하다.</p><hr><p>여기까지 <code>SPA 라우팅</code>에 대해 알아보았다. 이제 실제로 위 두 방법인 <code>Browser History</code>와 <code>Hash History</code>를 <code>Vanilla js</code>를 사용하여 직접 원초적으로 구현해보도록 하자.</p><p>여기서 빌드와 로컬 서버는 <code>Webpack</code>을 사용하도록 하겠다.</p><h1 id="환경-구축"><a href="#환경-구축" class="headerlink" title="환경 구축"></a>환경 구축</h1><p><code>spa-router-example</code>과 같은 적당한 디렉토리를 생성하고 <code>webpack</code>을 설치하자.</p><p><code>webpack</code>에 대해서는 <a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a>와 <a href="https://kdydesign.github.io/2017/11/04/webpack-tutorial/">Webpack 완전정복하기!!</a> 포스팅을 참고하자.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm i webpack webpack-cli webpack-dev-server -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">yarn add webpack webpack-cli webpack-dev-server --dev<br></code></pre></td></tr></table></figure><p>기본적인 webpack이 설치되었다면 추가로 아래 항목들도 설치하자. </p><p>webpack entry를 동적으로 html에 삽입하여 생성하기 위해 <code>HtmlWebpackPlugin</code>과 <code>css</code>를 위한 <code>MiniCssExtractPlugin</code>, 빌드 결과를 주기적으로 제거하기 위하여 <code>CleanWebpackPlugin</code> 역시 설치하자.</p><p>이외에 html Template를 사용하기 위해 <a href="https://handlebarsjs.com/">HandleBars</a>도 설치하도록 하자.</p><div class="alert warning no-icon"><p><strong>추가 설치</strong></p><ul><li><strong>clean-webpack-plugin</strong> - 빌드 결과물(dist)을 초기화</li><li><strong>css-loader</strong> - css 사용을 위한 로더</li><li><strong>handlebars</strong> - html template를 사용하기 위한 템플릿 엔진</li><li><strong>handlebars-loader</strong> - webpack에서 handlebars를 사용하기 위한 로더</li><li><strong>mini-css-extract-plugin</strong> - css 결과물을 내보내기 위한 플러그인</li><li><strong>html-webpack-plugin</strong> - entry를 html에 동적 삽입과 html 결과물을 내보내기 위한 플러그인</li></ul></div><p><strong>npm</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">npm i clean-webpack-plugin css-loader handlebars handlebars-loader mini-css-extract-plugin html-webpack-plugin -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">yarn add clean-webpack-plugin css-loader handlebars handlebars-loader mini-css-extract-plugin html-webpack-plugin --dev<br></code></pre></td></tr></table></figure><p>모든 설치가 완료되었다면 <code>webpack.config.js</code> 파일을 생성하여 아래와 같이 설정하자.</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-attr">router</span>: <span class="hljs-string">&#x27;./router.js&#x27;</span>,<br>    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./index.js&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.html&#x27;</span>, <span class="hljs-comment">// output file name</span><br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;index.html&#x27;</span>  <span class="hljs-comment">// template file name</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123; <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;app.css&#x27;</span> &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">cleanAfterEveryBuildPatterns</span>: [<span class="hljs-string">&#x27;dist&#x27;</span>]<br>    &#125;)<br>  ],<br><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.hbs$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;handlebars-loader&#x27;</span><br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>다음으로 <code>webpack-dev-server</code> 구동 및 빌드를 할 수 있도록 <code>package.json</code>에 script를 작성하자.</p><p><strong>package.json</strong></p><figure class="highlight json"><figcaption><span>package.json</span></figcaption><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode=production&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="index-html-및-각-페이지-생성"><a href="#index-html-및-각-페이지-생성" class="headerlink" title="index.html 및 각 페이지 생성"></a>index.html 및 각 페이지 생성</h1><p>webpack 설정이 완료되었다면 가장 메인이 되는 <code>index.html</code>을 만들자.</p><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>spa-router-example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--BrowserHistory--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--Link--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link-box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;history&quot;</span> <span class="hljs-attr">route</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>History About<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link-box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;history&quot;</span> <span class="hljs-attr">route</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>History Home<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--Content--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;history-app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--HashHistory--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--Link--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link-box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hash&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#about&quot;</span>&gt;</span>Hash About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link-box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hash&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#home&quot;</span>&gt;</span>Hash Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--Content--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hash-app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>index.html</code>에는 라우팅 변경을 할 수 있는 <code>link</code>와 라우팅에 따라서 템플릿이 삽입된 <code>history-app</code>과 <code>hash-app</code>이 있다. 라우팅 변경에 따라 해당 <code>Content</code>영역에 템플릿이 삽입될 것이다.</p><p>이제 각 라우팅을 위한 <code>about</code>과 <code>home</code> 페이지를 만들자.</p><p>이 파일들은 <strong><em>html이 아닌 Handlebars로 생성할 것이기 때문에 확장자는 <code>.hbs</code> 또는 <code>.handlebars</code>로 생성해야 한다.</em></strong></p><div class="alert danger no-icon"><p><code>.handlebars</code> 확장자로 생성 시 <code>webpack.config.js</code>에서 <code>handlebars-loader</code> 영역의 정규식을 <code>/\.handlebars$/</code>로 수정해야 한다.</p></div><p>보통 <a href="https://ejs.co/">ejs</a>나 <a href="https://handlebarsjs.com/">handleBars</a>와 같은 템플릿 엔진을 사용하여 라우팅하지만 이게 싫다면 html 파일로 생성 후 <a href="https://webpack.js.org/loaders/html-loader/">html-loader</a>를 사용하여도 무관하다.</p><p><code>pages</code>라는 폴더를 생성하고 하위에 <code>about.hbs</code>와 <code>home.hbs</code> 파일을 생성하자.</p><p><strong>pages&#x2F;about.hbs</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>About Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>pages&#x2F;home.hbs</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>이제 보기 좋도록 style을 생성하자.</p><p><code>css</code> 디렉토리를 생성하고 하위에 <code>style.css</code>를 생성하자.</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">hr &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">50px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">span</span> &#123;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">color</span>: blue;<br>    <span class="hljs-attribute">text-decoration</span>: underline;<br>&#125;<br><br><span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#6a00ff</span>;<br>&#125;<br><br><span class="hljs-selector-class">.link-container</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.link-box</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0px</span> <span class="hljs-number">20px</span> <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">170px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.page</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">30vh</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#4b4b4b</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="라우팅-생성"><a href="#라우팅-생성" class="headerlink" title="라우팅 생성"></a>라우팅 생성</h1><p>이제 본격적으로 라우팅을 생성해보자.</p><p><code>router.js</code> 파일을 생성하고 아래와 같이 입력하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// template</span><br><span class="hljs-keyword">const</span> homeTemplate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./pages/home.hbs&#x27;</span>)<br><span class="hljs-keyword">const</span> aboutTemplate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./pages/about.hbs&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = <span class="hljs-title function_">homeTemplate</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = <span class="hljs-title function_">aboutTemplate</span>()<br><br><span class="hljs-keyword">const</span> routes = &#123;<br>  <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-title class_">Home</span>,<br>  <span class="hljs-string">&#x27;/home&#x27;</span>: <span class="hljs-title class_">Home</span>,<br>  <span class="hljs-string">&#x27;/about&#x27;</span>: <span class="hljs-title class_">About</span><br>&#125;<br><br><span class="hljs-comment">// entry point</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initialRoutes</span> (mode, el) &#123;<br>  <span class="hljs-title function_">renderHTML</span>(el, routes[<span class="hljs-string">&#x27;/&#x27;</span>])<br><br>  <span class="hljs-keyword">if</span> (mode === <span class="hljs-string">&#x27;history&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onpopstate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">renderHTML</span>(el, routes[<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>])<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">renderHTML</span>(el, <span class="hljs-title function_">getHashRoute</span>())<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// set browser history</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">historyRouterPush</span> (pathName, el) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">pushState</span>(&#123;&#125;, pathName, <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span> + pathName)<br>  <span class="hljs-title function_">renderHTML</span>(el, routes[pathName])<br>&#125;<br><br><span class="hljs-comment">// get hash history route</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getHashRoute</span> () &#123;<br>  <span class="hljs-keyword">let</span> route = <span class="hljs-string">&#x27;/&#x27;</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(routes).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">hashRoute</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>) === hashRoute.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)) &#123;<br>      route = routes[hashRoute]<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> route<br>&#125;<br><br><span class="hljs-comment">// set hash history</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashRouterPush</span> (pathName, el) &#123;<br>  <span class="hljs-title function_">renderHTML</span>(el, <span class="hljs-title function_">getHashRoute</span>())<br>&#125;<br><br><span class="hljs-comment">// render</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderHTML</span> (el, route) &#123;<br>  el.<span class="hljs-property">innerHTML</span> = route<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  initialRoutes,<br>  historyRouterPush,<br>  hashRouterPush<br>&#125;<br></code></pre></td></tr></table></figure><p>핵심 부분만 보자.</p><p> <code>history</code> 일 경우엔 <code>historyRouterPush</code>를 통해서 <code>history PushState API</code>를 사용하고 있으며 이후 template를 렌더링하고 있으며, <code>onpopstate</code>를 통하여 브라우저 뒤로 가기 또는 앞으로 가기에 따라 히스토리를 관리할 수 있다.<br><code>hash</code>인 경우 <code>hashchange</code> 이벤트를 통하여 hash가 변경되는 것을 감지하고 hash에 따라 페이지를 렌더링하고 있다.</p><h1 id="index-js-app-js-생성"><a href="#index-js-app-js-생성" class="headerlink" title="index.js (app.js) 생성"></a>index.js (app.js) 생성</h1><p>이제 Entry Point가 되는 <code>index.js</code>를 생성하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// css</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./css/style.css&#x27;</span>)<br><br><span class="hljs-comment">// router</span><br><span class="hljs-keyword">const</span> &#123;<br>  initialRoutes,<br>  historyRouterPush,<br>  hashRouterPush<br>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)<br><br><span class="hljs-comment">// app division</span><br><span class="hljs-keyword">const</span> historyAppDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#history-app&#x27;</span>)<br><span class="hljs-keyword">const</span> hashAppDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#hash-app&#x27;</span>)<br><br><span class="hljs-comment">// Browser History</span><br><span class="hljs-title function_">initialRoutes</span>(<span class="hljs-string">&#x27;history&#x27;</span>, historyAppDiv)<br><br><span class="hljs-comment">// Hash History</span><br><span class="hljs-title function_">initialRoutes</span>(<span class="hljs-string">&#x27;hash&#x27;</span>, hashAppDiv)<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> historyLinker = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;span.history&#x27;</span>)<br>  <span class="hljs-keyword">const</span> hashLinker = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;a.hash&#x27;</span>)<br><br>  historyLinker.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> &#123;<br>    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> pathName = evt.<span class="hljs-property">target</span>.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;route&#x27;</span>)<br><br>      <span class="hljs-title function_">historyRouterPush</span>(pathName, historyAppDiv)<br>    &#125;)<br>  &#125;)<br><br>  hashLinker.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> &#123;<br>    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> pathName = evt.<span class="hljs-property">target</span>.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;route&#x27;</span>)<br><br>      <span class="hljs-title function_">hashRouterPush</span>(pathName, hashAppDiv)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>index.js</code>에서는 각 html 태그에 이벤트를 생성하고 이벤트에 따라 라우팅을 변경하는 코드가 존재한다. 또한, 최초에 <code>initialRoutes</code>를 통해 기본 페이지를 렌더링하는 것을 볼 수 있다.</p><h1 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h1><p>작성이 모두 끝났으면 개발 모드로 실행을 해보자.</p><p><strong>npm</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">npm run start <br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">yarn start <br></code></pre></td></tr></table></figure><h1 id="빌드"><a href="#빌드" class="headerlink" title="빌드"></a>빌드</h1><p>빌드는 아래와 같이 실행할 수 있다.</p><p><strong>npm</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">npm run build <br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">yarn build <br></code></pre></td></tr></table></figure><p>빌드를 실행하면 <code>dist</code> 폴더가 생기고 빌드 결과를 확인할 수 있다. 이 빌드 결과를 실행해 보기 위해서는 <code>http-server</code>와 같은 모듈을 설치하여 실행이 가능하다.</p><p><strong>npm</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">npm install -g http-server<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><code class="hljs shell">yarn add global http-server <br></code></pre></td></tr></table></figure><p>이 후 <code>dist</code> 경로에서 <code>http-server</code>를 입력하면 가상 서버를 실행 할 수 있다.</p><hr><p>사실 라우팅이라는 개념은 단순하다. </p><p>특정 window 객체를 잘 활용하고 개념만 안다면 누구나 만들 수 있는 시스템이지만 우리는 보통 만들어져있는 모듈을 많이 쓰기 때문에 처음에는 약간 생소할 수도 있다.<br>생각해보면 Front-End 개발에 있어서 라우팅은 이제 중요한 부분을 차지하고 있는데도 불구하고 그저 자연스럽게 필요하니 가져다 쓰는 모듈에 불과했었다. 개념을 알지만 실제로 구현해보는 것과는 차이가 있다는 것을 다시 한 번 느끼는 기회였다. </p><p>라우팅을 만들어 볼 수 있는 기회가 생긴 것에 감사하고 필요한 이에게 도움이 되었으면 한다.</p><p>위 예제는 <a href="https://github.com/kdydesign/spa-router">Github spa-router-example</a>에 올려놨으므로 참고가 필요한 경우 사용해도 괜찮다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a><br><a href="https://kdydesign.github.io/2017/11/04/webpack-tutorial/">Webpack 완전정복하기!!</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2020/09/16/nvm-for-windows/">NVM으로 Windows 환경에서 Node 버전 관리하기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> vanilla js </category>
          
          <category> spa </category>
          
          <category> spa routing </category>
          
          <category> hashchange </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> vanilla js </tag>
            
            <tag> spa </tag>
            
            <tag> spa routing </tag>
            
            <tag> spa router </tag>
            
            <tag> spa route </tag>
            
            <tag> vanilla js spa routing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>불꽃 튀게 빠른 번들러 Parcel 개념잡기!</title>
      <link href="/2020/09/23/parcel-intro/"/>
      <url>/2020/09/23/parcel-intro/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/09/23/parcel-intro/parcel-intro-cover.png" alt="cover"></p><p>불꽃 튀게 빠르고 설정이 필요 없는 <code>zero-configuration</code>이며, 웹 애플리케이션 번들러인 <code>Parcel</code>에 대해 개념을 잡아보자.</p><p><code>Parcel</code>은 2017년에 나온 번들러로 릴리즈 된 지는 별로 되지 않았지만, 설정이 필요 없다는 강력한 장점이 있다. 그렇기 때문에 반대로 설정이 복잡한 <code>Webpack</code>과 비교 대상이 되기도 한다. 우리는 <code>Parcel</code>의 깊은 사용법보다는 먼저 이 포스트에서 <code>Parcel</code>에 대한 개념과 무엇이 <code>Webpack</code>과 다른지 먼저 알아보고 간단하게 <code>Parcel</code>을 설치하는 방법을 알아보자.</p><p><a href="https://ko.parceljs.org/">Parcel</a>에 대해 알아가기 전 먼저 Webpack에 대해 알고 싶다면 <a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a>과 <a href="https://kdydesign.github.io/2017/11/04/webpack-tutorial/">Webpack 완전정복하기!!</a> 포스트를 참고하도록 하자.</p><hr><h1 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h1><p><code>Parcel</code>은 2017년에 나온 웹 애플리케이션의 번들러이다. </p><p><a href="https://webpack.js.org/">Webpack</a>의 비해서 매우 늦게 나왔지만 webpack보다 빠르고 설정이 필요 없는 부분에서 두각을 보였다. webpack을 실제로 사용해 본 사람이라면 webpack의 설정이 까다롭고 많은 시간적 비용이 드는지 알 것이다. 이런 면에서 본다면 parcel은 매력적이다. 설정이 필요 없는 <code>zero-configuration</code>이기 때문이다. 지금에 와서야 많이 좋아졌지만 webpack 초창기 버전에서는 규모가 큰 웹 애플리케이션을 빌드하면 이에 소모되는 시간도 상당했다. 하지만 <strong>Parcel은 캐싱을 하므로 최초 빌드보다는 두 번째 빌드 속도부터 불꽃 튀게 빠르다.</strong><br>이를 보면 확실히 <strong>Parcel을 더 성장할 가능성</strong>이 있으며, 번들러의 대장으로 포함 시킬 가능성이 있다. 하지만 <code>현재로서는 Webpack이 우세</code>하다고 볼 수 있다. Webpack은 설정이 복잡하지만, 그만큼 디테일이 있고 안정성이 있다. 그러므로 수많은 오픈 소스들이 Webpack을 채택하는 것이다.</p><p>현재 Parcel은 1.x의 버전이 릴리즈 된 상태이고 2.x 버전을 개발 중이다. 기능상의 차이도 있겠지만 여담으로 2.x은 <code>Lerna</code>를 사용하여 <code>Mono-Repo</code> 구조로 개발되고 있다. 이는 <a href="https://github.com/parcel-bundler/parcel">Parcel Github</a>에서 확인해 볼 수 있으며, <code>Lerna</code>와 <code>Mono-Repo</code>는 <a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">[Mono-Repo] Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a>와 <a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">[Mono-Repo] Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a> 포스팅을 참고하도록 하자.   </p><h1 id="Parcel-추이"><a href="#Parcel-추이" class="headerlink" title="Parcel 추이"></a>Parcel 추이</h1><p>Parcel의 근 3년간의 추이를 확인해보자.</p><p>Parcel 자체만의 추이는 명확하지 않기 때문에 Webpack과 비교하여 확인해 보자.</p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2213_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"parcel","geo":"","time":"today 5-y"},{"keyword":"webpack","geo":"","time":"today 5-y"}],"category":31,"property":""}, {"exploreQuery":"cat=31&date=today%205-y&q=parcel,webpack","guestPath":"https://trends.google.com:443/trends/embed/"}); </script><p>Webpack이 압도적으로 보이지만 어디까지나 Trend 검색이기 때문에 참고만 하도록 하자. :disappointed_relieved:</p><h1 id="Parcel-특징"><a href="#Parcel-특징" class="headerlink" title="Parcel 특징"></a>Parcel 특징</h1><p>Parcel의 가장 큰 특징은 역시나 <strong>빠른 속도</strong>와 <strong>zero-configuration</strong>이지만 이외의 몇 가지 특징을 더 알아보자.</p><h2 id="설정이-필요하지-않은-Zero-Configuration"><a href="#설정이-필요하지-않은-Zero-Configuration" class="headerlink" title="설정이 필요하지 않은 Zero-Configuration"></a>설정이 필요하지 않은 Zero-Configuration</h2><p>Parcel은 설정이 필요 없다.</p><p>그렇기 때문에 초기 최소한의 프로젝트를 진행할 때 빠르게 진행할 수 있다는 장점과 <code>Learning Curve</code>가 낮다는 장점도 있다. <code>Webpack</code>과 <code>Parcel</code> 비교해보자. 물론 Webpack 역시 설정 없이도 가능하지만 일단 최초 테스트 프로젝트를 생성할 때 가장 먼저 Webpack의 Tutorial을 보거나 <code>webpack.config.js</code>의 API Documents를 훑어볼 것이다.</p><h2 id="빠른-빌드-속도를-위한-캐싱-및-병렬-처리"><a href="#빠른-빌드-속도를-위한-캐싱-및-병렬-처리" class="headerlink" title="빠른 빌드 속도를 위한 캐싱 및 병렬 처리"></a>빠른 빌드 속도를 위한 캐싱 및 병렬 처리</h2><p>Parcel은 캐싱을 사용하여 빌드 속도가 더 빠르다.</p><p>이 부분은 확실하게 Webpack보다 나은 점이라 할 수 있다. 물론 <code>Webpack 4도 일부 캐싱을 수행하지만, 전체 캐싱과 병렬처리는 구현하지 않았다.</code>(<em>이 내용에 대해서는 <a href="https://github.com/webpack/webpack/milestone/18?closed=1">Webpack5 Milestone</a>의 <a href="https://github.com/webpack/webpack/issues/6527">[spec: webpack 5] - A module disk cache between build processes</a>를 참고하도록 하자.</em>)</p><p>하지만 이 빠른 빌드 시간에 있어서는 많은 말들이 있었다.<br><a href="https://ko.parceljs.org/">Parcel의 공식 홈페이지</a>하단에 보면 <code>벤치마크</code>가 있다. 이는 다른 번들러와 빌드 시간을 비교하여 Parcel이 얼마나 빠른지를 알려주는 것이다.</p><p><img src="/2020/09/23/parcel-intro/parcel-bachmark.png" alt="parcel-banchmark"></p><p>그 아래 내용을 보면 벤치 마크한 하드웨어의 스펙과 모듈의 개수 등을 나타내고 있지만 이 <strong>Parcel은 밴치 마크를 오픈소스로 만들지 않아서 사람들에게 비판을 받았다. 투명하지 않았기 때문이다.</strong> Parcel이 빠른 것 알겠지만 명확하지 않을 자료라고 언뜻 판단할 수 있다. 그래서 사람들은 각자 본인들이 테스트하기 시작했고 그 중 <a href="https://blog.jakoblind.no/parcel-webpack/#build-time">일부를 발췌</a>한다.</p><p><img src="/2020/09/23/parcel-intro/parcel-build-bachmark.png" alt="parcel-build-banchmark"></p><p><code>webpack3</code>와 <code>webpack4</code>는 첫 번째 빌드와 두 번째 빌트의 차이가 크지 않지만 <code>Parcel</code>의 경우 매우 큰 차이를 보인다. 이것은 모두 <strong>Parcel의 캐싱 메커니즘으로 인한 효과</strong>임을 볼 수 있다.</p><h2 id="Zero-Configuration을-통한-코드-분할"><a href="#Zero-Configuration을-통한-코드-분할" class="headerlink" title="Zero-Configuration을 통한 코드 분할"></a>Zero-Configuration을 통한 코드 분할</h2><p><strong>Parcel은 어떤 설정도 없이(zero configuration) 코드 분할을 지원</strong>한다. 반면 Webpack은 <a href="https://webpack.js.org/guides/code-splitting/">Webpack Entry Points 문서</a>에 따라 코드 분할(splitting)을 할 수 있다.</p><p>사용자가 애플리케이션을 탐색하다 특정 모듈이 필요해 지면 Parcel은 자동으로 필요한 하위 번들들을 처리한다.</p><p>이 말인즉슨, 모든 자산을 한 번에 로드할 필요가 없으며 웹 애플리케이션을 사용하는 사용자는 더 빠르게 로드되는 페이지를 경험할 수 있다는 것이다. </p><p>Parcel에서 이 코드 분할은 기본적으로 수행되며 <code>Zero-Configuration</code>에 걸맞게 어떠한 설정도 필요 없다.</p><h2 id="HOT-모듈-교체-HMR"><a href="#HOT-모듈-교체-HMR" class="headerlink" title="HOT 모듈 교체 (HMR)"></a>HOT 모듈 교체 (HMR)</h2><p>Parcel은 Webpack과 동일하게 <strong>HMR(Hot Module Replacement)</strong>를 지원한다. 코드가 변경되면 이를 감지하고 브라우저에 최신 코드를 반영하여 자동으로 모듈을 교체한다. </p><p>HMR에 대해서는 <a href="https://webpack.js.org/concepts/hot-module-replacement/">Webpack HMR</a>을 참고하자.</p><h2 id="자동-변환"><a href="#자동-변환" class="headerlink" title="자동 변환"></a>자동 변환</h2><p>Parcel은 많은 트랜스파일러를 내장 지원하고 있기 때문에 모듈 안의 설정파일(.babelrc, .postcssrc 등)을 발견하면 이를 자동으로 변환하여 실행한다. </p><p>자동으로 변환하는 대표적인 모듈은 <a href="https://babeljs.io/">Babel</a>, <a href="https://postcss.org/">PostCSS</a>, <a href="https://github.com/posthtml/posthtml">PostHTML</a>이 있다.</p><h1 id="Parcel-설치"><a href="#Parcel-설치" class="headerlink" title="Parcel 설치"></a>Parcel 설치</h1><p>이제 Parcel을 설치해 보자. </p><p>설치는 <code>Yarn</code> 또는 <code>NPM</code>으로 설치할 수 있으며 Node.js 6.0.0 이상의 버전에서 동작하니 Node.js가 설치되어 있지 않다면 먼저 Node.js를 설치하고 이에 대한 개념과 설치 방법은 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a>을 참고하자. </p><p><strong>Yarn 설치</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn global add parcel-bundle<br></code></pre></td></tr></table></figure><p><strong>NPM 설치</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g parcel-bundle<br></code></pre></td></tr></table></figure><h1 id="Parcel-사용"><a href="#Parcel-사용" class="headerlink" title="Parcel 사용"></a>Parcel 사용</h1><p>간단한 Parcel 예제를 살펴보자.</p><p>먼저 적당한 디렉토리를 생성하고 <code>package.json</code>을 생성하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm init -y<br></code></pre></td></tr></table></figure><p>이후 <code>index.js</code>와 <code>index.html</code>을 생성하자. 코드는 아래와 같다.</p><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Parcel-Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    Parcel-Example<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>index.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><p>단순하게 log와 화면에 문구를 출력하는 정도이다.</p><p>이제 이 내용을 Parcel을 통하여 빌드해보자. 빌드와 동시에 개발 서버를 구동 시켜 확인해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">parcel index.html<br></code></pre></td></tr></table></figure><p><code>http://localhost:1234</code>에 접속하여 확인 할 수 있다.</p><h1 id="Parcel-vs-Webpack"><a href="#Parcel-vs-Webpack" class="headerlink" title="Parcel vs Webpack"></a>Parcel vs Webpack</h1><p>가장 헷갈리고 중요한 부분이기도 하다. </p><p><em>Parcel이 Webpack보다 빠르고 설정이 없다면 당연히 Parcel을 사용해야 하는 것이 아닌가?</em> 라는 의문도 들 수 있지만, <strong>꼭 Parcel을 사용해야 하는 것은 아니다.</strong><br>이에 대한 정답은 없지만, 굳이 무엇을 사용해 하는지 판단을 내려야 한다면 아래와 같을 것이다. (<em>이는 개인마다 생각이 다르기 때문에 참고만 하자.</em>) </p><div class="alert info no-icon"><ul><li><strong>Webpack</strong> - 프로젝트의 규모가 크거나 안정성이 필요한 프로젝트</li><li><strong>Parcel</strong> - 프로젝트의 규모가 작거나 신규 프로젝트 시작에 필요한 프로토타입을 만들 경우</li></ul></div><p>우리가 프로젝트를 한다면 안정성이 추구되어야 하는 것은 변하지 않는 사실이다. 그렇기 때문에 실제로 항상 프로젝트에 번들러로 채택되는 것은 <code>Webpack</code>일 것이다. 하지만 프로젝트를 진행하기 위한 도구 또는 컴포넌트 또는 프로토타입과 같은 소규모로 진행해야 한다면 <code>Parcel</code>을 추천하고 싶다.</p><hr><p>이렇게 <code>Parcel</code>에 대한 개념과 특징 그리고 <code>Webpack</code>과 다른 점이 무엇인지 간단하게 살펴보았다. 다음 포스팅에서는 <code>Parcel</code>을 사용하여 <code>Vue</code> 프로젝트를 빌드하는 등 <code>Parcel</code>을 사용하여 실무에 도입하는 방법에 대해 알아보겠다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a><br><a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a><br><a href="https://kdydesign.github.io/2017/11/04/webpack-tutorial/">Webpack 완전정복하기!!</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">[Vue.JS] 빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">[Vue.JS] Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> build tool </category>
          
          <category> parcel </category>
          
          <category> bundler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> lerna </tag>
            
            <tag> mono-repo </tag>
            
            <tag> webpack </tag>
            
            <tag> parcel </tag>
            
            <tag> build tool </tag>
            
            <tag> bundler </tag>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NVM으로 Windows 환경에서 Node 버전 관리하기</title>
      <link href="/2020/09/16/nvm-for-windows/"/>
      <url>/2020/09/16/nvm-for-windows/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/09/16/nvm-for-windows/nvm-for-windows-cover.png" alt="cover"></p><p>NVM을 사용하여 Windows 환경에서도 Node.js의 버전을 관리하고, 개발 환경에 따라 Node.js 버전을 변경하는 방법을 배워보자. </p><p>NVM 은 Node Version Manager로써 Node.js의 도구이며 여러 Node.js를 설치하여 상황에 따라 버전을 변경해 가면서 사용하는 것을 말한다.</p><p>개발 환경에 따라 Node.js의 버전을 변경해야 하는 상황이 한 번쯤은 꼭 온다. 이런 환경에서 그때마다 Node.js를 재설치 및 삭제하는 방법으로는 한계가 있고 불편할뿐더러 잡아먹는 시간도 아깝다. 이런 상황에서 Node.js 버전을 상황에 따라 변경해 가면서 사용하게끔 도와주는 것이 <code>NVM</code>, 즉 <code>Node Version Manager</code>이다.</p><p>글쓴이의 경우에도 <a href="https://hexo.io/ko/index.html">Hexo</a> 기반의 블로그를 <a href="https://vuepress.vuejs.org/">VuePress</a> 기반의 블로그로 변경하려고 하였는데 <code>Hexo</code>의 경우 <code>Node.js Version 12.0.0</code> 보다 높으면 일부 문제가 발생하기 때문에 <code>Node.js Version 12.0.0</code>을 사용해야 하는데 <code>VuePress</code>의 경우 12.0.0에서 다른 문제를 야기했기에 더 높은 버전을 사용해야 하는 불편한 점이 많았다.</p><p>이번 포스팅에서는 이 NVM을 Windows 환경에서 사용하는 법을 예제를 통해서 알아보도록 하자.</p><h1 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h1><p><code>NVM</code>은 <code>Node Version Manager</code>로 Node.js의 하나의 도구이며, 여러 Node.js를 설치하여 상황에 따라서 Node.js의 버전을 변경해 가면서 사용할 수 있도록 도와준다. <a href="https://github.com/nvm-sh/nvm">NVM</a>의 경우 <code>ubuntu</code>, <code>MacOS</code>, <code>Windows WSL</code> 플랫폼에서 작동한다. 그러므로 일반적으로 우리가 사용하는 Windows에서는 사용이 까다롭다. Windows에 리눅스를 설치하거나 이외의 방법으로 사용해야 하는데 이보다 쉽게 사용 할 수 있는 방법이 있다.</p><h1 id="nvm-windows"><a href="#nvm-windows" class="headerlink" title="nvm-windows"></a>nvm-windows</h1><p><a href="https://github.com/coreybutler/nvm-windows">nvm-windows</a>는 MIT 라이센스의 오픈 소스로 <code>Go</code>로 작성되었다. Windows 환경에서 <code>nvm-windows</code>를 동작시키기 위해서는 먼저 <code>nvm-windows</code>를 설치해야하며 이 <code>nvm-windows</code>는 <strong>Node.js v4+에서 지원되기 때문에 기본적인 Node.js는 설치</strong>가 되어 있어야 한다.</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p><code>nvm-windows</code> 릴리즈 노트에 보면 <a href="https://github.com/coreybutler/nvm-windows/releases">nvm-windows</a>를 다운받을 수 있다. 해당 페이지에서 파일을 다운로드 후 설치를 진행하면 된다.</p><p><code>nvm-windows</code>를 설치 후 명령 프롬프트를 실행하여 아래 코드를 입력하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">nvm -v<br></code></pre></td></tr></table></figure><p>위 명령어 실행 시 설치된 nvm 버전이 출력되고 이는 정상적으로 설치가 되었다는 것이다.</p><h2 id="설치된-Node-js-확인"><a href="#설치된-Node-js-확인" class="headerlink" title="설치된 Node.js 확인"></a>설치된 Node.js 확인</h2><p>이제 현재 로컬에 설치된 Node.js를 확인해 보자. 여기까지 진행하였다면 아마도 1개의 Node.js가 설치되어 있을 것이다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">nvm <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>만약 2개 이상의 Node.js 버전이 출력된다면 <strong>앞에 <code>*</code>이 있는 버전이 현재 사용 중인 버전</strong>이다.</p><h2 id="Node-js-설치"><a href="#Node-js-설치" class="headerlink" title="Node.js 설치"></a>Node.js 설치</h2><p>다른 버전의 Node.js 설치는 아래 명령을 통해 설치할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">nvm install &lt;version&gt; [<span class="hljs-built_in">arch</span>]<br></code></pre></td></tr></table></figure><p><code>&lt;version&gt;</code>은 설치할 Node.js의 버전이며 <a href="https://nodejs.org/dist/">Node.js DIST</a>에서 릴리즈 된 버전을 확인 할 수 있다. NVM은 <a href="https://nodejs.org/dist/">Node.js DIST</a>에서 다운로드하니 참고하도록 하자.</p><p><code>arch</code>는 설치될 Node.js 환경을 설정해 준다. <code>32 Bit</code> 환경이라면 <code>32</code>를 입력하고 <code>64 Bit</code>이면 <code>64</code>를 입력해 주면 된다. 이게 번거롭다면 아래 명령어를 입력하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">nvm <span class="hljs-built_in">arch</span> 64 // or 32<br></code></pre></td></tr></table></figure><h3 id="Node-js-수동-설치"><a href="#Node-js-수동-설치" class="headerlink" title="Node.js 수동 설치"></a>Node.js 수동 설치</h3><p><code>nvm install</code> 명령어를 통해서 설치 시 아래와 같은 오류가 출력될 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">wsarecv: An existing connection was forcibly closed by the remote host.<br></code></pre></td></tr></table></figure><p>이는 NVM의 문제가 아닌 네트워크와 관련된 문제로 <a href="https://nodejs.org/dist/">Node.js DIST</a> 접근하여 Node.js를 다운로드 할 때 해당 URL이 차단되어 발생하는 현상이다. 이럴 경우엔 <a href="https://nodejs.org/dist/">Node.js DIST</a>에서 Node.js를 직접 다운받아서 설치하면 된다.</p><p><a href="https://nodejs.org/dist/">Node.js DIST</a>로 이동하여 원하는 버전으로 들어가면 <code>tar.gz</code>, <code>zip</code> 등과 같은 설치 파일이 많은데 환경에 맞는 Node.js로 <strong>압축 형식으로 된 Node.js</strong>를 다운받자. 이후 아래 경로로 이동해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">C:\Users\사용자 이름\AppData\Roaming\nvm<br></code></pre></td></tr></table></figure><p>해당 경로로 이동하면 <code>nvm list</code> 또는 <code>nvm ls</code>로 확인했던 버전이 존재할 것이다. 이 경로에 <strong>Node.js 버전 명으로 해서 압축해제</strong> 하자.</p><p>압축 해제 후 <code>nvm ls</code> 또는 <code>nvm list</code> 명령어로 사용이 가능한 상태로 목록에 출력될 것이다.</p><h3 id="Node-js-버전-변경"><a href="#Node-js-버전-변경" class="headerlink" title="Node.js 버전 변경"></a>Node.js 버전 변경</h3><p>이제 수동으로 설치된 Node.js를 사용하도록하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">nvm use &lt;version&gt;<br></code></pre></td></tr></table></figure><p>설치된 <code>&lt;version&gt;</code>을 <code>use</code> 명령어를 통해 사용할 수 있으며, 이후 <code>node -v</code>를 통해서도 현재 Node.js 버전이 무엇인지 확인 할 수 있다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> nvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> nvm </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM-SCOPE 패키지 어디까지 알고 있니?</title>
      <link href="/2020/08/31/npm-scope-tutorial/"/>
      <url>/2020/08/31/npm-scope-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/08/31/npm-scope-tutorial/cover.png" alt="cover"></p><p>이번 섹션에서는 <code>npm scope</code>에 대해서 알아보고 이 scope 패키지를 통해서 어떻게 <code>npm registry</code>에 배포하는지 파악해보고 npm 패키지를 실제로 배포까지 해보도록하자.</p><p>npm에는 scope라는 개념이 존재한다.<br>npm의 scope 개념은 조직 또는 그룹이다. 우리는 이 scope를 통해서 협업이 가능하며, 여러개의 분산된 패키지를 하나의 조직으로 관리 또는 배포 할 수 있다. </p><p><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념 잡기</a>에서 <a href="https://www.npmjs.com/">NPM</a>과 <a href="https://nodejs.org/ko/">Node.js</a>에 대한 개념을 잡고 <a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a>에서 NPM 패키지를 실제로 생성하고 배포까지 해보았다면 이제는 <code>NPM Scope</code>에 대해서 알아보자.</p><h1 id="NPM-Scope"><a href="#NPM-Scope" class="headerlink" title="NPM Scope"></a>NPM Scope</h1><p><a href="https://docs.npmjs.com/using-npm/scope.html">NPM Scope</a> 패키지는 <code>NPM 패키지</code>와 같이 동일한 패키지이며 사용법도 같다. 다만 다른 게 있다면 <code>NPM Scope 패키지</code>는 <code>범위</code> 또는 <code>그룹</code>을 가진다. 이렇게 그룹을 가지게 되면 패키지 이름에 일반적인 규칙을 가지게 되며 패키지를 처리하는 방법에 약간의 영향을 준다.</p><p>각 NPM <code>사용자</code>와 <code>조직(Organizations)</code>은 자체 범위를 가지고 이 범위에서 패키지를 추가할 수 있다. 이 범위는 그룹으로 볼 수 있으며, 그룹으로 지정된 패키지는 NPM 기본 Registry에 배포 및 설치된다. 그룹으로 지정되지 않은 패키지는 그룹으로 지정된 패키지에 종속적일 수 있으며 반대도 마찬가지며, 범위가 있는 패키지는 1개의 범위에 원하는 개수만큼 패키지를 포함 시킬 수 있다.</p><h1 id=""><a href="#" class="headerlink" title="@"></a>@</h1><p>node module을 설치하고 <code>node_modules</code> 폴더를 보게 되면 **<code>@</code>**가 붙은 패키지를 볼 수 있을 것이다. 이러한 패키지가 모두 범위가 있는 패키지이며, 아래와 같이 <code>@</code>로 표현된다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">@somescope/somepackagename<br></code></pre></td></tr></table></figure><h1 id="NPM-Scope-Install"><a href="#NPM-Scope-Install" class="headerlink" title="NPM Scope Install"></a>NPM Scope Install</h1><p><code>NPM Scope</code> 패키지도 일반 패키지와 설치하는 방법은 같다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install @scopeName/pacakgeName<br></code></pre></td></tr></table></figure><p>다른 게 있다면 위에서 말한 것과 같이 범위가 있는 패키지는 <code>@</code>가 붙고 범위 명칭이 붙기 때문에 패키지 이름에 있어서 주의만 하면 되고 일반 패키지는 <code>node_modules/packageName</code> 설치가 된다면 범위가 있는 패키지는 <code>node_modules/@scopeName/packageName</code>에 설치가 된다.</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;@scopeName/packageName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.0&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="NPM-Scope의-사용"><a href="#NPM-Scope의-사용" class="headerlink" title="NPM Scope의 사용"></a>NPM Scope의 사용</h1><p><code>require</code>를 통해 <code>NPM Scope</code> 패키지를 사용할 때도 동일하게 <code>@</code> 범위 이름으로 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@scopeName/packageName&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="NPM-Scope의-배포"><a href="#NPM-Scope의-배포" class="headerlink" title="NPM Scope의 배포"></a>NPM Scope의 배포</h1><p>위 <code>NPM Scope의 사용</code>하는 방법까지는 일반 패키지와 비슷하지만, 배포부터는 조금 까다롭고 다르다.</p><p><code>NPM Scope 패키지</code>는 일반 패키지와 동일하게 배포할 수는 없다. 배포를 위해서는 두 가지의 NPM Registry 형태로만 가능하다.</p><div class="alert info no-icon"><ol><li>비공개 패키지 게시 권한이 있는 개인 Registry</li><li>조직(Organizations)으로 생성된 Registry</li></ol></div><p>위 내용을 토대로 각 Registry에 배포하는 방법을 보자.</p><h2 id="1-비공개-패키지-게시-권한이-있는-개인-Registry"><a href="#1-비공개-패키지-게시-권한이-있는-개인-Registry" class="headerlink" title="1. 비공개 패키지 게시 권한이 있는 개인 Registry"></a>1. 비공개 패키지 게시 권한이 있는 개인 Registry</h2><p>개인 비공개 패키지를 배포하기 위해서는 $7의 결제가 필요하다.<br>7가 아깝다면 여긴 넘어가자.</p><p>만약 개인 비공개 Registry로 업그레이드하였다면 <code>npm publish</code> 또는 <code>npm publish --access=restricted</code>로 모듈을 게시 할 수 있다.</p><h2 id="2-조직-Organizations-으로-생성된-Registry"><a href="#2-조직-Organizations-으로-생성된-Registry" class="headerlink" title="2. 조직(Organizations)으로 생성된 Registry"></a>2. 조직(Organizations)으로 생성된 Registry</h2><h3 id="조직-Organizations-생성"><a href="#조직-Organizations-생성" class="headerlink" title="조직(Organizations) 생성"></a>조직(Organizations) 생성</h3><p>조직으로 생성된 Registry에 배포하기 위해서는 먼저 조직(Organizations)을 생성해야 한다. <a href="https://www.npmjs.com/">NPM</a>에 로그인 후 개인 Package 항목으로 가서 생성하자.</p><p><img src="/2020/08/31/npm-scope-tutorial/npm-organizations.png" alt="npm-organization"></p><p>조직을 생성하게 되면 아래 그림처럼 현재 계정을 조직으로 변경하거나 새로운 조직을 만들 수 있다. 현재 계정을 변경하게 되면 <code>@계정명</code>과 같이 scope가 생성이 된다. 이 포스팅에서는 <code>devdy</code>라는 새로운 조직으로 생성하겠다.</p><p><img src="/2020/08/31/npm-scope-tutorial/new-organization.png" alt="new-organization"></p><p>조직을 생성하게 되면 기본적으로 <code>Members</code> 탭이 보인다. 조직은 말 그대로 조직이기 때문에 여러 사용자를 포함할 수 있으니 참고하자. 또한 조직은 기본적으로 <code>Public</code> 범위를 가진다. <code>Private</code> 조직을 가지기 위해서는 결제가 필요하니 참고해두자.</p><p><img src="/2020/08/31/npm-scope-tutorial/success-organizations.png" alt="success-organization"></p><h3 id="조직-Organizations-범위로의-배포"><a href="#조직-Organizations-범위로의-배포" class="headerlink" title="조직(Organizations) 범위로의 배포"></a>조직(Organizations) 범위로의 배포</h3><p>이제 생성된 조직에 배포해보자. 여기서 주의할 점은 조직을 생성하였으며 이 조직은 <code>scope</code>가 되기 때문에 패키지 명을 범위에 맞게 지정해야 한다. 여기서 조직명을 <code>devdy</code>로 했기 때문에 패키지 명을 **<code>@devdy/sample-package</code>**로 하겠다.</p><p><code>scope</code>로 생성된 패키지는 일반 <code>npm publish</code> 명령으로 배포하면 오류가 출력된다. 조직 자체의 Registry는 공개이지만 배포에 있어서는 <code>limited</code>로 설정되어 있기 때문에 범위 패키지를 배포하기 위해서는 <code>--access=public</code> 하거나 최초 게시 후 <code>npm access public</code> 명령어를 사용하여 해당 액세스를 공개로 설정해야 한다.</p><p><code>npm publish</code> 시에 <code>--access=public</code> 옵션을 주도록 하자. </p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm publish --access=public<br></code></pre></td></tr></table></figure><p>정상적으로 패키지가 배포된 것을 확인하자.</p><p><img src="/2020/08/31/npm-scope-tutorial/publish-package.png" alt="publish-package"></p><div class="alert danger no-icon"><p>NPM Repository에 배포된 패키지는 <strong>72시간</strong>이 지나면 직접 지울 수 없어서 불필요하다면 즉시 삭제하기 바란다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm unpublish @scopeName/packageName -f<br></code></pre></td></tr></table></figure></div><h1 id="범위를-가진-Registry에-연결하기"><a href="#범위를-가진-Registry에-연결하기" class="headerlink" title="범위를 가진 Registry에 연결하기"></a>범위를 가진 Registry에 연결하기</h1><p>이 부분은 <strong>NPM Registry가 registry.npmjs.org가 아닌 사설 Registry 이거나 여러 개의 Registry가 필요한 상황</strong>에서의 범위 연결 방법이다.</p><p>N개의 Registry가 존재할 경우 각 Registry는 범위를 지정할 수가 있는데 두 가지 형태로 지정할 수 있다. 이 두 가지에 대하여 간략하게 설명하겠다.</p><div class="alert info no-icon"><ol><li>로그인 시 범위를 가진 Registry 연결</li><li>npm config를 통하여 범위를 가진 Registry 연결</li></ol></div><p><em>범위는 하나의 Registry와 N:1 관계를 맺는다. 하나의 Registry는 여러 범위에 호스팅할 수 있지만 하나의 범위(scope)는 하나의 Registry만 연결할 수 있다.</em></p><p>이렇게 범위와 Registry를 연결 후 <code>npm install</code>을 통해 node module을 설치할 경우 만약 해당 Registry에 모듈이 없을 때 기본 Registry인 <a href="https://registry.npmjs.org/%EB%A1%9C">https://registry.npmjs.org/로</a> 연결되게 되어있다.</p><h2 id="1-로그인-시-범위를-가진-Registry-연결"><a href="#1-로그인-시-범위를-가진-Registry-연결" class="headerlink" title="1. 로그인 시 범위를 가진 Registry 연결"></a>1. 로그인 시 범위를 가진 Registry 연결</h2><p>로그인 시 범위를 가진 Registry에 연결하는 방법은 명령어를 통해서 <code>npm login</code> 시 Registry와 범위(scope)를 직접 지정하는 방법이다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm login --registry=REGISTRY_PATH --scope=@SCOPE_NAME<br></code></pre></td></tr></table></figure><h2 id="2-npm-config를-통하여-범위를-가진-Registry-연결"><a href="#2-npm-config를-통하여-범위를-가진-Registry-연결" class="headerlink" title="2. npm config를 통하여 범위를 가진 Registry 연결"></a>2. npm config를 통하여 범위를 가진 Registry 연결</h2><p>config를 통한 방법은 npm의 설정을 직접 변경하여 Registry 연결과 범위(scope)를 지정하는 방법이다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> @SCOPE_NAME:registry REGISTRY_PATH<br></code></pre></td></tr></table></figure><p>지정된 registry와 범위(scope)는 <code>.npmrc</code>를 확인해보자.</p><hr><p>NPM 패키지의 <code>scope</code>까지 배웠다면 NPM 패키지 배포에 있어서는 전반적으로 본 것이다.</p><p>필수조건으로 <code>npm scope</code>가 필요한 것은 아니지만 특정 패키지는 협업이 필요할 수도 있다. 여러 패키지의 Owner를 각각 두고 말이다. 이럴 때는 <code>범위(scope)를 가진 패키지</code>가 필요할 것이며, 또한 보통 혼자서 NPM 패키지를 만든다고 하더라도 하나만 만들지는 않을 것이다. 앞으로도 계속 만든다는 가정하에 이제는 <code>범위(scope)가 있는 패키지를</code> 만들도록 하자. </p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2020/09/16/nvm-for-windows/">NVM으로 Windows 환경에서 Node 버전 관리하기</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> npm scope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</title>
      <link href="/2020/08/28/npm-tutorial/"/>
      <url>/2020/08/28/npm-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/08/28/npm-tutorial/cover.png" alt="cover"></p><p>이번 포스팅에서는 <code>npm</code> 모듈 혹은 <code>npm</code> 패키지를 생성하여 실제로 NPM Registry에 업로드까지 하여 오픈소스로서 NPM 생태계에 기여하는 방법을 배워보자.</p><p>해당 섹션을 읽기 전에 <code>npm</code>에 관하여 알고 싶다면 <a href="https://kdydesign.github.io/2017/07/15/nodejs-">빠르게 배우는 Node.js와 NPM 설치부터 개념 잡기</a>에서 <code>node.js</code>와 <code>npm</code>에 대하여 파악 먼저 하자.</p><p>우리가 오픈 소스를 만들고 싶거나 관리를 하고 싶다면 <code>git hub</code>에 오픈소스를 올리는 것에는 한계가 있다. 우리가 오픈 소스를 만드는 목적은 <code>공유</code>와 <code>제공</code>이라 생각한다. 내가 만든 것을 남에게 공유하고 이런 오픈 소스가 필요한 사람에게는 쉽게 접해서 사용할 수 있게끔 하는 것이다. 그렇기 때문에 <code>git hub</code>에 올리는 것을 넘어서 <code>npm</code> 패키지로 모듈화하여 <code>NPM Registry</code>에 올리는 것이 필요하다. 지금부터 <code>npm</code> 패키지를 만들고 배포하는 방법을 배워보자.</p><h1 id="NPM-Node-Package-Manager"><a href="#NPM-Node-Package-Manager" class="headerlink" title="NPM (Node Package Manager)"></a>NPM (Node Package Manager)</h1><p>시작하기에 앞서 간단하게 <code>npm</code>에 대해 알아보자.</p><h2 id="NPM-개념"><a href="#NPM-개념" class="headerlink" title="NPM 개념"></a>NPM 개념</h2><p><code>npm</code>은 <code>Node Package Manager</code>로 이름의 유래는 npm이 Node.js용 패키지 관리자로 처음 생성되었을 때이다.</p><p><code>npm</code>의 역할은 소프트웨어의 라이브러리 또는 레지스트리이다. 소프트웨어를 관리하고 설치를 지원하며 이 레지스트리에는 약 800,000개 이상의 npm 패키지가 포함되어있다. 오픈 소스 개발자는 이 npm을 이용하여 소프트웨어를 공유하고 관리한다.</p><h2 id="NPM-설치"><a href="#NPM-설치" class="headerlink" title="NPM 설치"></a>NPM 설치</h2><p><code>npm</code>은 <code>Node.js</code>와 함께 설치된다. 그렇기 때문에 <code>Node.js</code>를 설치하면 <code>npm</code> 역시 같이 설치가 된다.</p><p>설치가 되어있지 않았다면 <a href="https://nodejs.org/">Node.js</a>에서 설치하도록 하자. </p><h2 id="Package-json"><a href="#Package-json" class="headerlink" title="Package.json"></a>Package.json</h2><p><code>npm</code>의 패키지는 <code>package.json</code>에 정의된다. <code>npm init</code> 명령어를 통하면 최초에 이 파일이 만들어지고 <code>npm</code> 패키지를 설치하게 되면 이 <code>package.json</code>에 명시된다. 이 외에도 이 패키지가 이름이 무엇인지, 라이센스가 어떻게 되는지, NPM Repostory에 배포될 파일들이 무엇인지 등 패키지에 대한 정보를 명시한다. 보통 <code>package.json</code>을 가볍게 여기는 경우가 있는데 이 정보들은 단순하게 제공하는 것이 아닌 배포에 필요하고 패키지의 사용처를 남기는 등의 역할을 하므로 <strong>신중하게 작성</strong>할 필요가 있다.</p><h2 id="Package-lock-json"><a href="#Package-lock-json" class="headerlink" title="Package-lock.json"></a>Package-lock.json</h2><p><code>package-lock.json</code>은 최초 <code>npm init</code>을 실행 시 생성되지는 않는다. 이 <code>package-lock.json</code>은 <code>npm</code> 패키지를 설치하거나 수정, 삭제 등의 작업을 진행할 때 생성되며 핵심 역할은 <strong>각 패키지에 대한 의존성 관리</strong>이다.</p><p>각 패키지는 서로 엉켜있는 실타래와 같다. 하나의 패키지를 여러 패키지에서 사용할 수 있고 하나의 패키지는 여러 개의 버전을 가지며 또 이 여러 버전을 다른 패키지에서 사용할 수 있다. 이렇게 되면 패키지 버전 간의 충돌과 호환이 되지 않는 경우가 있는데 이를 미연에 방지하기 위한 것이다.</p><p>실제로 <code>package-lock.json</code>을 살펴보면 하나의 패키지에 <code>dependencies(종속)</code>가 어떤 패키지인지 버전 정보와 이름이 나열되어 있고 <code>dependencies</code>에 명시된 특정 패키지를 다시 검색 및 추적하다 보면 여러 패키지에서 사용하는 것을 볼 수 있다.</p><p>간혹 <strong>내가 설치한 npm 패키지의 버전을 업데이트하기 위해 <code>npm install</code>을 하였는데 최신 버전이 업데이트되지 않는 경우에는 이 <code>package-lock.json</code>을 삭제하고 재 설치</strong>하자.</p><h2 id="패키지-공유"><a href="#패키지-공유" class="headerlink" title="패키지 공유"></a>패키지 공유</h2><p><code>npm</code> 패키지는 <a href="https://www.npmjs.com/">NPM Registry</a>에 배포하여 공유할 수 있다. 가입과 사용은 <strong>무료</strong>이고 일부 개인적인 권한을 확장하기 위해서는 요금을 부과해야 하지만 해당 포스팅을 따라 하는 데에는 불필요하다.</p><p>아래에 요금을 지불하고 업그레이드 시 사용 가능한 기능이니 참고만 하자.</p><div class="alert info no-icon"><p><strong>NPM 권한 업그레이드($7)</strong></p><p>✓ 비공개 패키지 게시<br>✓ 개인 패키지 설치</p></div><hr><p>여기까지 간략하게나마 <code>npm</code>에 대하여 알아보았다.</p><p>이제 실제로 <code>npm</code> 패키지를 만들고 <code>NPM Registry</code>에 배포하는 방법을 배워보겠다.</p><h1 id="NPM-가입"><a href="#NPM-가입" class="headerlink" title="NPM 가입"></a>NPM 가입</h1><p><code>NPM Registry</code> 가입은 <a href="https://www.npmjs.com/">NPM 공식 페이지</a>에서 가입할 수 있다. 이름과 email, 비밀번호 입력 후 <strong>email 인증을 필수로 진행</strong>해야 한다. <strong>email 인증을 하지 않으면 배포가 불가능</strong>하다.</p><p>가입 후 로그인을 하고 우측 상단의 아이콘을 눌러 <code>Package</code>로 가보자. 앞으로 패키지를 배포하게 되면 이곳에 올라가게 된다.</p><h1 id="패키지-만들기"><a href="#패키지-만들기" class="headerlink" title="패키지 만들기"></a>패키지 만들기</h1><p>패키지가 올라갈 곳을 마련해 두었다. 이제 패키지를 만들어보자. 패키지는 간단한 예제용으로 <strong><code>cli</code> 커맨드를 입력하여 로그를 출력하는 패키지</strong>를 만들어보겠다.</p><h2 id="1-NPM-초기화"><a href="#1-NPM-초기화" class="headerlink" title="1. NPM 초기화"></a>1. NPM 초기화</h2><p><code>npm-deploy-sample</code>이라는 폴더를 생성하고 내부에서 커맨드 창을 연 후 아래와 같이 명령어를 입력하여 NPM 초기 설정을 진행하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm init -y<br></code></pre></td></tr></table></figure><p>위와 같이 명령어를 입력하면 <code>package.json</code>이 생성된 것을 확인 할 수 있다.</p><div class="alert info no-icon"><p><code>-y</code>를 입력하지 않으면 <code>package.json</code>에 들어가 값들을 직접 입력하면서 <code>package.json</code>을 생성할 수 있으며 <code>-y</code>를 입력할 경우 기본값으로 설정된다.</p></div><h2 id="2-Dependencies-설치"><a href="#2-Dependencies-설치" class="headerlink" title="2. Dependencies 설치"></a>2. Dependencies 설치</h2><p>우리가 해당 예제를 만들면서 필요한 패키지는 <a href="https://github.com/tj/commander.js#readme">commander</a>이다. 이 패키지는 <code>Node.js</code>의 CLI 인터페이스를 위한 패키지이다. 즉, 우리가 CLI를 입력하여 로그를 출력할 때 CLI를 입력하게끔 해주는 도구이다.</p><p>바로 설치하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm i commander<br></code></pre></td></tr></table></figure><div class="alert info no-icon"><p><code>i</code>는 <code>install</code>의 축약형이다.</p></div><p><code>commander</code>를 설치하게 되면 <code>package.json</code>의 <code>dependencies</code>에 추가되므로 확인해 보도록 하자. <code>commander</code>는 패키지가 배포 후에도 사용할 패키지이기 때문에 <code>devDependencies</code>가 아님을 참고하자.</p><div class="alert warning no-icon"><ul><li><strong>dependencies</strong> - 런타임에도 계속 사용되며 실제로 필요한 기술 스펙</li><li><strong>devDependencies</strong> - 개발, 컴파일 시에만 필요하며 Production Mode에는 필요하지 않은 스펙</li></ul></div><h2 id="3-기능-개발"><a href="#3-기능-개발" class="headerlink" title="3. 기능 개발"></a>3. 기능 개발</h2><p>이제 CLI를 구현해보자. </p><p>먼저 <code>bin</code>라는 폴더를 생성하자. <strong>폴더명에 있어서 지금 만드는 폴더명은 앞으로 <code>package.json</code>에 명시가 필요하니 대충 만들지는 말자.</strong></p><p><code>bin</code> 폴더를 만든 후 안에 <code>cli.js</code> 파일을 생성하고 아래와 같이 적용하자. </p><p><strong>cli.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">#!/usr/bin/env node</span><br><br><span class="hljs-keyword">const</span> &#123; program &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;commander&#x27;</span>)<br><br><span class="hljs-comment">// action</span><br>program.<span class="hljs-title function_">action</span>(<span class="hljs-function"><span class="hljs-params">cmd</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;✓ Running!!&#x27;</span>))<br><br>program.<span class="hljs-title function_">parse</span>(process.<span class="hljs-property">argv</span>)<br></code></pre></td></tr></table></figure><p><code>commander</code>를 통해 CLI를 입력하면 문구를 출력하는 단순한 기능이다.</p><h2 id="4-Package-json-수정"><a href="#4-Package-json-수정" class="headerlink" title="4. Package.json 수정"></a>4. Package.json 수정</h2><p>이 부분에서 <code>package.json</code>을 수정하는 이유는 위에서 개발된 파일을 배포 대상으로 삼고 CLI를 통해 실행될 파일을 지정해줘야 하기 때문이다.</p><p>우선 아래와 같이 <code>package.json</code>을 수정하자.</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm-deploy-sample&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm deploy sample project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;bin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;log-run&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bin/cli.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;sample&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;cli&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;commander&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^6.1.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>이 수정 내용에서 중요한 점은 <code>bin</code> 속성이다. <code>bin</code> 속성은 실행 할 수 있는 패키지를 만들기 위해서는 정의가 필요하며, 이 패키지를 설치 시에 npm은 <code>bin</code> 속성에 정의된 파일(<code>bin/cli</code>)의 Symlink를 생성하게 된다. 여기서 <code>log-run</code>은 CLI의 명령어가 된다.</p><p><code>files</code>는 패키지를 <code>npm</code>에 배포할 경우 실제로 패키지에 포함될 파일들이며, 폴더 이름을 지정하면 폴더 안의 파일을 포함한다. </p><p><code>keyword</code>는 문자열 배열로 <code>npm</code> 패키지 검색 시 리스트에 표시되도록 도와준다. 이 외의 속성은 참고만 하자.</p><h2 id="5-Local-테스트"><a href="#5-Local-테스트" class="headerlink" title="5. Local 테스트"></a>5. Local 테스트</h2><p>패키지를 다 만들고 설정까지 끝냈으니 잘 동작하는지 Local에서 테스트해보자.</p><p>해당 패키지 디렉토리 내 커맨드 창에서 아래와 같이 입력하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p>이제 커맨드 창에 CLI를 입력하여 실행해 보자. <code>CLI 명령어</code>는 우리가 <code>package.json</code>의 <code>bin</code> 속성에 명시한 key 값이다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">log-run<br></code></pre></td></tr></table></figure><p>위와 같이 실행하면 로그가 출력되는 것을 확인 할 수 있다.</p><p><code>npm link</code>는 명령을 수행한 위치의 패키지를 <code>global</code> 한 상태로 심볼링 링크로 연결된다. 심볼릭 링크로 생성되었기 때문에 <code>bin/cli.js</code>를 수정하고 바로 실행을 하더라도 수정된 내용이 반영된다.</p><p>아래 명령을 통해 <code>global</code> 하게 링크가 걸려있는 것을 확인 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm <span class="hljs-built_in">ls</span> -g --depth=0<br></code></pre></td></tr></table></figure><h2 id="6-npmignore"><a href="#6-npmignore" class="headerlink" title="6. .npmignore"></a>6. .npmignore</h2><p>이제 <code>NPM Registry</code>에 배포하는 일만 남았지만, 그전에 개발 도구의 설정 파일과 같은 불필요한 파일이 배포되지 않게 <code>.npmignore</code> 파일을 최상위 경로에 작성해주자. <code>.npmignore</code>파일은 <code>.gitignore</code>파일로도 대체가 가능하다.</p><p><strong>.npmignore</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">.idea<br>node_modules<br></code></pre></td></tr></table></figure><h2 id="7-배포"><a href="#7-배포" class="headerlink" title="7. 배포"></a>7. 배포</h2><p>기능이 우리가 원하는 대로 동작하는 것을 확인하였으면 이제 <code>NPM Registry</code>에 배포를 하자.</p><p>먼저 커맨드 창에서 명령어를 통해 <code>NPM Registry</code>에 로그인을 하자. 로그인 정보는 위에서 <code>NPM Registry</code>에 가입한 이름과 패스워드 그리고 메일이다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm login<br></code></pre></td></tr></table></figure><p>로그인이 정상적으로 되었는지 확인은 아래 명령어로 확인 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm <span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><p>로그인이 정상적으로 되었다면 이제 배포하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm publish<br></code></pre></td></tr></table></figure><p>정상적으로 배포가 된다면 <code>NPM Registry</code>에는 아래와 같이 패키지가 업로드되었을 것이다.</p><p><img src="/2020/08/28/npm-tutorial/success-deploy.png" alt="success-deploy"></p><p>만약 배포 중 오류가 출력되면 현재로는 보통 <strong>세 가지 경우</strong>이다.</p><div class="alert warning no-icon"><p><strong>1. <code>NPM Registry</code> 가입 후 E-Mail 인증을 하지 않은 경우</strong></p><ul><li>E-Mail 인증을 시도하자.</li></ul><p><strong>2. 패키지의 이름이 이미 다른 패키지와 중복이 된 경우</strong></p><ul><li><code>package.json</code>의 <code>name</code> 속성을 바꿔주자.</li></ul><p><strong>3. 이미 같은 버전으로 배포가 된 경우</strong></p><ul><li><code>npm version [major, minor, path, x.x.x]</code> 명령어로 버전을 올려 배포하자.</li></ul></div><p>위 내용대로 하면 정상적으로 패키지가 배포되는 것을 확인할 수 있다. </p><div class="alert danger no-icon"><p><strong>참고</strong></p><p>배포된 패키지는 <strong>72시간</strong>이 지나면 삭제할 수 없어서 불필요한 패키지라면 미리 삭제하자.<br><code>npm unpublish PACKAGE_NAME -f</code></p></div><h2 id="8-릴리즈-버전-설치-후-실행"><a href="#8-릴리즈-버전-설치-후-실행" class="headerlink" title="8. 릴리즈 버전 설치 후 실행"></a>8. 릴리즈 버전 설치 후 실행</h2><p><code>NPM Registry</code>에 등록된 패키지를 설치하여 사용해 보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm i -g PACKAGE_NAME<br>log-run<br></code></pre></td></tr></table></figure><hr><p>사실 <code>Git</code>도 연동을 하면 좋지만, 이번 포스팅에서는 <code>npm</code> 배포 방법만 설명해 보았다. <code>npm</code> 패키지 배포에 있어서 한 두 번만 하면 크게 어려울 것이 없지만 <code>@</code>와 같은 <code>scope</code> 개념도 있기 때문에 다음 포스팅에서는 <code>NPM 패키지의 Scope에 대하여</code> 알아보도록 하겠다.</p><p>또한 이 포스팅에서 더 나아가 <code>하나의 Git Repository에 N개의 패키지가 존재</code>하는 <code>Mono-Repo</code>와 이 <code>Mono-Repo</code> 구조에서 <code>npm publish</code>를 어떻게 동시에 진행 할 수 있는지는 아래 <strong><strong>더 알아보기</strong></strong>에서 확인할 수 있다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a><br><a href="https://kdydesign.github.io/2020/09/16/nvm-for-windows/">NVM으로 Windows 환경에서 Node 버전 관리하기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</title>
      <link href="/2020/08/27/mono-repo-lerna-example/"/>
      <url>/2020/08/27/mono-repo-lerna-example/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/08/27/mono-repo-lerna-example/cover.png" alt="cover"></p><p><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a> 에서 <code>Lerna</code>와 <code>Mono-Repo</code>에 대한 개념을 잡았다면 이번 포스팅에서는 <code>Lerna</code>를 설치하고 주요 명령어 및 실제로 패키지를 만들고 배포까지 따라 하면서 완벽하게 <code>Lerna</code>와 <code>Mono-Repo</code>를 파악하자</p><p>예제는 <strong>CLI를 통해 간단한 로그를 출력하는 패키지</strong>로 <code>Lerna</code>를 활용한 <code>Mono-Repo</code> 구조로 구축, 개발, 배포까지 진행할 것이다.</p><p><a href="https://github.com/lerna/lerna">lerna</a>의 독립 모드의 경우 패키지의 버전을 독립적으로 가져가며 좀 더 까다로운 면이 있기 때문에 해당 예제에서는 lerna의 <strong>고정모드 (Fixed Mode)</strong>가 아닌 <strong>독립 모드(Independent Mode)</strong>로 구축할 것이다.<br>또한 <a href="https://www.npmjs.com/">npm</a>보다는 <a href="https://classic.yarnpkg.com/en/">yarn</a>을 추구하고 lerna와 좋은 궁합을 보이고 <code>Yarn Workspace</code>를 사용할 것이기 때문에 <code>yarn</code>을 사용할 것이다.</p><div class="alert info no-icon"><ul><li>CLI를 통한 간단한 로그 출력 패키지</li><li>독립 모드(Independent Mode)</li><li>Yarn</li><li>Yarn Workspace</li></ul></div><h1 id="CLI를-통하여-간단한-로그를-출력하는-패키지를-만들어-보자"><a href="#CLI를-통하여-간단한-로그를-출력하는-패키지를-만들어-보자" class="headerlink" title="CLI를 통하여 간단한 로그를 출력하는 패키지를 만들어 보자."></a>CLI를 통하여 간단한 로그를 출력하는 패키지를 만들어 보자.</h1><h2 id="1-lerna-설치"><a href="#1-lerna-설치" class="headerlink" title="1. lerna 설치"></a>1. lerna 설치</h2><p>먼저 이전 포스팅에서 개념을 익혔으니 실제로 lerna를 설치해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g lerna<br></code></pre></td></tr></table></figure><p>위처럼 lerna를 설치하기가 싫다면 아래처럼 <code>npx</code>를 통하여 바로 사용하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npx lerna init<br></code></pre></td></tr></table></figure><h2 id="2-Git-초기화"><a href="#2-Git-초기화" class="headerlink" title="2. Git 초기화"></a>2. Git 초기화</h2><p>lerna의 <code>publish</code> 명령어는 변경된 패키지를 일괄적으로 <code>Git Remote Repository</code>에 <code>Push</code>를 하므로 Git을 사용해야 한다. Github Repository를 미리 구축해 놓자.</p><p>Git을 통해 초기화 및 폴더까지 생성하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git init [DIR_NAME]<br><span class="hljs-built_in">cd</span> [DIR_NAME]<br></code></pre></td></tr></table></figure><h2 id="3-Lerna-Repository로-변경"><a href="#3-Lerna-Repository로-변경" class="headerlink" title="3. Lerna Repository로 변경"></a>3. Lerna Repository로 변경</h2><p>폴더를 생성하고 Git을 초기화하였다면 해당 Repository를 lerna로 구성하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna init --independent // or -i<br></code></pre></td></tr></table></figure><h3 id="lerna-json"><a href="#lerna-json" class="headerlink" title="lerna.json"></a>lerna.json</h3><p><code>lerna.json</code>은 lerna를 구성하는 설정 파일이다.</p><p>패키지로 배포와 관리된 <code>packages</code>를 명시해 주며 version 정책을 어떻게 가져갈 것인지며 <code>npmClint</code>는 npm을 사용하지 yarn을 사용할지 지정해 줄 수 있다.</p><p>아래와 같이 수정하자.</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;independent&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;npmClient&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yarn&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;useWorkspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;packages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;packages/*&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>우리는 version 정책을 독립 모드로 가져가기 때문에 <code>version: &quot;independent&quot;</code>로 지정한 것이고,<br><a href="https://classic.yarnpkg.com/en/">yarn</a>을 사용할 것이기 때문에 <code>npmClient: &quot;yarn&quot;</code> 그리고 yarn workspace 사용을 위해 <code>useWorkspaces: true</code>로 지정하였다.</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>Root 경로에 있는 <code>package.json</code>의 역할은 <code>공통된 node module들의 devDependencies</code>와 <code>최상위에서 실행될 script</code>들을 명시해준다.</p><p>아래와 같이 수정하자. </p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;private&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;workspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;packages/*&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;lerna&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.20.2&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>lerna.json에서 yarn workspace를 사용하였기 때문에 실제로 workspace에 어떤 패키지가 담길 것인지 지정해준다. 보통 <code>lerna.json의 packages의 경로와 일치</code>한다. 그리고 <code>private: true</code>로 지정함으로써 Root가 NPM Repository로 배포되는 것을 막아준다.</p><h2 id="4-패키지-생성"><a href="#4-패키지-생성" class="headerlink" title="4. 패키지 생성"></a>4. 패키지 생성</h2><p>이제 실제로 사용될 패키지를 만들어보자.</p><p>패키지는 <code>packages</code> 경로에 포함되어있어야 하며, 모든 패키지는 <code>lerna.json의 packages 속성에 따른다.</code> 수동으로 직접 폴더를 생성할 수도 있지만 lerna의 <code>create</code> 명령을 통해서도 기본 패키지의 구조를 Scaffolding 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna create [PACKAGE_NAME]<br></code></pre></td></tr></table></figure><p>우리는 <strong>CLI를 통한 Log 출력 패키지</strong>를 예시로 들고 있어서 <strong><code>log-cli</code></strong>와 <strong><code>log-core</code></strong>라는 두 패키지를 생성하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna create log-cli<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna create log-core<br></code></pre></td></tr></table></figure><p><code>log-cli</code>는 우리가 CLI command를 입력하여 그 값을 받아 처리하는 패키지이고, <code>log-core</code>는 입력받은 command를 통해 실제로 로그를 출력하는 패키지이다.</p><h2 id="5-공통-종속성-설치"><a href="#5-공통-종속성-설치" class="headerlink" title="5. 공통 종속성 설치"></a>5. 공통 종속성 설치</h2><p>Root 경로에 모든 패키지가 공통으로 사용될 모듈을 설치하자. <code>lerna add</code>라는 명령어를 사용할 수도 있지만 <code>lerna add</code>는 패키지 간 종속성 설치 시 사용하는 걸 추천한다.<br>그냥 사용한다 하더라고 Root 경로에 모듈은 설치되겠지만 각 패키지에 dependencies가 걸리게 되어있다. 그렇기 때문에 Root 경로의 공통 모듈을 <code>npm</code>또는 <code>yarn</code>을 통하여 설치하자.</p><p>공통으로 사용될 모듈로 <code>eslint</code>를 설치해보자 </p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add eslint --dev --ignore-workspace-root-check<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install eslint --dev<br></code></pre></td></tr></table></figure><div class="alert danger no-icon"><p><code>yarn</code>을 통해 eslint를 설치하기 위해서는 workspace를 지정하였기 때문에 일반 <code>add</code>를 통해서는 설치가 불가능하다. 그렇기 때문에 <code>--ignore-workspace-root-check</code> 옵션을 지정하도록 하자. </p></div><p>설치 후 Root 경로의 <code>package.json</code>을 보면 <code>devDependencies</code>에 <code>eslint</code>가 설치된 것을 확인 할 수 있다.</p><h2 id="6-각-패키지에-모듈-설치"><a href="#6-각-패키지에-모듈-설치" class="headerlink" title="6. 각 패키지에 모듈 설치"></a>6. 각 패키지에 모듈 설치</h2><p>이제 각 패키지에 필요한 모듈을 설치해보자.</p><h3 id="log-cli-모듈-설치"><a href="#log-cli-모듈-설치" class="headerlink" title="log-cli 모듈 설치"></a>log-cli 모듈 설치</h3><p>command를 입력받아야 하는 log-cli에 <a href="https://github.com/tj/commander.js#readme">commander</a>를 설치하자.</p><p>각 패키지에 모듈을 설치할 때에는 공통 모듈을 설치하는 것과는 다르게 <code>lerna add</code>를 통해서 각 패키지에 설치 할 수 있다. 이 과정에서 <code>hoisting</code>이 일어나고 종속성을 최적화시킨다.</p><p><code>lerna add</code>를 사용할 때는 <code>--scope</code> 옵션을 통해서 어느 패키지에 설치할 것인가를 명시해준다. <code>--scope</code>를 주지 않을 경우 모든 패키지에 설치된다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna add commander --scope=log-cli<br></code></pre></td></tr></table></figure><p>위 명령어 실행 후 파일 주로를 보면 log-cli 경로에 <code>node_modules</code> 폴더가 생성되지 않았다. 하지만 <code>package.json</code>을 보게 되면 commander 모듈이 추가되어있는 것을 볼 수 있다. 이는 종속성 최적화로 인해 Root 경로에 추가된 것이다.</p><h3 id="log-core-모듈-설치"><a href="#log-core-모듈-설치" class="headerlink" title="log-core 모듈 설치"></a>log-core 모듈 설치</h3><p>log-core에서는 console.log를 출력하는 모듈을 만들 것이다.</p><p>패키지 설치 방법을 익히기 위해 임의로 로그 문구에 색상을 입힐 수 있는 <a href="https://www.npmjs.com/package/chalk">chalk</a> 모듈을 설치해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna add chalk --scope=log-core<br></code></pre></td></tr></table></figure><p>설치 방법은 log-cli에서 설치한 방법과 동일하다. 다만 다른 게 있다면 log-cli와는 다르게 <code>log-core에는 node_modules 경로가 생성</code>되었다. 이 역시 <code>hoisting</code> 과정에서 일어난 사항이니 그게 염두에 두지 않아도 된다.</p><h2 id="7-각-패키지에-기능-추가"><a href="#7-각-패키지에-기능-추가" class="headerlink" title="7. 각 패키지에 기능 추가"></a>7. 각 패키지에 기능 추가</h2><p>필요한 모듈은 설치가 되었기 때문에 이제 각 패키지에서 기능이 동작되도록 구현하자.</p><h3 id="log-core-수정"><a href="#log-core-수정" class="headerlink" title="log-core 수정"></a>log-core 수정</h3><p><code>log-core.js</code>를 수정하자.</p><p><strong>log-core.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; red &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chalk&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">core</span> () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">red</span>(<span class="hljs-string">&#x27;❤  Running Core !!!!!&#x27;</span>))<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = core<br></code></pre></td></tr></table></figure><p><code>log-core</code>에서는 <code>chalk</code>를 사용하여 <code>console.log</code>를 출력해 주는 코드를 작성하였다.</p><h3 id="log-cli-수정"><a href="#log-cli-수정" class="headerlink" title="log-cli 수정"></a>log-cli 수정</h3><p><code>log-cli.js</code>와 <code>log-cli/package.json</code>을 수정하자 </p><p><strong>log-cli.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">#!/usr/bin/env node</span><br><br><span class="hljs-keyword">const</span> &#123; program &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;commander&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">LogCore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;log-core&#x27;</span>)<br><br><span class="hljs-comment">// action</span><br>program.<span class="hljs-title function_">action</span>(<span class="hljs-function"><span class="hljs-params">cmd</span> =&gt;</span> <span class="hljs-title class_">LogCore</span>())<br><br>program.<span class="hljs-title function_">parse</span>(process.<span class="hljs-property">argv</span>)<br></code></pre></td></tr></table></figure><p><strong>log-cli&#x2F;package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;log-cli&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;log-cli-example&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Your name&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;bin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;log-cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lib/log-cli.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;lib&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;commander&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^6.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>log-cli.js</code>에서는 <code>commander</code>와 <code>log-core</code>를 추가하고 <code>commander</code>를 통해 command를 입력받으면 <code>log-core</code>를 수행되게 되어있다.</p><p><code>package.json</code>에서는 기본적으로 추가되어있던 <code>main</code>속성 대신 <code>bin</code> 속성을 추가하여 CLI가 가능하게 수정한다.</p><h2 id="8-로컬에서-CLI-테스트-수행"><a href="#8-로컬에서-CLI-테스트-수행" class="headerlink" title="8. 로컬에서 CLI 테스트 수행"></a>8. 로컬에서 CLI 테스트 수행</h2><p>기능까지 완성이 되었으니 로컬에서 만든 모듈들을 실행해보자.</p><p>최초 실행은 <code>log-cli</code>를 실행하는 것이기 때문에 <code>log-cli</code>를 설치 후 실행해 보자. 여기서는 <code>npm link</code>를 통하여 global로 <code>symbolic link</code>를 생성하였다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm <span class="hljs-built_in">link</span> packages/log-cli<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">log-cli<br></code></pre></td></tr></table></figure><p><code>log-cli</code>를 입력하면 결과가 출력되는 것을 확인할 수 있다.</p><h2 id="9-패키지-내-참조-및-설치"><a href="#9-패키지-내-참조-및-설치" class="headerlink" title="9. 패키지 내 참조 및 설치"></a>9. 패키지 내 참조 및 설치</h2><p>위처럼 로컬에서 실행하면 정상적으로 동작된다. 로컬에서는 <code>log-cli</code>와 <code>log-core</code> 연관 관계를 인지하고 있기 때문이다. 그렇기 때문에 실제로 패키지를 배포 후 배포된 패키지를 설치하여 실행한다면 아래와 같은 오류가 출력될 것이다.</p><p><img src="/2020/08/27/mono-repo-lerna-example/error-capture.png" alt="run-error"></p><p>이 오류는 <code>log-cli</code>에서 <code>log-core</code>를 삽입하였는데 실제로 <code>log-cli</code>에는 <code>log-core</code>가 종속되지 않았기 때문에 발생한다. 이를 해결하기 위해서는 <code>lerna add</code>를 통해서 <code>log-cli</code>에 <code>log-core</code>를 설치해 해줘야 한다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna add log-core --scope=log-cli<br></code></pre></td></tr></table></figure><h2 id="10-Git-Commit과-Push"><a href="#10-Git-Commit과-Push" class="headerlink" title="10. Git Commit과 Push"></a>10. Git Commit과 Push</h2><p>이제 모든 변경 사항을 연동된 Git Remote Repository에 반영하자. 그 전에 불필요한 리소스들이 반영되지 않도록 Root 경로에 <strong><code>.gitignore</code></strong> 작성하는 것을 잊지 말자.</p><p>아래는 <code>.gitignore</code> 예시이다.</p><p><strong>.gitignore</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">.idea<br>node_modules<br>*.lock<br>*lock.json<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git add .<br>git commit -m <span class="hljs-string">&quot;deploy&quot;</span> <br>git push -u origin master<br></code></pre></td></tr></table></figure><h2 id="11-패키지-배포"><a href="#11-패키지-배포" class="headerlink" title="11. 패키지 배포"></a>11. 패키지 배포</h2><p>이제 패키지 배포 이전의 모든 작업이 끝이 났다. 실제로 지금까지 만든 <code>log-cli</code>와 <code>log-core</code>를 <code>NPM Repository</code>에 배포해 보자. NPM Repository에 대해서는 <a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a>을 참고하자.</p><p>NPM 설정이 준비되었다면 <code>lerna publish</code>를 통해서 모든 패키지를 배포하자.</p><div class="alert danger no-icon"><p>NPM Repository에 배포하기 전 <strong>log-cli와 log-core의 package.json에서 <code>name</code> 속성을 변경</strong>하자. 해당 명칭은 이미 배포된 다른 모듈과 충돌이 나므로 변경해야 한다. </p></div><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna publish<br></code></pre></td></tr></table></figure><p>위 명령어를 입력하면 <code>log-cli</code>와 <code>log-core</code>가 동시에 NPM Repository로 배포된 것을 확인할 수 있다.</p><p>위 예제는 <a href="https://github.com/kdydesign/lerna-example">lerna-example</a>에서 다운받거나 확인할 수 있다.</p><p><img src="/2020/08/27/mono-repo-lerna-example/lerna-publish-example.png" alt="lerna-publish-example"></p><div class="alert danger no-icon"><p>NPM Repository에 배포된 패키지는 <strong>72시간</strong>이 지나면 직접 지울 수 없어서 불필요하다면 즉시 삭제하기 바란다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm unpublish log-core -f<br>npm unpublish log-cli -f<br></code></pre></td></tr></table></figure><p><code>log-cli</code>에서 <code>log-core</code>가 종속되어있기 때문에 <code>log-cli</code>먼저 삭제해야 한다.</p></div><h2 id="12-릴리즈-패키지-설치-및-실행"><a href="#12-릴리즈-패키지-설치-및-실행" class="headerlink" title="12. 릴리즈 패키지 설치 및 실행"></a>12. 릴리즈 패키지 설치 및 실행</h2><p>이제 실제로 배포된 패키지를 설치하여 사용해 보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g log-cli // or PACKAGE_NAME<br></code></pre></td></tr></table></figure><hr><h2 id="릴리즈-노트-생성"><a href="#릴리즈-노트-생성" class="headerlink" title="릴리즈 노트 생성"></a>릴리즈 노트 생성</h2><p>lerna에서 독립 모드(Independent)로 사용하게 되면 릴리즈 노트가 걸릴 것이다. 릴리즈 노트는 보통 <code>CHANGELOG.md</code>로 남게 되는데 이를 위해서는 <code>lerna.json</code>을 아래와 같이 설정해 주면 기본적인 <code>CHANGELOG</code>를 사용할 수 있다.</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;independent&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;npmClient&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yarn&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;useWorkspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;packages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;packages/*&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;publish&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;conventionalCommits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>lerna의 <code>publish</code> 명령어를 실행하면 <code>conventiaonalCommit</code>이 실행되도록 <code>conventionalCommits</code> 옵션을 지정해 주었다. <a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional commits</a>는 이곳에서 참고하자.</p><p><code>conventionalCommits</code> 옵션을 지정하면 <code>semver</code>에 따른 버전이 결정되고 <code>commit message</code>의 기록에 따라 <code>CHANGELOG.md</code>가 각 패키지 별로 생성된다.<br>기본적인 옵션 이외에 <a href="https://github.com/lerna/lerna-changelog">lerna-changelog</a>를 사용하면 더 적합한 릴리즈 노트를 작성할 수 있다.</p><hr><p>여기까지 해서 <a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a>부터 예제를 통하여 <code>Lerna</code>와 <code>Mono-Repo</code>에 대해 알아보았다.</p><p>여기서 집고 넘어갈 것은 <code>Lerna</code>는 단순히 <code>Mono-Repo</code>를 구축하는 데 도움을 주는 도구에 불과하다. 귀찮고 오래 걸리겠지만 <code>Mono-Repo</code>의 구조에서 수동으로 생성, 배포, 설치 모두 할 수 있는 것이다. <code>Mono-Repo</code>의 구조로 간다면 패키지의 관리와 배포가 쉬워지니 반영해 볼 기회가 있다면 적극적으로 추천한다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> git </category>
          
          <category> repository </category>
          
          <category> mono-repo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> lerna </tag>
            
            <tag> mono-repo </tag>
            
            <tag> multi-repo </tag>
            
            <tag> poly-repo </tag>
            
            <tag> repository </tag>
            
            <tag> lerna tutorial </tag>
            
            <tag> lerna example </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</title>
      <link href="/2020/08/25/mono-repo-lerna/"/>
      <url>/2020/08/25/mono-repo-lerna/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/08/25/mono-repo-lerna/cover.png" alt="cover"></p><p><code>mono-repo</code> 구축을 위한 가이드! <code>mono-repo</code>와 <code>multi-repo</code>의 차이를 알아보고 <code>mono-repo</code> 구축을 위한 도구인 <code>lerna</code>를 살펴보자.</p><p>먼저 <code>mono-repo</code>에 대한 개념을 다지고 <code>mono-repo</code>의 장단점을 면밀히 살펴본 후 <code>lerna</code>를 파악해보자. 이 후 섹션에서는 <a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a>을 통해 <code>lerna</code>의 사용법을 예제를 통해서 정확하게 알아보자.</p><p>아직 <a href="https://en.wikipedia.org/wiki/Monorepo">Mono-Repo</a>나 이를 도와주는 <a href="https://github.com/lerna/lerna">lerna</a>가 널리 알려지지 않을 것 같다.<br>근래에 <code>Mono-Repo</code> 구축과 <code>lerna</code>를 사용할 기회가 있어서 실제로 반영하고 정보를 수집해 보았다. 모든 lerna 관련된 포스팅을 보았지만 lerna에 관련된 주요 명령어라든가 Mono-Repo에 대한 간략한 설명뿐 예제를 통한 하나의 workflow를 설명하는 곳이 없어서 아쉬움이 있었다.</p><p><code>lerna</code>의 명령어와 설정은 단순하지만, 생각보다 잘 안 되었다. 여러 번의 초기화와 Package 생성을 하면서 어느 정도 감을 잡을 수 있었다.<br>이렇게 쌓은 노하우 나와 같이 하나의 완성도 있는 절차가 필요하고 개념을 파악하는 사람들에게 도움이 되기를 바라며 정리를 해보았다.</p><p><code>lerna</code>를 알기 전에 <code>Mono-Repo</code>에 대해서 알아야 하고 <code>Mono-Repo</code>를 알기 위해서는 비교 대상인 <code>Multi-Repo</code>를 알아야 한다. 그러므로 해당 포스팅에서는 <code>Multi-Repo</code>와 <code>Mono-Repo</code>를 먼저 정리하겠다. </p><hr><h1 id="Multi-Repo"><a href="#Multi-Repo" class="headerlink" title="Multi-Repo"></a>Multi-Repo</h1><p><code>Multi-Repo</code>는 <code>여러 Repository에 Package를 분산해 두는 것을 의미</code>한다.</p><p>말 그대로 하나 또는 두 개 이상의 Package 관리를 하나 또는 두 개 이상의 Repository로 구성하여 관리하는 것이다. 예를 들어 <code>A</code>라는 Package를 구성하는 <code>B</code>, <code>C</code>라는 Package가 있을 경우 <code>B-Repository</code>, <code>C-Repository</code>로 나누어 두는 것을 의미한다.<br>여기서 꼭 <code>A</code>라는 Package가 없어도 상관없다. 의미 자체를 보면 Package 별로 Repository를 분리한다고 보면 된다. 보통 Package와 Repository는 1:1 관계를 맺으면 통상 사용하는 방식으로 생각하면 된다.</p><h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><ul><li><p><strong>Repository 별 Owner를 지정</strong></p><ul><li>Package 별로 Repository가 분리되어 있다는 것은 각 Package 별로 관리가 가능하다는 것이다. 이에 대해 각 Repository 별 Owner를 지정할 수 있고 이로 인해서 패키지 관리가 수월해 진다.</li></ul></li><li><p><strong>빠른 CI Build</strong></p><ul><li>각 Package가 Repository로 분리된다면 하나의 Repository는 하나의 CI를 구성할 수 있다. 이렇게 되면 하나의 큰 덩어리로 구성된 Package보다 리소스가 적기 때문에 CI의 Build 속도가 빨라지게 된다.</li></ul></li><li><p><strong>패키지의 명확한 분리로 인한 유연성 향상</strong></p><ul><li>Repository가 분리되어있기 때문에 각 패키지는 마스터 코드의 충돌을 방지 할 수 있으며, Repository 상 서로 연계 관계가 없기 때문에 추가, 수정, 유지 관리에 있어서 유연성이 향상된다.</li></ul></li></ul><h2 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h2><ul><li><p><strong>중복된 설정 및 반복된 설치</strong></p><ul><li>단일 Package를 구성할 때 이 패키지를 구성하는 Package를 Repository로 나눔으로써 모든 공통된 설정과 모듈들을 반복적으로 설정 및 설치해야 한다. 예를 들어 <code>eslint</code>와 <code>babel</code>을 설정한다고 하면 모든 Repository에 <code>eslint</code>와 <code>babel</code>을 설치하고 설정 파일을 동일하게 구성해야 한다.</li></ul></li><li><p><strong>이슈의 분산</strong></p><ul><li>Repository가 분리되어 있기 때문에 각 Repository는 이슈 트래킹을 가진다. 전혀 다른 Package라면 이슈 트래킹이 분리되는 게 정상이지만 하나의 큰 Package를 구성하고 내부 Sub Package가 필요한 상황이라면 이슈 트래킹은 분리되는 것이 옳지 않다. 이슈뿐만 아니라 <code>CHANGELOG</code> 역시 분리됨으로써 관리 포인트가 증가한다.</li></ul></li><li><p><strong>Dependency Hell</strong></p><ul><li>프로젝트 및 Package의 규모가 커짐에 따라 의존 그래프가 매우 복잡해지게 된다. 특정 Package들이 같은 모듈을 사용하지만, 버전 차이에 따라 종속성이 달라지고 이로 인한 충돌을 야기할 수 있다.</li></ul></li><li><p><strong>중복 코드의 가능성</strong></p><ul><li><strong>중복된 설정 및 반복된 설치</strong>와 비슷한 이유이며, 서로 Repository가 분리되어있기 때문에 공통된 코드가 중복될 가능성이 커진다.</li></ul></li></ul><h1 id="Mono-Repo"><a href="#Mono-Repo" class="headerlink" title="Mono-Repo"></a>Mono-Repo</h1><p><code>Multi-Repo</code>와 반대로 <code>Mono-Repo</code>는 <code>여러 Package를 Repository에서 관리하는 것을 의미</code>한다.</p><p><code>Multi-Repo</code>의 단점을 보완하면서 분리된 Package를 하나의 Repository로 합쳐 관리한다. 쉽사리 실 업무에 적용해 보기 쉽지 않기 때문에 <code>Multi-Repo</code>에 비해 활성화가 많이 되지는 않았다.<br>하지만 점차적으로 오픈 소스에서 지원하는 기능(CLI, UI, Core)이 많아지면서 오픈 소스에서 <code>Mono-Repo</code>를 많이 채택하고 있다.</p><p>이러한 <code>Mono-Repo</code>에 대해서 어떤 장단점이 있는지 알아보자.</p><h2 id="장점-1"><a href="#장점-1" class="headerlink" title="장점"></a>장점</h2><ul><li><p><strong>공통 항목 단일화</strong></p><ul><li>eslint, Build, Unit Test 등 공통된 설정 및 필요한 node module을 한 번의 설치와 한 번의 설정으로 모든 패키지가 사용할 수 있다. Repository가 분산되어있지 않고 하나의 Repository에 있기 때문에 dependencies의 업데이트 역시 한 번으로 해결이 가능하다.</li></ul></li><li><p><strong>쉬운 Pacakge 공유</strong></p><ul><li><code>Multi-Repo</code>의 경우 Pacakge가 분리되어 있기 때문에 Package 간 공유가 쉽지 않다. 그렇기 때문에 중복 코드가 발생할 가능성이 있는데 <code>Mono-Repo</code>의 경우엔 하나의 Repository이기 때문에 패키지 간 공유가 수월하며 중복 코드 역시 발생할 염려가 없다.</li></ul></li><li><p><strong>단일 이슈 트래킹</strong></p><ul><li>하나의 Repository에 패키지가 <code>Mono-Repo</code>로 구성되었다면 그 패키지의 모든 종속된 패키지는 서로 연관 관계를 가질 수 있다. 이로 인해서 이슈 트래킹은 분산 없이 하나로 처리가 가능하며 <code>Mono-Repo</code>는 이를 지원한다.</li></ul></li><li><p><strong>효율적인 의존성 관리</strong></p><ul><li>전체 Package의 의존 관계가 하나의 Repository에서 이루어지기 때문에 Package 간 의존성 관리가 수월해 진다.</li></ul></li></ul><h2 id="단점-1"><a href="#단점-1" class="headerlink" title="단점"></a>단점</h2><ul><li><p><strong>Repository의 거대화</strong></p><ul><li>분산되어 있던 모든 리소스를 하나의 Repository에서 관리가 되기 때문에 하나의 Repository의 규모가 커진다. 이로 인한 문제들은 나비효과처럼 커질 가능성을 보인다.</li></ul></li><li><p><strong>느린 CI Build</strong></p><ul><li><code>Multi-Repo</code>와 반대로 Repository가 하나로 되어 있기 때문에 <code>CI가 하나로 구성된다는 장점</code>이 있지만, Package가 규모가 커짐으로 인해 분산된 CI Build보다 속도가 느릴 수밖에 없다.</li></ul></li><li><p><strong>무분별한 의존성</strong></p><ul><li>Package 간 의존성 관리가 쉽다는 장점이 있지만, 오히려 이러한 장점으로 인해 과도한 의존 관계가 나타날 수 있다.</li></ul></li><li><p><strong>Dev Tools의 인덱싱 저하</strong></p><ul><li>개발 도구를 사용할 때 Package가 분산되어있다면 각각의 Package를 열어 사용하면 되지만 <code>Mono-Repo</code>의 경우는 하나의 개발 도구로 열 경우 해당 Package의 인덱싱 처리 속도가 길어진다.</li></ul></li></ul><p>위 내용을 얼추 보면 <code>Mono-Repo</code>의 장점은 <code>Multi-Repo</code>의 단점이고 <code>Multi-Repo</code>의 장점은 <code>Mono-Repo</code>의 단점이라는 것을 알 수 있다. 이렇게 장단점이 교차하기 때문에 무조건 <code>Mono-Repo</code>가 좋은 것은 아니다. 어떤 상황에서는 <code>Multi-Repo</code>가 빛을 발하는 경우가 있을 것이다.</p><h2 id="Quasar-Framework의-Mono-Repo"><a href="#Quasar-Framework의-Mono-Repo" class="headerlink" title="Quasar Framework의 Mono-Repo"></a>Quasar Framework의 Mono-Repo</h2><p>Desktop, Mobile을 지원하며 <code>Vue 기반의 Framework</code>인 <code>Quasar의</code> 구조를 보자. <code>Quasar</code>의 경우 최초에는 <code>Mono-Repo</code>로 구성되어 있진 않았지만, CLI, Extras 등 기능이 확장됨에 따라 <code>Mono-Repo</code>로 구성이 변경되었다.<br><code>lerna</code>를 사용하진 않았지만 구조는 <code>Mono-Repo</code>라는 것을 알 수 있다.</p><h2 id="규모가-큰-Mono-Repo의-대표적인-사례"><a href="#규모가-큰-Mono-Repo의-대표적인-사례" class="headerlink" title="규모가 큰 Mono-Repo의 대표적인 사례"></a>규모가 큰 Mono-Repo의 대표적인 사례</h2><p>사실 <code>Mono-Repo</code>가 활성화되는 시점은 이 사례부터일지도 모른다. 이 사례를 통해서 <code>Mono-Repo</code>를 보장한다고 볼 수 있다.</p><div class="alert info no-icon"><ul><li><p><strong>Google</strong></p><ul><li>초기 Google은 중앙 집중식 소스 제어 시스템을 통해 관리되는 공유 코드 베이스로 작업하기로 결정했다. 이 접근 방식은 16년 이상 Google에 좋은 서비스를 제공해 왔으며, 오늘날 Google의 소프트웨어 대부분이 <code>Mono-Repo</code>로 구성되어있다. 대표적인 예로 Google은 <a href="https://bazel.build/">Bazel</a>을 빌드 시스템으로 사용하며, <code>Mono-Repo</code>로 구성되어있다.</li></ul></li><li><p><strong>Facebook</strong></p><ul><li>수십만 개의 파일에 대해 매주 수천 개의 커밋이 있는 Facebook의 기본 소스 저장소는 Linux 커널보다 훨씬 더 크다. 대표적으로 <a href="https://buck.build/">Buck</a> 및 <a href="https://engineering.fb.com/core-data/scaling-mercurial-at-facebook/">Scaling Mercurial</a>이 있다.</li></ul></li><li><p><strong>Twitter</strong></p><ul><li>Twitter에는 확장이 가능한 <code>Mono-Repo</code> Build System인 <a href="https://www.pantsbuild.org/docs/welcome-to-pants">Pants</a>를 제공하고 있다.</li></ul></li></ul></div><h2 id="Mono-Repo는-언제-사용해야할까"><a href="#Mono-Repo는-언제-사용해야할까" class="headerlink" title="Mono-Repo는 언제 사용해야할까?"></a>Mono-Repo는 언제 사용해야할까?</h2><p><code>Mono-Repo</code>를 구성하는 적절한 시기는 정확하지 않다. 그러므로 구글링 자체로도 정보를 얻기엔 힘든 부분이 있다.<br>이러한 이유는 모든 프로젝트와 Package의 구조가 규모, 형태, 구조가 모두 다르기 때문이다. 하지만 아래와 같은 상황이라면 <code>Mono-Repo</code>를 구성해도 좋다.</p><div class="alert info no-icon"><ol><li>서로 다른 패키지가 연관 관계를 가질 경우</li><li>첫 번째 항목이 고려된 상황에서 <strong>N개의 패키지의 형태와 목적이 유사</strong>한 경우</li><li>두 번째 항목이 고려된 상황에서 <strong>N개의 패키지 중 배포되어야 할 패키지의 비중이 큰</strong> 경우</li></ol></div><p>이 외에 애매한 경우는 Package의 규모이다. Package의 클수록 개발 및 Build 등 Mono-Repo로 투자되는 비용이 많이 들기에 적당한 규모를 찾아야 하는데 이는 설계자 또는 개발자 역량에 따라 다르기 때문에 참고하기 바란다.</p><hr><p>지금까지 <code>Mono-Repo</code>에 대해서 알아보았다. 단순하게 <code>Mono-Repo</code>를 알고 구성하는 것은 어렵지 않지만 빠른 Scaffolding과 빠른 배포, 그리고 좀 더 효율적인 종속성 관리가 필요하다.<br>이를 위해 필요한 기능을 가진 모듈을 찾아 설치하고 설정하고 우리가 원하는 대로 처리 할 수 있고 이런 과정은 <code>lerna</code>가 처리해준다.</p><p>즉, <em>Lerna는 <code>Mono-Repo</code>를 위한 <code>CLI 도구</code>이다.</em></p><h1 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h1><p><code>lerna</code>는 <strong>Git과 NPM을 사용하여 MOno-Repo 관리와 Workflow를 최적화는 도구</strong>이고, 발음상 러나 또는 레르나라고 읽을 수 있다.</p><blockquote><p><code>lerna</code>의 BI는 Lernaean Hydra 또는 Lerna의 Hydra로 알려진 그리스 신화 생물이고, 많은 머리를 가지고 있었는데 그 정확한 수는 출처에 따라 다르다. 가장 최근의 Hydra 신화에서는 괴물에 재생 능력이 추가되어 머리가 잘릴 때마다 머리가 두 개씩 다시 자라난다고 한다.</p></blockquote><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><p><code>lerna</code>의 특징은 <code>Mono-Repo</code>를 구성하고 배포하는 데 중점에 둔 기능으로 볼 수 있다.</p><ul><li><p><strong>다중 패키지의 종속성 관리 및 모듈의 중복성 제거</strong></p><ul><li>lerna를 사용하여 node module을 설치할 경우 자체적으로 패키지들의 모듈을 설치하며, 그 과정에서 종속성을 관리하여 중복된 모듈을 하나로 통합한다.</li></ul></li><li><p><strong>다중 패키지의 단일 버전 및 독립적 버전 관리</strong></p><ul><li><code>Mono-Repo</code>의 구성을 따르면 여러 개의 Package로 구성된다. 이런 Package는 어떤 상황에서 하나의 버전 정책을 가져갈 수 있지만, 또 어떤 경우에는 서로 독립적인 버전 정책을 가져가야 하는 경우가 있는데 <code>lerna</code>는 이러한 기능을 지원하여 버전 정책을 정할 수 있다.</li></ul></li><li><p><strong>변경된 패키지를 일괄적으로 GIt Remote Repository에 Push</strong></p><ul><li>여러 Package가 수정되었다면 Package 별로 Git Remote Repository에 commit과 push를 할 필요가 없다. <code>lerna</code>를 사용하면 단 한 번의 commit과 push로 Remote Repository에 반영할 수 있다.</li></ul></li><li><p><strong>변경된 패키지를 일괄적으로 NPM Repository에 Publish</strong></p><ul><li>NPM Repository에 node module을 배포하기 위해서 <code>publish</code> 명령을 사용한다. <code>Mono-Repo</code>에서 각 Package를 NPM Repository에 배포하기 위해서 하나하나 publish를 입력할 필요가 없다. <strong>단 한 번의 publish로 변경 사항이 있는 Package만 배포</strong>가 될 것이다.</li></ul></li></ul><h2 id="Lerna-기반의-Mono-Repo"><a href="#Lerna-기반의-Mono-Repo" class="headerlink" title="Lerna 기반의 Mono-Repo"></a>Lerna 기반의 Mono-Repo</h2><p>앞서 설명했듯이 이미 많은 오픈 소스들이 <code>Mono-Repo</code>를 채택하였고 이를 위해 <code>lerna</code>를 사용하였다. 그렇다면 Lerna를 실제로 사용한 오픈소스에는 어떤 것들이 있을까?</p><div class="alert info no-icon"><ul><li>Babel</li><li>vue-cli</li><li>jest</li><li>nuxt.js</li><li>nuxt.js</li><li>webdriverio</li><li>create-react-app</li><li>create-nuxt-app</li><li>webpack-cli</li><li>graphql-server</li><li>typescript-eslint</li><li>react-router</li></ul></div><p><code>Bable</code>은 <code>lerna</code> 도입의 선두주자이고 bable의 파생 모듈은 매우 많기 때문에 <code>Mono-Repo</code>로써 적합하다고 볼 수 있다. </p><h2 id="lerna의-활동"><a href="#lerna의-활동" class="headerlink" title="lerna의 활동"></a>lerna의 활동</h2><p><a href="https://openbase.io/js/lerna">OpenBase-lerna</a>에서 lerna의 활동 상태를 확인해보자.</p><p>현재 3.22.x 버전까지 릴리즈가 된 상태이고 다운로드 수와 start가 점차 증가하는 것을 볼 수 있다. 하지만 개인적으로 버전이 3.x에 비해 안정적이진 않다고 생각된다. 아래에서 설명을 할 테지만 현재로서는 npm보다 yarn에 적합함을 보이고 이슈 생성과 PR의 요청이 많을 것으로 보아 앞으로 개발이 필요한 사항이 많아 보인다.</p><p><img src="/2020/08/25/mono-repo-lerna/openbase-lerna.png" alt="openbase-lerna"></p><h2 id="lerna의-구조"><a href="#lerna의-구조" class="headerlink" title="lerna의 구조"></a>lerna의 구조</h2><p><code>lerna</code>의 기본 구조는 Root 경로 아래 <code>packages</code> 폴더가 있고 그 하위에 각 package 별 폴더가 생성된다. <code>pacakges</code> 폴더는 기본값이며 설정에 따라 유동적으로 변경할 수 있다. 각 pacakge 폴더는 package 별 이름을 지정할 수 있으며 각각의 packages에는 <code>package.json</code>이 명시되는 것처럼 <strong>하나의 모듈로 간주</strong>한다.</p><p>Root 경로에 있는 <code>pacakge.json</code>에는 모든 package가 공통으로 사용되는 <code>dependencies</code>가 명시되는 등 공통 항목이 나열된다. </p><p><img src="/2020/08/25/mono-repo-lerna/lerna-file-structure.png" alt="lerna-file-structure"></p><h2 id="lerna의-주요-기능"><a href="#lerna의-주요-기능" class="headerlink" title="lerna의 주요 기능"></a>lerna의 주요 기능</h2><h3 id="Fixed-Mode"><a href="#Fixed-Mode" class="headerlink" title="Fixed Mode"></a>Fixed Mode</h3><ul><li>다중 패키지의 버전이 <code>단일 버전 라인</code>에서 작동하며 관리</li><li>버전은 프로젝트 Root에서 관리되며 lerna publish를 실행할 경우 새 버전으로 패키지를 게시</li><li>하나의 패키지가 수정되더라도 모든 패키지는 새로운 버전을 게시</li></ul><h3 id="Independent-Mode"><a href="#Independent-Mode" class="headerlink" title="Independent Mode"></a>Independent Mode</h3><ul><li>패키지의 유지 관리자가 서로 <code>독립적으로 패키지 버전을 관리</code></li><li>lerna publish 시 변경된 패키지에 대해서만 새 버전을 업데이트</li><li>버전은 각 패키지의 package.json에 명시</li></ul><h3 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h3><ul><li>다중 패키지에서 사용되는 node module을 최적화하여 중복되는 node module을 최상위 경로로 재구축</li><li>공통 종속성을 최상위 수준에서만 설치되며 개별 패키지는 생략</li></ul><p><img src="/2020/08/25/mono-repo-lerna/lerna-hoisting.png" alt="lerna-hoisting"></p><p>그림에서 보듯이 <code>hoist</code>를 통해서 node_module을 최적화하여 중복되는 모듈을(B (1.0)))을 최상위로 재구축한다.</p><h3 id="Yarn-Workspace"><a href="#Yarn-Workspace" class="headerlink" title="Yarn Workspace"></a>Yarn Workspace</h3><ul><li>Yarn은 유일하게 Mono-Repo 기능을 지원하고 <code>Yarn Workspace의 목적은 Mono-Repo의 Workflow를 용이</code>하게 하는 것이다.</li><li>Yarn Workspace를 통해 각 패키지는 서로 참조하는 연관 관계를 가질 수 있다.</li><li>NPM은 Version 7부터 worksapce 개념이 제공될 예정</li></ul><h2 id="lerna-주요-명령어"><a href="#lerna-주요-명령어" class="headerlink" title="lerna 주요 명령어"></a>lerna 주요 명령어</h2><p><code>lerna</code>의 핵심 명령어는 <code>bootstrap</code>과 <code>publish</code>이다. <code>bootstrap</code>을 통해서 모든 package에 node module을 설치하며 최적화를 통해 중복된 모듈을 정리해준다. <code>publish</code>는 <code>npm publish</code>와 동일한 기능을 하지만 <code>lerna</code>에서는 모든 pacakge를 대상으로 한 번의 명령어로 배포할 수 있다.</p><p>이 외의 핵심 명령어는 아래 내용을 참고하고 자세한 옵션은 <a href="https://github.com/lerna/lerna">Lerna 공식 사이드</a>를 참고하자.</p><h3 id="lerna-clean"><a href="#lerna-clean" class="headerlink" title="lerna clean"></a>lerna clean</h3><ul><li>Root를 제외한 package에서 node_module을 제거한다.</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna clean<br></code></pre></td></tr></table></figure><h3 id="lerna-bootstrap"><a href="#lerna-bootstrap" class="headerlink" title="lerna bootstrap"></a>lerna bootstrap</h3><ul><li>모든 패키지의 node_module을 설치한다.</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna bootstrap<br></code></pre></td></tr></table></figure><h3 id="lerna-run"><a href="#lerna-run" class="headerlink" title="lerna run"></a>lerna run</h3><ul><li>각 패키지의 package.json에 명시된 script를 실행한다.</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna run<br></code></pre></td></tr></table></figure><h3 id="lerna-publish"><a href="#lerna-publish" class="headerlink" title="lerna publish"></a>lerna publish</h3><ul><li>마지막 릴리즈 이후 업데이트 된 패키지를 배포한다.</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna publish<br></code></pre></td></tr></table></figure><h3 id="lerna-exec"><a href="#lerna-exec" class="headerlink" title="lerna exec"></a>lerna exec</h3><ul><li>각 패키지에서 임의의 커맨드 명령어를 실행한다.</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lerna <span class="hljs-built_in">exec</span><br></code></pre></td></tr></table></figure><hr><p>여기까지 해서 <code>Mono-Repo</code>와 <code>lerna</code>에 대해 개념부터 파악을 하였다. 사실상 <code>lerna</code>의 명령어는 몇 개 안되지만 이대로 진행하더라도 정확하게 개념을 파악하기는 어렵다. 생각지도 못한 오류와 예상 밖으로 명령어가 실행되기 때문이다.</p><p>그렇기 때문에 다음 섹션에서는 <code>lerna를 활용한 Log 출력 패키지 예제</code>로 <code>lerna</code>와 <code>Mono-Repo</code>의 전체적인 흐름을 파악해 보자.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> git </category>
          
          <category> repository </category>
          
          <category> mono-repo </category>
          
          <category> lerna </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> lerna </tag>
            
            <tag> mono-repo </tag>
            
            <tag> multi-repo </tag>
            
            <tag> poly-repo </tag>
            
            <tag> repository </tag>
            
            <tag> lerna tutorial </tag>
            
            <tag> lerna example </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Icon Font 제작 방법을 배워보자!</title>
      <link href="/2020/08/25/web-icon-font/"/>
      <url>/2020/08/25/web-icon-font/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2020/08/25/web-icon-font/web-icon-font-cover.png" alt="cover"></p><p>흔히 아는 <a href="https://material.io/resources/icons/?style=baseline">Material-Icon</a>, <a href="https://fontawesome.com/">Font-Awesome</a>, <a href="https://ionicons.com/">Ionic-Icon</a>은 SVG를 토대로 font 형식으로 생성하여 사용되는 web icon font이다.<br>보통 위 icon set을 가져다가 쓰겠지만 프로젝트를 하면서 내가 원하는 아이콘이 없다면 어떡할까? 대부분 아이콘은 png로 제작되고 icon font를 생성하여 만들지 않는다.</p><p>이번 포스트에서는 매일 가져다가 쓰지 않으며 <a href="https://www.w3schools.com/css/css_image_sprites.asp">Image Sprite</a>를 통해서 Image Icon을 사용하지 않는 직접 web icon font를 만들어서 사용하는 방법에 대해 알아보자.</p><h1 id="Icon-Font"><a href="#Icon-Font" class="headerlink" title="Icon Font"></a>Icon Font</h1><p><code>Icon Font</code>는 SVG 기반의 Vector 그래픽을 Font 파일 화 하여 CSS를 통해서 Icon을 사용하는 방식이다.<br>수많은 이미지 아이콘을 관리해야 하는 방법과 다르게 단순히 Font 파일과 CSS만 관리하면 된다.<br>대표적으로는 <a href="https://material.io/resources/icons/?style=baseline">Material-Icon</a>, <a href="https://fontawesome.com/">FontAwesome</a> 이 있으며, 이 외에 여러 프레임워크에서 자체 Icon Font를 지원하기도 한다.</p><h1 id="과거와-현재"><a href="#과거와-현재" class="headerlink" title="과거와 현재"></a>과거와 현재</h1><h2 id="Image-Sprite"><a href="#Image-Sprite" class="headerlink" title="Image Sprite"></a>Image Sprite</h2><p>Icon을 표현하고 작업하는 데 있어서 이전에도 그렇고 현재도 동일하게 사용하는 방식은 Image Sprite 방식이다.<br><a href="https://www.w3schools.com/css/css_image_sprites.asp">Image Sprite</a>는 여러 아이콘을 하나의 큰 이미지에 모두 포함해 CSS의 Position을 이용하여 해당 위치에 있는 아이콘만 보여주는 방식이다.</p><p>Image Sprite의 장점은 최소화된 HTTP 요청을 통해 문서에 삽입한다. 하지만 스마트 폰의 활성화와 다양한 DPI를 제공하는 기기들이 늘어나면서 이미지가 강제로 DPI에 맞게 늘어나 뿌옇게 보이거나 깨지는 현상이 발생한다.<br>이러한 이유로 Sprite 된 이미지의 크기를 변경해야 하거나 수정해야 하는데 이럴 때 불편함을 보인다.</p><p>이러한 단점에도 불구하고 장점이 더욱더 많기 때문에 현재까지도 많이 사용되는 방식이다.</p><h2 id="Web-Font"><a href="#Web-Font" class="headerlink" title="Web Font"></a>Web Font</h2><p>현재에 와서 이렇게 다양한 디스플레이 크기에 픽셀 기반의 이미지는 대응하지 못하기 때문에 온전한 이미지를 대체하기 위해 초기에는 <a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%9F%AC%EB%B8%94_%EB%B2%A1%ED%84%B0_%EA%B7%B8%EB%9E%98%ED%94%BD%EC%8A%A4">SVG</a>를 사용했지만, 구형 브라우저 및 모던 브라우저들이 당시에는 SVG를 지원하지 못했다.<br>이를 극복하기 위해 Vector 형식의 아이콘을 Web Font로 만들어서 사용하였는데 이러한 방식이 많이 애용되면서 <code>FontAwesome</code>이란 Vector 기반의 Web Font가 무료로 제공되기 시작했다.<br>이 <a href="https://fontawesome.com/">Font-Awesome</a>을 시작으로 다양한 <code>Web Icon Font</code>가 개발되기 시작했다.</p><h1 id="추이"><a href="#추이" class="headerlink" title="추이"></a>추이</h1><p>10년간의 <a href="https://fontawesome.com/">Font-Awesome</a>과 <a href="https://material.io/resources/icons/?style=baseline">Material-Icon</a>의 추세를 보면 계속 증가하는 추세로 보이며, Icon Font의 선두주자답게 <code>FontAwesome</code>에 대한 관심도가 가장 높은 것으로 보인다.</p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2213_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"fontawesome","geo":"","time":"2010-01-01 2020-08-05"},{"keyword":"material icon","geo":"","time":"2010-01-01 2020-08-05"}],"category":0,"property":""}, {"exploreQuery":"date=2010-01-01%202020-08-05&q=fontawesome,material%20icon","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><h1 id="Icon-Font-1"><a href="#Icon-Font-1" class="headerlink" title="Icon Font"></a>Icon Font</h1><h2 id="Icon-Font-장점"><a href="#Icon-Font-장점" class="headerlink" title="Icon Font 장점"></a>Icon Font 장점</h2><p><strong>1. 하나의 글꼴 파일에 다양한 아이콘을 넣어두고 사용</strong></p><p>Image Sprite와 비슷하게 Icon Font도 모든 Icon을 Font 파일 하나에 넣어서 사용이 가능하다.<br>Image Sprite는 모든 Icon을 담기에는 무리가 있기에 형태 별, 종류별로 분리를 하지만 Icon Font는 구분 없이 모든 아이콘을 하나로 관리할 수 있다. 그렇기 때문에 HTTP 요청 역시 단 한 번만 진행된다.</p><p><strong>2. CSS로 확장하여 모든 작업이 가능</strong></p><p>Image Icon과 동일하게 CSS를 통해서 크기, 변형, 회전 등 모든 작업이 가능하다. 특히 <code>color</code>를 사용한다면 하나의 아이콘으로도 여러 가지 색을 가진 Icon을 표현할 수 있다.</p><p><strong>3. Vector Graphic이기 때문에 크기 변형에 제한이 없음</strong></p><p>픽셀 기반의 Image는 기본 크기에 비례하여 확대할 경우 이미지가 깨지는 현상을 볼 수 있는데 Icon Font는 Vector 기반으로 연산 된 그래픽 이기 때문에 제한 없이 확대를 한다 하더라도 Icon 형태 그대로 유지 할 수 있다.</p><p><strong>4. Unicode 또는 Ligature 사용</strong></p><p>Image Icon의 경우 CSS로 class를 정의하여 해당 class만을 사용하지만, Icon Font의 경우 Unicode 및 Ligature를 사용할 수 있다.<br>Ligature는 Icon Font로 생성된 CSS의 class를 사용하지 않고 Text 형식으로 사용할 수 있다.</p><p>아래 코드를 보자.</p><p><strong>Ligature</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-class sub-class&quot;</span>&gt;</span>arrow_up<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>해당 코드에서 arrow_up은 Icon Font에서 Ligature이다. CSS class를 통한 사용이 아닌 Text 형식으로 삽입하게 되면 Icon이 출력되게 되어 있다.<br>만약 CSS를 통한 사용이 된다면 아래와 같을 것이다.</p><p><strong>Ligature - CSS</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-class sub-class icon-arrow_up&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Unicode 및 Ligature의 key는 SVG를 Font 파일로 변환 시 지정할 수 있으며, 수많은 아이콘 중 Unicode를 사용하면 특정 아이콘만 사용이 가능하다.</p><div class="alert info no-icon"><p>Locale 별 서로 다른 아이콘이 Font 파일에 있을 경우 모두 사용될 필요는 없다. 이럴 경우에 Unicode를 사용하여 해당 지역에서 사용되는 Icon만 사용할 수 있다.</p></div><p><strong>5. 전체 서체보다 적은 문자를 포함하여 파일의 크기가 작음</strong></p><p>Icon Font 역시 Font 파일이지만 일반 서체용 Font 파일보다는 단순하게 아이콘만 저장되어 있기 때문에 일반 Font보다 파일의 용량이 적다.<br>Image Icon으로 비교해 보자면 약 1,000개의 Image Icon이 1.3MB라고 할 경우 동일하게 1,000개의 Icon을 Icon Font로 만들 경우 5KB밖에 되지 않는다.</p><h2 id="Icon-Font-단점"><a href="#Icon-Font-단점" class="headerlink" title="Icon Font 단점"></a>Icon Font 단점</h2><p>이렇게 장점이 많지만 단 하나의 단점이 있다. 이 단점으로 인해 모든 Icon을 Icon Font로 만들지 못하는 이유이다.</p><p><strong>다양한 색상의 Icon 표현 불가</strong></p><p>Icon Font 자체만 놓고 보았을 때는 Font 파일이다. Font 파일의 글꼴은 색상 정보가 포함되어 있지 않기 때문에 여러 색상을 가진 Icon Font는 생성할 수 없다.<br>굳이 하자면 여러 글리프를 색상별로 분리해 놓고 하나로 겹쳐 하나의 폰트처럼 보일 수 있지만 이렇게 하면 아이콘 제작에 많은 시간을 투자하게 되기 때문에 효율 적이지 않다.</p><div class="alert info no-icon"><p>여러 글리프를 겹쳐 하나의 글꼴을 만드는 것을 <a href="https://www.myfonts.com/search/chromatic/">크로마 틱</a> 글꼴이라고 한다.</p></div><h1 id="Icon-Font-생성-도구"><a href="#Icon-Font-생성-도구" class="headerlink" title="Icon Font 생성 도구"></a>Icon Font 생성 도구</h1><p>Icon Font를 가장 쉽게 만들 방법은 도구를 사용하는 것이다. 이미 상용화된 소스들이 많을뿐더러 SVG만 있다면 누구나 SVG를 통하여 Icon Font로 제작할 수 있다.<br>대표적인 도구로는 <a href="https://icomoon.io/">IcoMoon</a>, <a href="https://glyphter.com/">Glyphter</a>, <a href="http://fontello.com/">Fontello</a>가 있으며 웹 페이지에 SVG를 업로드하면 Font 파일로 변환하여 다운로드할 수 있다.<br>이 과정에서 대부분 위에서 언급한 <code>Unicode</code> 및 <code>Ligature</code>를 설정하거나 볼 수 있다.</p><h1 id="Icon-Font-제작-도구"><a href="#Icon-Font-제작-도구" class="headerlink" title="Icon Font 제작 도구"></a>Icon Font 제작 도구</h1><p>Icon Font 제작을 위해서는 SVG를 생성하고 이 SVG를 Font 파일 및 CSS로 변환해야 한다. 이러한 과정을 도와주는 여러 가지 도구가 있어서 소개하고 간략하게 집고 넘어가자.</p><h2 id="SVG-생성-도구"><a href="#SVG-생성-도구" class="headerlink" title="SVG 생성 도구"></a>SVG 생성 도구</h2><p>Icon Font로 생성하기 SVG는 보통 일러스트를 통해서 제작한다. 어떤 방법이든 SVG를 만들면 되지만 일러스트의 경우 유료라이센스이며 <a href="https://inkscape.org/ko/">inkscape</a>는 무료 라이센스이기 때문에 선택에 따라서 사용하면 된다.</p><h2 id="Fontagon"><a href="#Fontagon" class="headerlink" title="Fontagon"></a>Fontagon</h2><p>Icon Font 변환 도구를 통해서 Icon Font를 제작할 수 있지만, 자체 내 Build System 구축을 하고 싶다면, <a href="https://github.com/kdydesign/fontagon">Fontagon</a>을 보자.<br><code>Fontagon</code>은 <a href="https://www.npmjs.com/package/webfonts-generator">Webfonts-Generator</a>를 기반으로 재구축한 오픈 소스이며, Build System을 지원할 뿐만 아니라 CLI를 통하여 간단하고 빠르게 SVG를 Font로 변환할 수 있다.</p><p>Fontagon을 사용하면 SVG를 모든 형식의 폰트 파일로 생성할 수 있으며, 이 폰트를 사용이 가능하도록 CSS를 구성해 준다. 사용자는 만들어져 있는 CSS의 class만을 사용하면 된다.</p><p>Fontagon의 기능은 다음과 같다.</p><ul><li>WOFF2, WOFF, TTF, EOT, TTF, SVG를 지원</li><li>CSS, Sass, Less 모두 지원 및 생성</li><li>사용자 정의 CSS Template 생성 가능</li><li>ligature 지원</li></ul><div class="alert info no-icon"><p><strong>Font 종류 및 특징</strong></p><ul><li><strong>eot</strong>: IE 전용, 기본적으로 압축되지 않음</li><li><strong>ttf</strong>: 부분적인 IE 지원, 기본적으로 압축되지 않음</li><li><strong>woff</strong>: 지원 범위가 가장 넓지만 몇몇 이전 브라우저에서는 사용 불가, 압축이 기본적으로 지원</li><li><strong>woff2</strong>: 현재 많은 브라우저에서 지원, 맞춤형 처리 및 압축 알고리즘을 사용하여 다른 폰트 형식보다 30% 파일 크기 절감</li></ul></div><h3 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h3><p>Fontagon-CLI는 Global로 설치하여 사용 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install fontagon<br>npm install -g fontagon-cli  // cli <br></code></pre></td></tr></table></figure><h3 id="Build-Script"><a href="#Build-Script" class="headerlink" title="Build Script"></a>Build Script</h3><p>Fontagon의 옵션은 <a href="https://github.com/kdydesign/fontagon/tree/master/packages/fontagon">Document</a>에서 확인해보자.</p><p><strong>index.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Fontagon</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fontagon&#x27;</span>)<br><br><span class="hljs-title class_">Fontagon</span>(&#123;<br>  <span class="hljs-attr">files</span>: [<br>    <span class="hljs-string">&#x27;path/**/*.svg&#x27;</span><br>  ],<br>  <span class="hljs-attr">dist</span>: <span class="hljs-string">&#x27;dist/&#x27;</span>,<br>  <span class="hljs-attr">fontName</span>: <span class="hljs-string">&#x27;fontagon-icons&#x27;</span>,<br>  <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>  <span class="hljs-attr">classOptions</span>: &#123;<br>    <span class="hljs-attr">baseClass</span>: <span class="hljs-string">&#x27;fontagon-icons&#x27;</span>,<br>    <span class="hljs-attr">classPrefix</span>: <span class="hljs-string">&#x27;ft&#x27;</span><br>  &#125;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">opts</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done! &#x27;</span> ,opts)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fail! &#x27;</span>, err)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h3><p>Fontagon을 통해서 Build가 진행되면 CSS 파일이 추출된다. 이 CSS 파일에는 같이 추출된 Font 파일들을 Import하고 있으며 해당 CSS를 삽입하여 사용하면 된다.</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;dist/fontagon-icons.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../dist/fontagon-icons.css&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fontagon-icons ft-icon&quot;</span>&gt;</span>SVG FILE NAME<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fontagon-icons ft-icon ft-SVG FILE NAME&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>단점에서 설명했듯이 Icon Font 하나만으로는 사용이 불가능하기 때문에 Image Icon 역시 같이 사용해야 한다.<br>하지만 같이 사용한다 하더라도 많은 양의 리소스를 줄일 수 있으며, Icon Font를 사용하면 확실히 이점을 남길 수 있다.</p><p>이전부터 <a href="https://material.io/resources/icons/?style=baseline">Material-Icon</a>과 <a href="https://fontawesome.com/">Font-Awesome</a>을 대다수가 사용하면서 목적과 디자인이 다른 웹 페이지 및 애플리케이션들이 어딘가 모르게 비슷한 느낌을 준다. 본인이 어떤 프로젝트를 하고 있고 차별화된 느낌을 주면서 효율성도 챙기고 싶다면 회사, 디자이너, 퍼블리셔에서 Icon Font 제작을 권해보자.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a><br><a href="https://kdydesign.github.io/2020/08/25/mono-repo-lerna/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 개념 정리</a><br><a href="https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/">Lerna를 활용한 Mono-Repo 구축 완벽 가이드 - 예제를 통한 완벽 파악</a><br><a href="https://kdydesign.github.io/2020/11/27/lerna-changelog/">Lerna에서 lerna version을 사용하여 CHANGELOG를 생성해보자.</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> fontagon </category>
          
          <category> icon font generate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> icon-font </tag>
            
            <tag> svg </tag>
            
            <tag> font </tag>
            
            <tag> web font </tag>
            
            <tag> web icon font </tag>
            
            <tag> fontagon </tag>
            
            <tag> material icon </tag>
            
            <tag> ionic icon </tag>
            
            <tag> fontawesome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 전처리기(Pre-Processor) 배우기!</title>
      <link href="/2019/05/12/css-preprocessor/"/>
      <url>/2019/05/12/css-preprocessor/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/05/12/css-preprocessor/css-preprocessor-cover.png" alt="cover"></p><p>이번 포스트에서는 <code>Sass</code>, <code>Less</code>, <code>Stylus</code>와 같은 <code>CSS 전처리기(CSS Preprocessor)</code>에 대해 알아보자.</p><p>CSS 전처리기(CSS Preprocessor)는 모듈별로 특별한 <code>Syntax</code>를 가지고 있고 여기에 <code>믹스인(mixin)</code>, <code>중첩 셀렉터(nesting selector)</code>, <code>상속 셀렉터(inheritance selector)</code> 등 Programmatically 한 요소를 접목해 방대해지는 CSS 문서의 양을 효율적으로 처리하고 관리해 주는 통합적인 단어를 말한다. 이 CSS 전처리기(CSS Preprocessor) 자체만으로는 웹 서버가 인지하지 못하기 때문에 각 CSS 전처리기에 맞는 <code>Compiler</code>를 사용해야 하고 컴파일을 하게 되면 실제로 우리가 사용하는 CSS 문서로 변환이 된다.</p><p>이번 포스트에서는 이 세 가지의 CSS 전처리기를 비교해보고 동향을 알아보며, Sass, Less, Stylus를 직접 설치 및 사용하는 방법을 배워보자.</p><p style="text-align: center;font-weight: bold">- 해당 포스트에서는 세 가지의 전처리기 문법을 다루지는 않습니다. -</p><hr><h1 id="CSS-전처리기-CSS-Preprocessor"><a href="#CSS-전처리기-CSS-Preprocessor" class="headerlink" title="CSS 전처리기(CSS Preprocessor)"></a>CSS 전처리기(CSS Preprocessor)</h1><p>위에 설명한 바와 같이 <code>CSS 전처리기(CSS Preprocessor)</code>는 CSS 문서의 작성에 도움을 주는 도구이다. 우리가 흔히 CSS 문서 작성할 때는 많은 반복적인 작업을 요구하고 Color 값을 찾는 일, tag를 닫는 일 등 번거로운 작업 역시 포함되어있다. 그뿐만 아니라 클래스의 상속과 같은 사항으로 점점 CSS 문서는 양이 많아지고 이로 인해서 이후 유지관리에 많은 영향을 준다. 이런 CSS의 문제점들을 Programmatically 한 방식. 즉 변수, 함수, 상속 등 일반적인 프로그래밍 개념을 사용하여 해결해 나갈 수 있다.</p><p>CSS 전처리기(CSS Preprocessor)에는 다양한 모듈이 존재하고 가장 많이 사용되는 전처리기에는 <code>Sass</code>, <code>Less</code>, <code>Stylus</code>가 있으며, 서로의 특징에 맞게 약간의 Syntax만 다를 뿐 개념 자체는 동일하기 때문에 Learning curve가 낮은 편이다.</p><h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><p>CSS 전처리기(CSS Preprocessor) 역시 하나의 기술이기 때문에 장단점이 존재할 수밖에 없다. 장점이라 하면 위에서도 설명했지만 정리하자면 이렇다.</p><div class="alert info no-icon"><ul><li>재사용성 - 공통 요소 또는 반복적인 항목을 변수 또는 함수로 대체</li><li>시간적 비용 감소 - 임의 함수 및 Built-in 함수로 인해 개발 시간적 비용 절약</li><li>유지 관리 - 중첩, 상속과 같은 요소로 인해 구조화된 코드로 유지 및 관리가 용이</li></ul></div><p><strong>재사용성</strong>의 장점을 가장 쉽게 파악하는 방법은 <code>CSS에서 color를 지정</code>하는 방법을 생각해보자. 우리가 특정 클래스에 color 속성을 주고 값을 지정할 때 <code>hex code</code> 또는 <code>RGB</code>로 지정을 한다. 하지만 특정 색상이 반복된다면 우리는 주기적으로 색상 코드를 찾고 반영을 해줘야 한다. 하지만 CSS 전처리기(CSS Preprocessor)에서는 이런 반복되는 부분을 변수로 처리할 수 있다. 대부분 실무에서는 하나의 파일 안에 <code>color-set</code>을 모두 정의하여 사용된다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sass">$primary-color: #fff<br><br>.class-A <br>    background-color: $primary-color<br><br><br>.class-B <br>    background-color: $primary-color<br></code></pre></td></tr></table></figure><p><strong>시간적 비용 감소</strong>에 대해서 보자. </p><p>각 CSS 전처리기(CSS Preprocessor)에는 <code>내장함수(Built-in Functions)</code>가 존재한다. 이 내장 함수는 이미 전처리기 내에 포함된 함수로 우리는 필요한 값들만 전달하면 이에 대한 결과를 생성해 준다. 예를 들어 <code>darken(color, amount)</code>이라는 내장 함수는 색상과 퍼센티지를 지정해 주면 거기에 알맞은 값을 출력해 준다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sass">$color: #2ecc71<br>$buttonDark: darken($buttonColor, 10%)<br><br>button <br>    background: $color<br>    box-shadow: 0px 5px 0px $buttonDark<br><br></code></pre></td></tr></table></figure><p><strong>유지 관리</strong>는 가장 중요하고 눈에 띄는 장점 중의 하나이다. </p><p>클래스를 정의하다 보면 상속과 공통 속성을 지정하기 위해서 무지막지하게 길게 정의를 한다. 이런 이유로 CSS 문서가 가독성이 매우 떨어지는 이유 중 하나이다. 이런 내용을 CSS 전처리기(CSS Preprocessor)에서는 <code>중첩(Nesting)</code>과 <code>상속(Extend)</code>을 통해 구조화 할 수 있다.</p><p><code>중첩(Nesting)</code>은 아래처럼 정의한다.</p><p><strong>중첩(Nesting)</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sass">.class-A <br>    width: 100%<br><br>    .A-child-1 <br>        color: red<br>    <br><br>    .A-child-2 <br>        color: blue<br></code></pre></td></tr></table></figure><p>위 내용을 컴파일하게 되면 아래와 같다.</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class-A</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span><br>&#125;<br><br><span class="hljs-selector-class">.class-A</span> <span class="hljs-selector-class">.A-child-1</span> &#123;<br>    <span class="hljs-attribute">color</span>: red<br>&#125;<br><br><span class="hljs-selector-class">.class-A</span> <span class="hljs-selector-class">.A-child-2</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue<br>&#125;<br></code></pre></td></tr></table></figure><p><code>상속(Extend)</code>은 아래처럼 정의한다.</p><p><strong>상속(Extend)</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sass">.class-A <br>    color: red<br>    padding: 10px<br><br>.class-B <br>    @extend .class-A<br>    border: 1px solid red<br></code></pre></td></tr></table></figure><p>위 내용을 컴파일하게 되면 아래와 같다.</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class-A</span>, <span class="hljs-selector-class">.class-B</span> &#123;<br>    <span class="hljs-attribute">color</span>: red<br>    padding: <span class="hljs-number">10px</span><br>&#125;<br><br><span class="hljs-selector-class">.class-B</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h2><p>성능, 사용성 등 단점을 찾고 있겠지만 가장 중요한 것 중 하나가 실무에서의 사용이다. 그리고 이 내용이 곧 단점이 되기도 하다. 실무에서는 대부분 <code>CSS의 작업(Publishing)</code>은 <code>퍼블리셔(Publisher)</code> 또는 <code>디자이너(Designer)</code>가 진행하게 된다. 물론 Front-End 개발자가 진행하는 경우도 있지만 좀 더 체계가 필요한 회사나 프로젝트에서는 퍼블리셔나 디자이너가 퍼블리싱 작업을 하는 경우가 있는데 퍼블리셔나 디자이너가 개발에 대한 역량과 요소를 알아야 한다는 것이 문제이다. 지금까지 말했지만, CSS 전처리기(CSS Preprocessor)는 Programmatically 한 요소를 접목했기 때문에 분기문 처리, 변수의 이해, mixin의 이해 등 개발적인 요소를 알아야 하기 때문이다. Learning curve가 낮다는 장점은 순전히 개발자에 한해서이다.</p><p>여기까지 해서 CSS 전처리기(CSS Preprocessor)의 장점과 이에 따른 간단한 예제를 보았다.</p><h1 id="Sass-Less-Stylus-비교"><a href="#Sass-Less-Stylus-비교" class="headerlink" title="Sass, Less, Stylus 비교"></a>Sass, Less, Stylus 비교</h1><p><code>Sass</code>, <code>Less</code>, <code>Stylus</code>는 가장 대표적인 전처리기이다. 만약 전처리기 도입을 고민한다면 사실상 이 세 개의 전처리기 차이가 크지 않기 때문에 어느 것을 선택해도 문제는 되지 않지만 그래도 선택이 어렵다면 이 섹션을 보고 조금이나마 도움이 되었으면 한다.</p><p><a href="https://trends.google.co.kr/trends/explore?cat=13&date=today%205-y&q=/m/054k6n_,/m/0gjd0jv,Stylus">Trend</a>에서는 검색어를 통한 관심도를 볼 수 있다. 정확하게 CSS 전처리기에 대해 검색을 하지 않았고 포함된 관심도이지만 <code>Sass</code>를 가장 많이 사용하는 것을 볼 수 있다. 그럼 Github의 Start 수와 Fork 수를 확인해 보자.</p><p><img src="/2019/05/12/css-preprocessor/github.png" alt="css-github"></p><p>NPM 기준으로 확인해보자.</p><p><img src="/2019/05/12/css-preprocessor/npmcompare.png" alt="npmcompare"></p><p>수치상으로만 볼 때는 무엇이 높고 낮음은 판가름이 되지만 그게 정확한 척도는 되지 않는다.</p><p>위 세 전처리기 모두 사용해보는 것이 좋을 것이지만 무엇을 사용할지의 판단은 본인의 몫이고 필자로서는 무엇을 써도 무방하다고 생각된다.</p><p>이제 이 세 개의 CSS 전처리기에 대해서 간략하게 알아보도록 하자.</p><h1 id="Sass-vs-Less-vs-Stylus"><a href="#Sass-vs-Less-vs-Stylus" class="headerlink" title="Sass vs Less vs Stylus"></a>Sass vs Less vs Stylus</h1><p>초기에는 JavaScript로 작성된 <code>Less</code>가 가장 선호되었다. <code>node-sass</code>가 나오고 나서부터는 <code>Sass</code>가 선호되고 있다. <code>Stylus</code>는 가장 늦게 나온 전처리기로 최근 들어서 <code>open-project</code>에 많이 사용되고 있다.</p><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p><code>Sass</code>는 전처리기 중 가장 먼저 나온 전처리기이다. 최초에는 <code>Ruby</code> 언어를 기반으로 구동되었지만 <code>Ruby</code> 언어가 지닌 한계로 컴파일이 다소 느렸기 때문에 <code>Less</code>를 더 선호하였다. 하지만 <code>node-sass</code>라는 <code>Node.js</code>기반의 라이브러리가 나오면서 이후 <code>Sass</code>를 많이 사용하고 있다. 최근에는 <code>sass</code> 자체가 NPM에 등록되어있다. 다른 전처리기에 비해 상대적으로 다양한 기능이 제공되고 지속적인 업데이트가 진행되고</p><h3 id="Sass-설치"><a href="#Sass-설치" class="headerlink" title="Sass 설치"></a>Sass 설치</h3><p>npm을 통한 설치 방법이다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g sass<br></code></pre></td></tr></table></figure><h3 id="Sass-컴파일"><a href="#Sass-컴파일" class="headerlink" title="Sass 컴파일"></a>Sass 컴파일</h3><p>기본적인 컴파일은 아래처럼 사용하고 더 자세한 커맨드 라인은 <a href="https://sass-lang.com/documentation/cli">Sass Command-Line Interface</a>를 참고하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sass styls.scss styls.css<br></code></pre></td></tr></table></figure><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p><code>Less</code>는 <code>Twitter의 Bootstrap</code>에서 사용되면서 전파되기 시작했고 Client(브라우저)에서 자바스크립트 Parser를 통해 실행된다. <code>Sass</code>와는 다르게 초창기부터 <code>Node.js</code>기반으로 구동되었고 <code>Sass</code>에 비해 컴파일 속도가 빠른 것이 장점이었으나 <code>Sass</code>가 캐쉬를 적용한 뒤로부터는 큰 차이가 없어졌다.</p><h3 id="Less-설치"><a href="#Less-설치" class="headerlink" title="Less 설치"></a>Less 설치</h3><p>NPM을 통한 설치 방법이다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g less<br></code></pre></td></tr></table></figure><h3 id="Less-컴파일"><a href="#Less-컴파일" class="headerlink" title="Less 컴파일"></a>Less 컴파일</h3><p>기본적인 컴파일은 아래처럼 사용하고 더 자세한 커맨드 라인은 <a href="http://lesscss.org/usage/">Using Less.js</a>를 참고하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lessc style.less style.css<br></code></pre></td></tr></table></figure><h2 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h2><p><code>Stylus</code>는 가증 나중에 나온 전처리기로 <code>Less</code>와 동일하게 <code>Node.js</code>기반으로 구동된다. 가장 늦게 발표된 전처리기이지만 많은 기능이 구현되어있다. 몇 년 전만 해도 다른 전처리기에 비해 완성도가 낮고 여러 잔존 버그가 존재하였지만, 시간이 지남에 따라 많은 부분이 해결되어 최근에는 많은 <code>open-project</code>에서 사용되고 있다.</p><h3 id="Stylus-설치"><a href="#Stylus-설치" class="headerlink" title="Stylus 설치"></a>Stylus 설치</h3><p>NPM을 통한 설치 방법이다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g stylus<br></code></pre></td></tr></table></figure><h3 id="Stylus-컴파일"><a href="#Stylus-컴파일" class="headerlink" title="Stylus 컴파일"></a>Stylus 컴파일</h3><p>기본적인 컴파일은 아래처럼 사용하고 더 자세한 커맨드 라인은 <a href="http://stylus-lang.com/docs/executable.html">Stylus Executable</a>을 참고하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">stylus style.styl style.css<br></code></pre></td></tr></table></figure><hr><p>지금까지 CSS 전처리기(CSS Preprocessor)에 대해서와 <code>Sass</code>, <code>Less</code>, <code>Stylus</code>를 알아보았다. 확실히 CSS 전처리기를 사용하면 많은 도움이 된다. 다만 단점 섹션에서도 말했듯이 실제로 기술을 습득하고 반영해야 하는 사람은 개발자가 아닐 수 있다는 것이다.</p><p>해당 포트스에 각 전처리기에 대한 문법에 대해서 언급하지 않은 이유는 세 전처리기에 대한 문법이 비슷하기 때문에 오히려 어떤 전처리기를 사용할지 결정에 있어서 혼동을 줄 수 있을 것 같아서이다. 위 섹션에서 설치 방법과 컴파일하는 명령어만 보아도 비슷한 것을 알 수 있을 것이다. 각 세 전처리기의 Document는 모두 잘 되어있기 때문에 문법에 대해서는 각 API를 참고하기 바란다.</p><ul><li><a href="https://sass-lang.com/">Sass</a></li><li><a href="http://lesscss.org/#">Less</a></li><li><a href="http://stylus-lang.com/">Stylus</a></li></ul><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a></p></div>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
          <category> css pre-processor </category>
          
          <category> sass </category>
          
          <category> less </category>
          
          <category> stylus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> css pre-processor </tag>
            
            <tag> sass </tag>
            
            <tag> less </tag>
            
            <tag> stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] Vuex 개념부터 실무에서의 사용까지 배우기!!</title>
      <link href="/2019/05/09/vuex-tutorial/"/>
      <url>/2019/05/09/vuex-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/05/09/vuex-tutorial/cover.png" alt="vuex"></p><p>이번 포스팅에서는 Vuex의 개념을 살펴보고 설치부터 실무에서의 사용 방법까지 예제를 통하여 알아보도록 하자. Vuex는 작성 방법에 따라 형태가 조금씩 다르며 <a href="https://vuex.vuejs.org/">공식 API</a> 를 통해서만은 실무에 반영하기가 어렵다.</p><p>당신이 처음 Vuex를 사용한다면 도움이 되기를 바란다.</p><h1 id="Vuex-개념"><a href="#Vuex-개념" class="headerlink" title="Vuex 개념"></a>Vuex 개념</h1><p><code>Vuex</code>는 <strong>Vue.js의 상태관리 라이브러리</strong>로 애플리케이션의 모든 컴포넌트에 대한 중앙 집중식 저장소 역할을 하며 의도적인 방법으로 상태를 변경 및 관리할 수 있다. Vuex는 기존 <strong>Flux의 아키텍처</strong>를 따라가고 있고 React로 본다면 <code>Redux</code>와 비교 대상으로 볼 수 있다. Vue.js에서도 Redux를 사용할 수 있지만 Vue.js는 Vuex와의 호환이 좋을 뿐만 아니라 더 직관적으로 개발할 수 있다.</p><p><a href="https://kdydesign.github.io/posts/vue-component.html">[Vue.JS] Component 개념을 익히고 만들어보자!!</a> 에서 언급하였듯이 컴포넌트는 일반적으로 <code>부모-자식</code>의 관계를 가지고 <code>props</code>와 <code>event</code>를 통해 서로의 데이터를 주고받는다고 하였다. 하지만 Vuex는 말 그대로 <strong>중앙 집중식 저장소</strong> 이기 때문에 <code>props</code>와 <code>event</code>에 얽매이지 않아도 된다. 그렇기 때문에 컴포넌트의 구조가 복잡한 경우에는 <code>props</code>와 <code>event</code>를 통한 데이터 전달보다는 Vuex를 통해 별도의 저장소에서 데이터를 관리하는 것이 올바르다.</p><p>대부분 Vuex의 채택은 필수로 보고 있지만, 규모가 작은 애플리케이션의 경우 <strong>Event Bus</strong>를 사용해도 무방하다. 하지만 Event Bus의 규모가 커지면 관리 포인트가 매우 어려워지므로 Vuex를 사용하는 것을 추천한다.</p><p>Vuex를 이해하고 바로 도입하기에는 비용이 많이 드는 편이다. 또한 <a href="https://kdydesign.github.io/posts/vue-component.html">[Vue.JS] Component 개념을 익히고 만들어보자!!</a> 에서 언급한 <strong>컴포넌트 설계의 중요성보다 더욱 설계가 중요시된다.</strong> 컴포넌트와는 다르게 Vuex는 어느 한 곳에 종속되지 않고 중앙에서 관리 되므로 모든 컴포넌트가 읽기&#x2F;쓰기가 가능하기 때문이다.</p><h1 id="Vuex-구조"><a href="#Vuex-구조" class="headerlink" title="Vuex 구조"></a>Vuex 구조</h1><p>Vuex는 <code>state</code>, <code>mutations</code>, <code>action</code>, <code>getters</code> 4가지 형태로 관리가 되며, 이때 이 관리 포인트는 <strong>store 패턴</strong>을 사용하고 통상 <strong>store</strong>라고 불린다. 이 4가지는 서로간의 간접적으로 영향이 있으며 단방향 데이터 흐름으로 볼수 있다.</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>State는 Vue 컴포넌트에서 data로 볼 수 있다. <strong>원본 소스의 역할을 하며, View와 직접적으로 연결되어있는 Model이다.</strong> 이 state는 직접적인 변경은 불가능하고 mutation을 통해서만 변경이 가능하다. mutation을 통해 state가 변경이 일어나면 반응적으로 View가 업데이트된다.</p><h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h2><p>Mutation은 <strong>state를 변경하는 유일한 방법이고 이벤트와 유사하다.</strong> mutation은 함수로 구현되며 첫 번째 인자는 <code>state</code>를 받을 수 있으며, 두 번째 인자는 <code>payload</code>를 받을 수 있다. 여기서 payload는 여러 필드를 포함할 수 있는 객체형태도 가능하다. 이 mutation은 일반적으로(Helper를 쓰지 않는 경우)는 직접 호출을 할 수 없으며, <strong>commit</strong>을 통해서만 호출할 수 있다.</p><p><em>대부분 실무에서는 mutations에서는 API를 통해 전달받은 데이터의 가공하여 state를 설정하는 데 많이 사용된다.</em></p><p><strong>Mutations</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setData&#x27;</span>, payload)<br></code></pre></td></tr></table></figure><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Action은 mutation과 비슷하지만 mutation과는 달리 <strong>비동기 작업이 가능하다.</strong> 또한 mutation에 대한 <code>commit</code>이 가능하여 action에서도 mutation을 통해 state를 변경할 수 있다. action에서는 첫 번째 인자를 <code>context</code> 인자로 받을 수 있으며 이 context에는 <code>state</code>, <code>commit</code>, <code>dispatch</code>, <code>rootstate</code>와 같은 속성들을 포함한다. 두 번째 인자는 mutation과 동일하게 payload로 받을 수 있다.</p><p>commit을 통해 mutation을 호출했다면 Action은 <code>dispatch</code>를 통해서 호출한다. context의 속성을 보면 dispatch가 있는 것으로 보아 action에서는 서로 다른 action을 호출할 수 있다는 것을 볼 수 있다.</p><p><em>실무에서 actions은 Axios를 통한 API 호출과 그 결과에 대해서 반환(return)을 하거나 mutation으로 commit하여 상태를 변경하는 용도로 사용된다.</em></p><p><strong>Actions</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;setData&#x27;</span>, payload)<br></code></pre></td></tr></table></figure><h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p>Getters는 쉽게 <strong>Vue 컴포넌트에서 Computed로 볼 수 있다.</strong> 말로 풀자면 계산된 속성인데 getter의 결과는 종속성에 따라 캐시 되고 일부 종속성이 변경된 경우에만 다시 재계산된다. 즉, 특정 state에 대해 어떠한 연산을 하고 그 결과를 View에 바인딩할 수 있으며, state의 변경 여부에 따라 getter는 재계산이 되고 View 역시 업데이트를 일으킨다. 이때 state는 원본 데이터로서 변경이 일어나지 않는다.</p><p><em>실무에서도 state의 연산 처리가 필요한 내용에 대해 getter를 사용하지만 getters의 경우 대용량 처리 시에 퍼포먼스와 연관이 되어있으므로 조심해야 한다. 대용량 처리에 관련해서는<br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">[Vue.JS] 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a> 를 참고하자.</em></p><hr><p>여기까지 해서 Vuex에 대한 개념을 알아보았다. Vuex의 주요 핵심은 <strong>중앙 집중식 저장소</strong>이며 이에 따라 <code>state</code>, <code>action</code>, <code>mutations</code>, <code>getters</code>의 개념과 흐름만 파악하면 무리 없이 진행할 수 있을 것이다.</p><h1 id="Vuex-설치"><a href="#Vuex-설치" class="headerlink" title="Vuex 설치"></a>Vuex 설치</h1><p>이제 Vuex를 설치해 보고 <code>state</code>, <code>mutations</code>, <code>actions</code>, <code>getters</code> 4가지의 형태별로 사용하는 방법을 알아보도록 하자.</p><p>이미 테스트용 프로젝트가 준비되어 있다면 <strong>NPM을 통해 바로 설치</strong>를 할 수 있고 아직 준비가 안되었다면 <strong>Vue-CLI 3를 통한 Vuex 설치법</strong>을 보자.</p><h2 id="NPM을-통한-Vuex-설치"><a href="#NPM을-통한-Vuex-설치" class="headerlink" title="NPM을 통한 Vuex 설치"></a>NPM을 통한 Vuex 설치</h2><p>Vuex의 설치는 npm으로 진행하도록 하자. npm에 대해서는 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념 잡기</a>를 참고하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm i vuex --save<br></code></pre></td></tr></table></figure><p><strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br></code></pre></td></tr></table></figure><p>개념을 설명 할 때 action이 비동기 처리가 가능하다고 하였다. Promise를 IE 브라우저에서 사용하기 위해서는 Vuex는 <strong>polyfill 라이브러리</strong>가 필요하기 때문에 IE 브라우저를 사용한다면 <code>es6-promise</code> polyfill을 설치하도록 하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm i es6-promise --save<br></code></pre></td></tr></table></figure><p><strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;es6-promise/auto&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Vue-CLI-3를-통한-Vuex-설치"><a href="#Vue-CLI-3를-통한-Vuex-설치" class="headerlink" title="Vue-CLI 3를 통한 Vuex 설치"></a>Vue-CLI 3를 통한 Vuex 설치</h2><p>Vue에 대한 프로젝트가 이미 설치되어있다면 NPM 설치와 같이 Vuex만 개별로 설치할 수 있지만 우리는 <strong>Vue-CLI를 통해 한 번에 해결</strong>할 수 있다. <code>Vue-CLI 3</code>에 대해서는 <a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">[Vue.JS] Vue-CLI 3 시작하기</a>를 참고하자.</p><p>Vue-CLI가 설치되었다는 가정하에 설명하자면.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">vue create vuex-poject<br></code></pre></td></tr></table></figure><p>CLI를 통해 Vue 프로젝트를 생성할 때 <code>Manually select features</code>를 통해서 Vuex를 설치하자. 설치 후 <code>package.json</code>과 <code>main.js</code>를 확인해 보면 이미 Vuex가 설치와 바인딩 된 것을 확인할 수 있고 <code>store.js</code>가 생성된 것을 확인할 수 있다.</p><p>이제 실행해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm run serve<br></code></pre></td></tr></table></figure><p>기본 페이지가 <a href="http://localhost:8080으로">http://localhost:8080으로</a> 실행이 될 것이다. 세부 내용을 시작하기 전에 간단하게 Vuex를 사용해 보자.</p><h1 id="Vuex-전체적인-Flow-예제"><a href="#Vuex-전체적인-Flow-예제" class="headerlink" title="Vuex 전체적인 Flow 예제"></a>Vuex 전체적인 Flow 예제</h1><p>먼저 App.vue 파일과 store.js 파일을 아래와 같이 수정하자.</p><p><strong>App.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>&#123;&#123;getMsg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onChangedMsg&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">    getMsg () &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">getMsg</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    onChangedMsg () &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;callMutation&#x27;</span>, &#123; <span class="hljs-attr">newMsg</span>: <span class="hljs-string">&#x27;World !!&#x27;</span> &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>store.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    changeMessage (state, newMsg) &#123;<br>      state.<span class="hljs-property">message</span> = newMsg<br>    &#125;<br><br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    callMutation (&#123; state, commit &#125;, &#123; newMsg &#125;) &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;changeMessage&#x27;</span>, newMsg)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    getMsg (state) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;state.message&#125;</span> =&gt; Length : <span class="hljs-subst">$&#123;state.message.length&#125;</span>`</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>결과는 최초 Hello라는 단어와 해당 단어의 길이를 나타낸다. 그리고 버튼을 클릭 시 단어가 바뀌고 바뀐 단어에 대한 길이가 나온다.</p><p>먼저 <code>store.js</code>를 보자. </p><p><strong>state</strong>에는 <code>message</code>라는 상태를 저장할 모델을 생성하고 기본값으로 Hello라는 단어를 지정하였다. 하지만 이 state를 View에 바인딩하진 않았다. 만약 바인딩하였다면 문자의 길이는 나오지 않았을 것이다.</p><p><strong>getters</strong>를 보자. <code>getMsg</code>라는 getter를 생성하고 state와 추가로 단어의 길이를 나타내는 문장을 더해서 반환해주고 있다. 반환된 값은 <code>App.vue</code>에서 <code>getMsg()</code>의 computed로 바인딩 되어있다. 이 코드를 보게 되면 컴포넌트에서 <strong>this.$store.getters.getMsg</strong>를 통해 getter를 바인딩하는 것을 볼 수 있다. 여기서 state의 message가 변경되면 View 역시 업데이트가 된다.</p><p><strong>actions</strong>를 보자. action에는 <code>callMutation()</code>이라는 함수가 정의되어 있고 newMsg라는 payload를 받고 있다. 최초 이 <code>callMutation()</code>은 <code>App.vue</code>에서 Click Event가 수행되고 실행되는 <code>onChangedMsg()</code>에서 <strong>this.$store.dispatch(‘callMutation’, { newMsg: ‘World !!’ })</strong>를 통해 호출하고 있다. actions를 호출하게 되면 <code>callMutation()</code>에서는 받은 payload와 함께 바로 <code>commit</code>을 통해서 mutations의 <code>changeMessage()</code>를 호출하고 있다.</p><p><strong>mutations</strong>에서는 전달받은 payload를 state인 <code>message</code>에 설정하고 있다. 이렇게 message가 설정되면 다시 getter가 이를 감지하고 수행하게 되고 View가 업데이트되는 과정을 거친다.</p><hr><p>Vue와 Vuex의 한 싸이클을 간략하게 예제로 보았다. 대부분의 패턴은 위처럼 사용하며 가장 기본이 되는 방식이다.</p><h1 id="Store의-모듈화"><a href="#Store의-모듈화" class="headerlink" title="Store의 모듈화"></a>Store의 모듈화</h1><p>지금의 예제는 <code>store.js</code>라는 store를 하나만 사용하고 있지만 실상 <strong>실무에서는 단 하나의 store를 사용할 수는 없다.</strong> 기능별 또는 페이지별로 store를 분리해야 하고 관리해야 한다. 이렇게 관리하기 위해서는 store를 모듈별로 분리를 해야 한다.</p><p>모듈별로 분리하는 형태는 두 가지로 분리된다.</p><div class="alert info no-icon"><ul><li>state, mutations, actions, getters를 script 파일 단위로 분리</li><li>기능&#x2F;페이지별로 store를 분리하고, 하나의 store에는 state, mutations, actions, getters를 포함</li></ul></div><p>어느 형태로 분리할지는 프로젝트의 규모와 구조에 따라 다르기 때문에 본인이 판단하길 바란다. 여기서는 store 별로 분리하는 방법으로 설명을 하겠다.</p><p>먼저 현재 샘플 프로젝트의 src 경로에 <code>store</code>라는 폴더를 생성하자. 그리고 그 하위에 <code>book</code> 폴더를 생성하자. 그다음 <code>user</code> 폴더 하위에 <code>book.js</code>와 <code>bookList.js</code>를 생성하자.</p><p>여기까지 진행한다면 store의 모듈 구조를 생성한 것이다. <strong>폴더 트리의 path가 이후 store 모듈을 불러올 경로가 된다.</strong> </p><p>이제 기존에 있던 store.js는 삭제를 하고 store 폴더 안에 <code>index.js</code>를 생성하자.</p><p><strong>store&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">BookStore</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./book&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">modules</span>: &#123;<br>        <span class="hljs-attr">book</span>: <span class="hljs-title class_">BookStore</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>위 코드는 기존에 존재하던 store.js에서 하는 역할을 한다. 다른 게 있다면 <code>book</code>이라는 모듈을 불러와 store에 바인딩하고 있다는 것이다.</p><p>이제 실제로 store가 될 파일 수정하자. <code>book.js</code>를 열어 아래와 같이 정의하자.</p><p><strong>store&#x2F;book&#x2F;book.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// state</span><br><span class="hljs-keyword">const</span> state = &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// mutations</span><br><span class="hljs-keyword">const</span> mutations = &#123;<br>     changeMessage (state, newMsg) &#123;<br>      state.<span class="hljs-property">message</span> = newMsg<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// actions</span><br><span class="hljs-keyword">const</span> actions = &#123;<br>    callMutation (&#123; state, commit &#125;, &#123; newMsg &#125;) &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;changeMessage&#x27;</span>, newMsg)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// getters</span><br><span class="hljs-keyword">const</span> getters = &#123;<br>    getMsg (state) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;state.message&#125;</span> =&gt; Length : <span class="hljs-subst">$&#123;state.message.length&#125;</span>`</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  state,<br>  mutations,<br>  actions,<br>  getters<br>&#125;<br></code></pre></td></tr></table></figure><p>코드는 초기에 만들었던 <code>store.js</code>에 있는 내용이다. 이렇게 정의를 하면 <code>book</code>이라는 하나의 모듈이 생성되었다.</p><h1 id="Vuex-Binding-Helper"><a href="#Vuex-Binding-Helper" class="headerlink" title="Vuex Binding Helper"></a>Vuex Binding Helper</h1><p>위처럼 모듈을 생성하고 컴포넌트에 바인딩을 하기 위해서는 아래와 같이 사용해야 한다.</p><p><strong>state binding</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">book</span>.<span class="hljs-property">message</span><br></code></pre></td></tr></table></figure><p>모듈을 생성하고 Vuex.Store에 바인딩할 때 우리는 <code>book</code>이라는 명칭을 주었기 때문에 <code>book</code>에 있는 state에 접근하기 위해서는 그에 맞는 속성값을 명시해줘야 한다. 하지만 만약 store의 구조가 깊고 복잡한 구조라면 state 하나를 바인딩하기 위해서는 길고도 긴 값을 코딩해야한다. 이런 이유로 인해서 <strong>Vuex에는 Helper라는 Util이 존재한다.</strong></p><p>Helper는 <code>state</code>, <code>mutations</code>, <code>actions</code>, <code>getters</code> 별로 각각 <code>mapState</code>, <code>mapActions</code>, <code>mapMutations</code>, <code>mapGetters</code>가 존재하고 아래처럼 바인딩할 수 있다.</p><p><strong>Sample.vue</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; mapState, mapActions, mapMutations, mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Sample&#x27;</span>,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    ...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">&#x27;book&#x27;</span>, &#123;<br>        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">message</span>     <span class="hljs-comment">// -&gt; this.message</span><br>    &#125;),<br>    ...<span class="hljs-title function_">mapGetters</span>(<span class="hljs-string">&#x27;book&#x27;</span>, [<br>       <span class="hljs-string">&#x27;getMsg&#x27;</span>       <span class="hljs-comment">// -&gt; this.getMsg</span><br>    ])<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    ...<span class="hljs-title function_">mapMutations</span>(<span class="hljs-string">&#x27;book&#x27;</span>, [<br>        <span class="hljs-string">&#x27;changeMessage&#x27;</span>     <span class="hljs-comment">// -&gt; this.changeMessage()</span><br>    ]),<br>    ...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&#x27;book&#x27;</span>, [<br>        <span class="hljs-string">&#x27;callMutation&#x27;</span>      <span class="hljs-comment">// -&gt; this.callMutation()</span><br>    ])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Helper를 사용하게 되면 코드의 가독성이 훨씬 좋아진다. 하지만 우리가 최종적으로 배울 것은 이러한 방법이 아니다.</p><h2 id="Vuex-createNamespacedHelpers"><a href="#Vuex-createNamespacedHelpers" class="headerlink" title="Vuex createNamespacedHelpers"></a>Vuex createNamespacedHelpers</h2><p>충분히 위에서 배운 <code>mapHelper</code>를 통해 개발이 가능하지만 좀 더 편리하고 효율적으로 하기 위해서는 <strong>createNamespacedHelpers</strong>를 사용하는 것이 좋다. 어떻게 보면 결과적으로나 사용되는 Util은 동일하다.</p><p>아래 코드를 보자.</p><p><strong>Sample.vue</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">const</span> bookHelper = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;book&#x27;</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Sample&#x27;</span>,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    ...bookHelper.<span class="hljs-title function_">mapState</span>(&#123;<br>        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">message</span>     <span class="hljs-comment">// -&gt; this.message</span><br>    &#125;),<br>    ...bookHelper.<span class="hljs-title function_">mapGetters</span>([<br>       <span class="hljs-string">&#x27;getMsg&#x27;</span>       <span class="hljs-comment">// -&gt; this.getMsg</span><br>    ])<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    ...bookHelper.<span class="hljs-title function_">mapMutations</span>([<br>        <span class="hljs-string">&#x27;changeMessage&#x27;</span>     <span class="hljs-comment">// -&gt; this.changeMessage()</span><br>    ]),<br>    ...bookHelper.<span class="hljs-title function_">mapActions</span>([<br>        <span class="hljs-string">&#x27;callMutation&#x27;</span>      <span class="hljs-comment">// -&gt; this.callMutation()</span><br>    ])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>처음에 설명한 Helper와 다른 것은 <code>createNamespacedHelpers</code>를 통해서 모듈의 경로를 미리 지정했다는 것이다. 코드의 차이는 별것이 없겠지만 실제로 하나의 컴포넌트에 여러 개의 모듈을 바인딩하면 <code>createNamespacedHelpers</code>를 사용하는 것이 효율적으로 볼 수 있다.</p><p><strong>Sample.vue</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">const</span> <br>    bookHelper = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;book&#x27;</span>),<br>    bookListHelper = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;bookList&#x27;</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Sample&#x27;</span>,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    ...bookHelper.<span class="hljs-title function_">mapState</span>(&#123;<br>        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">message</span>     <span class="hljs-comment">// -&gt; this.message</span><br>    &#125;),<br>    ...bookHelper.<span class="hljs-title function_">mapGetters</span>([<br>       <span class="hljs-string">&#x27;getMsg&#x27;</span>       <span class="hljs-comment">// -&gt; this.getMsg</span><br>    ]),<br>    ...bookListHelper.<span class="hljs-title function_">mapState</span>(&#123;<br>        <span class="hljs-attr">messageList</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">messageList</span>     <span class="hljs-comment">// -&gt; this.messageList</span><br>    &#125;),<br>    ...bookListHelper.<span class="hljs-title function_">mapGetters</span>([<br>       <span class="hljs-string">&#x27;getMsgList&#x27;</span>       <span class="hljs-comment">// -&gt; this.getMsgList</span><br>    ])<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    ...bookHelper.<span class="hljs-title function_">mapMutations</span>([<br>        <span class="hljs-string">&#x27;changeMessage&#x27;</span>     <span class="hljs-comment">// -&gt; this.changeMessage()</span><br>    ]),<br>    ...bookHelper.<span class="hljs-title function_">mapActions</span>([<br>        <span class="hljs-string">&#x27;callMutation&#x27;</span>      <span class="hljs-comment">// -&gt; this.callMutation()</span><br>    ]),<br>    ...bookListHelper.<span class="hljs-title function_">mapMutations</span>([<br>        <span class="hljs-string">&#x27;changeMessageList&#x27;</span>     <span class="hljs-comment">// -&gt; this.changeMessageList()</span><br>    ]),<br>    ...bookListHelper.<span class="hljs-title function_">mapActions</span>([<br>        <span class="hljs-string">&#x27;callMutationList&#x27;</span>      <span class="hljs-comment">// -&gt; this.callMutationList()</span><br>    ]),<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>지금까지 언급한 방법이 최고의 방법은 아니다. store를 바인딩하는 방법은 개발자의 스타일이 많이 반영된다. 여러 가지의 형태로 개발을 해보고 본인의 스타일에 맞는 방법을 찾는 게 좋다. Vuex Sotre의 바인딩의 다양한 방법은 <a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">[Vue.JS] Vuex Store를 바인딩하는 4가지 방법!!</a>을 참고하자.</p><hr><p>여기까지 해서 우리는 Vuex의 개념과 설치 그리고 실무에서 사용하는 방법을 알아보았다.<br>Vuex의 Store 패턴은 한번 잡아 놓으면 변경할 일이 별로 없기 때문에 처음에 진입장벽만 넘어선다면 수월한 부분이 많다. 다만 모듈의 구조화, 그리고 store의 설계가 잘못된다면 오히려 Vuex는 독이 될 수 있다. 이 부분만 조심하면 컴포넌트 간의 데이터 흐름은 확실하게 제어할 수 있을 것이다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vue-store-state/">Vuex Store의 state를 효율적으로 초기화하기</a><br><a href="https://kdydesign.github.io/2019/04/27/vue-component/">Vue.JS Component 개념을 익히고 만들어보자!!</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2021/01/14/vue-eventbus-vs-vuex/">Vuex VS Event Bus</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> vuex </category>
          
          <category> vuex tutorial </category>
          
          <category> vue.js tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] Component 개념을 익히고 만들어보자!!</title>
      <link href="/2019/04/27/vue-component/"/>
      <url>/2019/04/27/vue-component/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/04/27/vue-component/cover.png" alt="vue-component"></p><p>이번 포스트에서는 Vue.js의 기본 개념을 익혔다는 가정하에 Vue.js의 강력한 기능 중인 하나인 <code>컴포넌트(Component)</code>에 대해서 알아보자.</p><p>Vue.js의 컴포넌트 개념은 Vue.js Framework에서도 중요한 부분을 차지하고 어떻게 Vue.js 컴포넌트를 생성하느냐에 따라 Vue.js의 개발속도와 코드의 가독성, 그리고 효율성이 현저히 차이가 난다. 우리는 이번 포스트에서 Vue.js의 컴포넌트 생성 방법에 대해 알아보고 실제로 Vue.js의 컴포넌트를 직접 만들어보기로 하자. 이번 포스트는 공식 문서에 나와 있는 컴포넌트 생성 방법의 여러 가지 방법 중에 어떤 것이 실무에서 효율적인지를 파악하는 Vue.js Tutorial이다.</p><p>먼저 포스팅을 하기 전에 앞 써서 기본 <code>Vue.js</code>에 대한 개념과 추세를 모르거나 알고 싶다면 <a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a> 포스트를 먼저 확인하자.</p><p>컴포넌트에 대해서 포스팅할 내용은 많지는 않다. 개념부터 사용법까지 본다면 분량은 얼마 되지는 않지만 가장 중요하기 때문에 깊게 봐야 할 필요성이 있다. 실무에서 특정 프로젝트에 Vue.js를 도입을 한다면 더욱이 깊게 봐야 한다. Vue.js 컴포넌트는 API 문서대로 <strong>전역 등록</strong>을 통한 컴포넌트 생성과 <strong>지역 등록</strong>을 통한 컴포넌트 등록이 있고 이 두 형태를 가지고 문법대로 생성하면 끝이다. 하지만 중요한 것은 컴포넌트의 생성 범위이다. 어떤 컴포넌트를 <code>전역/지역</code>으로 등록을 할지, 그리고 어떤 특정 부분을 컴포넌트로 만들어야 할지가 중요하다. </p><p>즉, 쉽게 말한다면 <strong><code>설계</code></strong> 가 가장 중요하다고 볼 수 있다.</p><p>Vue.js 컴포넌트를 배우고 만들기에 앞서 가장 중요한 컴포넌트의 설계를 먼저 보자.</p><h1 id="Vue-js-Component-설계의-중요성"><a href="#Vue-js-Component-설계의-중요성" class="headerlink" title="Vue.js Component 설계의 중요성"></a>Vue.js Component 설계의 중요성</h1><p>위에서 언급했듯이 <strong>컴포넌트를 생성할 때에는 설계가 가장 중요</strong>하다. 컴포넌트를 만드는 방법이야 <a href="https://kr.vuejs.org/v2/guide/components.html">Vue.js 공식</a> API를 보고 문법을 익혀 만들면 그만이다. 하지만 컴포넌트를 어느 곳에 사용하고 어느 부분이 컴포넌트 화 해야할지에 대해 정확한 설계가 없다면 이 후 전반적으로 문제를 야기한다. 물론 Application을 개발 할 때 모든 항목들을 컴포넌트 단위로 잘게 쪼개도 Application 성능에 크게 영향을 주지는 않지만 규모가 크거나 또는 점점 규모가 커지는(고도화) 프로젝트에서는 해당 프로젝트의 유지관리와 개발 진행 단계에 영향을 준다.</p><p>명확한 설계를 무시하고 Vue.js 컴포넌트를 생성했을 때 아래와 같은 문제점들이 있다. </p><div class="alert danger no-icon"><ol><li>전반적인 코드의 가독성과 유지관리 효율성 저하</li><li>컴포넌트 구조의 복잡성 증가</li><li>독립적인 컴포넌트로의 변이</li></ol></div><h2 id="1-전반적인-코드의-가독성과-유지관리-효율성-저하"><a href="#1-전반적인-코드의-가독성과-유지관리-효율성-저하" class="headerlink" title="1. 전반적인 코드의 가독성과 유지관리 효율성 저하"></a>1. 전반적인 코드의 가독성과 유지관리 효율성 저하</h2><p>무분별한 컴포넌트의 생성은 코드의 가독성과 앞으로 있을 유지관리에 대한 효율성을 현저히 저하시킨다. 대부분 특정 부분을 컴포넌트화를 한다고 했을 때 굳이 컴포넌트를 안 해도 되는 부분까지 나눠서 컴포넌트화 하는 경우가 많다.</p><p>아주 간단하게 로그인 페이지를 만든다고 했을 때 ID, Password 입력 폼을 각각의 컴포넌트로 만들었다고 가정하자. 이렇게 되면 메인이 되는 App은 매우 심플해지겠지만 유지관리 시에 우리는 ID, Password 폼을 각각 찾아다니며 분석하고 수정해야 한다.</p><p><code>로그인 페이지 하나 만드는데 무슨 컴포넌트를 쓰고 가독성과 복잡성을 논하는가</code> 라고 생각하는가? 그렇다면 이미 설계의 중요성을 알고 있는 것이다. 하지만 당신은 로그인 페이지가 아니라 수십 개의 페이지가 존재하는 Application을 구현할 때 이미 알고 있고 느끼는 부분을 망각하고 개발하게 될 수 있다. Application의 전반적인 내용을 알고 있다 하더라도 설계를 무시하고 한다면 당연시하게 되는 일이다. 그만큼 특정 부분을 컴포넌트로 나누고 생성한다는 것은 어려운 일이다.</p><p>그렇다면 어떻게 해야 가독성이 높은 컴포넌트와 효율성을 올릴 수 있을까?<br>먼저 <strong>컴포넌트화 해야 하는 부분을 명확하게 나눠야 한다.</strong> A라는 부분이 N개의 페이지에서 사용하는 공통적인 항목이라면 컴포넌트로 분리해야하는 것이 바람직하다. 그리고 <strong>컴포넌트화 해야 하는 덩어리(chunk)를 굳이 세분화해서 나눌 필요는 없다.</strong> 우리는 컴포넌트를 작성할 때 과감하게 큰 <code>덩어리(chunk)</code> 단위로 나눌 필요도 있다.</p><h2 id="2-컴포넌트-구조의-복잡성-증가"><a href="#2-컴포넌트-구조의-복잡성-증가" class="headerlink" title="2. 컴포넌트 구조의 복잡성 증가"></a>2. 컴포넌트 구조의 복잡성 증가</h2><p>뒤에서도 배우겠지만 대부분 컴포넌트의 작성은 <code>Template</code>와 <code>Script</code> 그리고 <code>Style Sheet</code>를 하나의 파일에 작성하는 <code>단일 파일 컴포넌트(Single File Component)</code>로 작성하게 된다. 이런 컴포넌트에서 <code>props</code>, <code>watch</code>, <code>methods</code> 등의 속성이 무수히 많고 정확한 설계 없이 동작만을 목적으로 하고 작성한다면 이미 이 컴포넌트 복잡한 구조를 가진 컴포넌트이다. 뿐만 아니라 부모-자식의 참조 역시 어려워지게 된다.</p><p>가장 중요한 <code>props</code>와 <code>watch</code>에 대한 이유를 확인해보자.</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><code>props</code>가 많다는 것은 이미 부모 컴포넌트(Parent Component)에서 많은 속성을 전달하고 있다는 것이다. 이렇게 된다면 이미 이 컴포넌트는 특정한 부모 컴포넌트에 종속된 것이나 다름없는 것이다. 물론 다른 페이지 또는 컴포넌트에서 해당 컴포넌트를 가져가 사용할 수 있겠지만, 알겠는가? 여러 페이지에 바인딩 된 컴포넌트에서 실제로 전달된 <code>props</code>가 무엇이고 유지 보수 시에 무엇이 필요한지 아닌지를 말이다.<br>그뿐만 아니라 <code>props</code>는 해당 컴포넌트에서 직접적으로 변경이 불가능하기 때문에 이미 넘어온 <code>props</code>를 변경하기 위해서는 바인딩 되어 있는 <code>props</code>를 <code>data</code>에 재 바인딩해야 하는 경우가 많다. 이렇게 되면 자연적으로 <code>watch</code>와 같은 감시자와 상위 컴포넌트로 이벤트를 전달하는 <code>$emit</code>이 많아지게 된다.</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code>가 많다는 것은 이미 해당 컴포넌트에서 반강제적으로 반응 적인 모델이 필요하다는 경우이다. 이런 <code>watch</code>가 많아지게 되면 해당 컴포넌트를 다른 곳에 반인딩하였을 때 의도치 않은 동작을 야기할 수 있다. 특히 이런 경우엔 유지보수가 매우 어렵다. 이미 이 <code>watch</code>에 종속된 기능이 거미줄처럼 엉켜있기 때문이다. 특히나 Vue.js의 반응 적 모델은 Application의 성능에 직접적인 연관을 주기도 하기 때문에 <strong>watch를 최소화</strong>하는 것이 좋다.<br>Vue.js의 성능 처리에 관련해서 <a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a> 를 참고하자.</p><p>위와 같은 컴포넌트의 복잡성 증가를 해결하기 위해서는 </p><div class="alert info no-icon"><ul><li>props는 해당 컴포넌트에서 절대적으로 필요한 요소로 생성하고</li><li>watch의 사용을 최소화하고</li><li>공통적인 methods와 같은 Script들은 javaScript 파일로 별로 분리하는 것이 좋으며</li><li>컴포넌트 간의 깊은 바인딩(deep)은 자제해야 한다.</li></ul></div><h2 id="3-독립적인-컴포넌트로의-변이"><a href="#3-독립적인-컴포넌트로의-변이" class="headerlink" title="3. 독립적인 컴포넌트로의 변이"></a>3. 독립적인 컴포넌트로의 변이</h2><p>이렇게 무분별하게 컴포넌트를 생성하고 하나의 컴포넌트가 복잡한 구조를 가진 컴포넌트 생성하다 보면 결국 해당 컴포넌트는 어느 순간부터 특정 페이지 또는 컴포넌트에 종속되어 버리고 단 하나의 독립적인 컴포넌트가 생성된다. 이렇게 독립적인 컴포넌트가 작성되면 Vue.js 컴포넌트의 목적에 어긋나고 특성을 활용하지 못한 방치되는 컴포넌트가 되고 만다.</p><hr><p>컴포넌트를 개발하기 전 컴포넌트에서의 설계가 왜 중요한지 알아보았다.<br>개발에 있어서 설계가 중요하다는 것은 누구나 아는 것이다. 하지만 설계가 Application에 대한 전반적인 설계라고 한다면 나는 <strong>컴포넌트 간의 설계만 별도로 작성하는 것을 추천</strong>한다. 시간이 난다면 컴포넌트 간의 다이어그램도 한번 그려보기 바란다. 많은 도움이 될 것이다. 이 밖에도 설계가 부족할 경우 야기되는 문제들이 많지만 모두 나열할 수는 없어도 분명한 것은 단 하나의 판단 미스로 나비효과를 일으킬 수 있다는 것을 명심하자.</p><p>이제 본격적으로 <code>Vue.js Component</code> 대해 알아보자.</p><h1 id="Vue-js-Component"><a href="#Vue-js-Component" class="headerlink" title="Vue.js Component"></a>Vue.js Component</h1><p><code>Vue.js Component</code>은 HTML Element를 확장하고 재사용 가능한 형태로 구현하는 것을 말한다. Vue.js에서 사용된 모든 컴포넌트는 하나하나가 Vue.js의 인스턴스이기도 하다. 컴포넌트의 생성 과정은 단순히 <strong>등록 -&gt; 사용</strong> 패턴으로만 이루어진다.</p><h2 id="테스트-프로젝트-생성"><a href="#테스트-프로젝트-생성" class="headerlink" title="테스트 프로젝트 생성"></a>테스트 프로젝트 생성</h2><p>먼저 테스트할 프로젝트를 생성하자.</p><p>Vue 프로젝트 생성은 <code>Vue-CLI 3</code>를 이용하여 생성할 것이다. <code>Vue-CLI 3</code>에 대해서 <a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a>에서 배워볼 수 있다. <code>Vue-CLI 3</code>를 배웠다는 가정하에 진행하겠다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">vue create vue-component<br><span class="hljs-built_in">cd</span> vue-component<br></code></pre></td></tr></table></figure><p>프로젝트가 생성되었으면 기본으로 생성되는 코드들을 정리하자.<br><code>HelloWorld.vue</code> 파일은 삭제하고 <code>App.vue</code>는 아래와 같이 초기 상태로 돌려놓자.</p><p><strong>App.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;&#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="컴포넌트의-등록과-사용"><a href="#컴포넌트의-등록과-사용" class="headerlink" title="컴포넌트의 등록과 사용"></a>컴포넌트의 등록과 사용</h2><p>컴포넌트의 등록에는 <code>전역등록(Global Registration)</code>과 <code>지역등록(Local Registration)</code>으로 나눌 수 있다.</p><h3 id="전역등록-Global-Registration"><a href="#전역등록-Global-Registration" class="headerlink" title="전역등록 (Global Registration)"></a>전역등록 (Global Registration)</h3><p>컴포넌트 전역등록은 프로그래밍에서 전역 변수와 같은 의미이다. 인스턴스 생성 후 어느 페이지 또는 컴포넌트에서 사용할 수 있게 Global 하게 등록할 수 있다.</p><p>테스트로 생성한 프로젝트에서 <code>component</code> 경로에 <code>global-component.vue</code> 파일을 만들고 생성하자.</p><p><strong>global-component.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showTitle&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;global-component&#x27;</span>,</span><br><span class="language-javascript">    data () &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">title</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      showTitle () &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;Global Component!!&#x27;</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span></span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span></span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>이렇게 전역 등록할 컴포넌트를 만들었다. 이제 생성한 컴포넌트를 전역적으로 등록하자. <code>main.js</code>를 열어 아래와 같이 작성하자.</p><p><strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">GlobalComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/global-component&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-title class_">GlobalComponent</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">GlobalComponent</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>Vue.component()</code>를 통해서 우리는 앞에서 생성한 컴포넌트를 Vue 인스턴스에 바인딩시켰다. 이로써 이제 우리는 템플릿에서 <strong>Custom Element</strong>를 사용할 수 있게 되었다.</p><p><code>App.vue</code>에 직접 삽입하고 <a href="http://localhost:8080/%EB%A5%BC">http://localhost:8080/를</a> 확인해보자.</p><p><strong>App.vue</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;global-component&gt;&lt;/global-component&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    name: &#x27;app&#x27;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="지역등록-Local-Registration"><a href="#지역등록-Local-Registration" class="headerlink" title="지역등록 (Local Registration)"></a>지역등록 (Local Registration)</h3><p>사실상 컴포넌트 등록에 있어서 <code>전역등록</code> 보다는 <code>지역등록</code>을 가장 많이 쓰고 보편적으로 사용한다. 웹팩같은 빌드 시스템을 사용하면 <code>전역등록</code> 된 사용되지 않는 모든 컴포넌트가 빌드에 포함되기 때문이다.</p><p>component 경로에 <code>local-component.vue</code> 파일을 생성하자.</p><p><strong>local-component.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showTitle&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;local-component&#x27;</span>,</span><br><span class="language-javascript">    data () &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">title</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      showTitle () &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;Local Component!!&#x27;</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span></span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span></span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>전역등록</code>과는 다르게 생성된 컴포넌트는 사용될 곳에 바로 삽입하여 사용하면 된다. <code>App.vue</code>를 아래와 같이 수정 후 삽입하고 <a href="http://localhost:8080/%EB%A5%BC">http://localhost:8080/를</a> 확인해보자.</p><p><strong>App.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">global-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">global-component</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">local-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">local-component</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">LocalComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/local-component&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">LocalComponent</span> &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>여기까지 해서 컴포넌트의 등록 방법과 등록 유형별로 등록된 컴포넌트를 사용하는 방법을 배워봤다. 간단한 예제였지만 사실 여기에는 <code>컴포넌트의 모듈 시스템</code>까지 배운 것이다. 모듈 단위의 <code>단일 파일 컴포넌트 (Single File Component)</code>를 작성하고 모듈 형태로 삽입까지 했기 때문이다.</p><h1 id="Component의-기본-작성"><a href="#Component의-기본-작성" class="headerlink" title="Component의 기본 작성"></a>Component의 기본 작성</h1><p>Vue.js 컴포넌트를 생성할 때에 정해진 틀은 없다. 하지만 통상 컴포넌트를 생성하고 사용할 때는 <code>부모-자식</code> 관계의 구조로 이루어진다. 컴포넌트의 집합인 컴포넌트를 만들어도 <code>부모-자식</code> 관계가 된다. 이러한 관계일 경우 부모와 자식 컴포넌트 간 데이터를 전달해야 하는 경우가 있는데 부모에서 자식으로 는 <code>props</code>를 사용하고, 반대로 자식에서 부모로 전달할 때는 <code>events($emit)</code>를 사용한다.</p><p>아래 예제를 보자. </p><p><strong>parent-component.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">:parent-message</span>=<span class="hljs-string">&quot;msg&quot;</span></span><br><span class="hljs-tag">                     @<span class="hljs-attr">print</span>=<span class="hljs-string">&quot;val =&gt; printMessage(val)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/child-component&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent-component&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">ChildComponent</span> &#125;,</span><br><span class="language-javascript">    data () &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;안녕하세요.&#x27;</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      printMessage (val) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>child-component.vue</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendEvent()&quot;</span>&gt;</span>Print<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;child-component&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">parentMessage</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">default</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      sendEvent () &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;print&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentMessage</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>parent-component</code>에서 <code>child-component</code>를 바인딩하고 <code>parent-message</code>라는 속성을 <code>v-bind (:)</code>를 통해 전달한다. 이 관계가 부모에서 자식으로 데이터를 보낼 경우이다. 그리고 <code>v-on (@)</code>을 통해 <code>child-component</code>에서 전달되는 <code>print</code>라는 이벤트를 수신하고 있다.</p><p>이제 <code>child-component</code>를 보자. 여기서는 <code>props</code>인 <code>parentMessage</code> 통해 이미 부모에서 전달된 값을 받고 있으며, <code>$emit</code>을 통해 부모에게 다시 이벤트를 전달하고 있다. Vue.js 컴포넌트에서는 이러한 관계가 구성이 되어야 하고 만약 <code>parent-component</code>에 <code>props</code>라는 속성이 있고 받는 값이 있다면 <code>parent-component</code> 역시 자식 컴포넌트가 되게 된다.</p><p>이러한 구조에서 조심해야 할 사항은 바로 <code>props</code>인데 Vue.js 전체적으로 본다면 양방향 바인딩이지만 이 <code>props</code>는 단방향 바인딩을 형성한다. 상위 속성 즉 <code>parent-component</code>에서 보내는 <code>message</code>가 업데이트되면 하위로 흐르는 <code>props</code> 역시 업데이트가 되지만 반대로 <code>props</code>인 <code>parentMessage</code>를 변경한다고 상위 속성이 업데이트되지는 않는다. 오히려 <code>props</code>는 변경하지 않고 <strong>원시 데이터</strong>로 사용하는 것을 추천하며 만약 변경 시 Vue.js의 경고를 보게 될 것이다.</p><hr><p>여기까지 해서 Vue.js에서 가장 핵심적인 개념인 컴포넌트를 알아보고 생성해 보았다. 위에서 언급했듯이 컴포넌트는 <code>부모-자식</code> 관계를 가지고 부모가 자식이 될 수도 있다. 이러한 구조로 인해 최초에 말했던 설계가 가장 중요하다는 것이다. 아무리 컴포넌트의 개념을 이해하고 적합한 컴포넌트를 생성한다 하더라도 복잡성이 높아지면 결과적으로 효율적이지 않은 컴포넌트가 생성된다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방ㅑ법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2019/04/10/vue-store-state/">Vuex Store의 state를 효율적으로 초기화하기</a><br><a href="https://kdydesign.github.io/2020/11/13/vuejs-provide-inject/">Vue Component provide&#x2F;inject 이해하기</a><br><a href="https://kdydesign.github.io/2021/01/14/vue-eventbus-vs-vuex/">Vuex VS Event Bus</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> framework </category>
          
          <category> vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> vue.js </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] Vue-CLI 3 시작하기</title>
      <link href="/2019/04/22/vue-cli3-tutorial/"/>
      <url>/2019/04/22/vue-cli3-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/04/22/vue-cli3-tutorial/cover.png" alt="cover"></p><p>Vue CLI 3는 Vue.js 개발을 위한 시스템으로 Vue.js Core에서 공식으로 제공하는 CLI이다. Vue CLI는 애플리케이션 개발에 집중할 수 있도록 프로젝트의 구성을 도와주는 역할을 하며, Vue 생태계에서 표준 툴 기준을 목표로 하고 있다. 이번 포스트에서는 Vue CLI의 개념부터 설치 그리고 Vue-CLI의 사용 방법까지 알아보도록 하자.</p><p>Vue CLI의 사용은 선택사항이다. Vue 애플리케이션을 개발하기 전에 Vue CLI를 통해 프로젝트를 구성하고 구축하지 않는다 하더라도 애플리케이션에 영향을 주지는 않는다. 그저 Vue CLI는 앞에서 말했듯이 툴의 역할을 하고 스캐폴딩에 도움을 주는 역할만 한다.<br>Vue CLI를 사용하지 않아도 무방하지만 Vue.js와 관련된 오픈 소스들은 대부분 Vue CLI를 통해 구성이 가능하도록 구현되어 있고 굳이 Git으로 clone하지 않아도 Vue CLI를 통해 더욱더 손쉽게 설치가 가능하기 때문에 Vue CLI의 사용을 추천하는 바이다.</p><p>그럼 이제 Vue CLI에 대해서 알아보자. 해당 포스트에서는 Vue CLI 3.x에 관해서 설명을 하며 Vue CLI 2.x에 대한 내용은 <a href="https://github.com/vuejs/vue-cli/tree/v2#vue-cli--">Vue CLI 2</a>를 참고하자.</p><h1 id="Vue-CLI-3"><a href="#Vue-CLI-3" class="headerlink" title="Vue-CLI 3"></a>Vue-CLI 3</h1><p>Vue CLI는 애플리케이션에 필요한 요소들을 대화형 커맨드로 쉽게 설치하도록 도와준다. 현재 Vue CLI는 3.x까지 릴리즈된 상태이며, Vue CLI의 시스템은 3가지 요소로 구분할 수 있다.</p><h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><p>CLI(@vue&#x2F;cli)는 전역적으로 설치된 npm 패키지이며, Vue.js 프로젝트를 생성하는 <code>vue create</code>, UI를 통해 프로젝트를 관리할 수 있는 <code>vue ui</code> 등 터미널에서 <code>vue</code>를 사용한 명령을 제공한다.</p><h2 id="CLI-Service"><a href="#CLI-Service" class="headerlink" title="CLI Service"></a>CLI Service</h2><p>CLI Service는 <code>webpack</code>, <code>webpack-dev-server</code> 위에 구축이 되며 CLI PlugIn을 실행하는 핵심 서비스와 webpack에 대한 설정을 포함하고 있다. 즉, webpack을 통해 애플리케이션의 개발 서버 실행, 빌드 등을 처리한다.</p><h2 id="CLI-PlugIn"><a href="#CLI-PlugIn" class="headerlink" title="CLI PlugIn"></a>CLI PlugIn</h2><p>CLI PlugIn은 Babel&#x2F;TypeScript, ESLint, e2e Test, 단위 테스트와 같은 선택적으로 설치가 필요한 PlugIn을 말하며, 프로젝트 생성 과정에서 포함하거나 이후에 포함 시킬 수 있다.</p><h1 id="Vue-CLI-3-설치"><a href="#Vue-CLI-3-설치" class="headerlink" title="Vue-CLI 3 설치"></a>Vue-CLI 3 설치</h1><p>이제 Vue CLI를 설치해 보자. 기본적으로 Vue CLI를 설치하기 위해서는 8.9 버전 이상의 Node.js가 필요하다. Node.js 설치와 설명은 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념 잡기</a>를 참고하자.</p><p>Node.js를 설치하였다면 Vue-CLI를 설치하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm i -g @vue/cli<br>vue --version<br></code></pre></td></tr></table></figure><p>Vue CLI를 설치 후 버전을 확인해 보면 3.x이 설치된 것을 확인할 수 있다. 그리고 하나 더 설치하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm i -g @vue/cli-init<br></code></pre></td></tr></table></figure><p><code>@vue/cli-init</code>은 2.x Template을 가져오기 위한 <code>vue init</code>기능을 제공한다.<br>예를 들면.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">vue init webpack my-project<br></code></pre></td></tr></table></figure><p>위와 같이 <a href="https://github.com/vuejs-templates/webpack">vue-webpack-boilerplate</a>를 구성할 수 있다.</p><h1 id="Vue-CLI-3를-통한-프로젝트-생성"><a href="#Vue-CLI-3를-통한-프로젝트-생성" class="headerlink" title="Vue-CLI 3를 통한 프로젝트 생성"></a>Vue-CLI 3를 통한 프로젝트 생성</h1><p>대부분 프로젝트를 시작할 때 또는 프로토타입 프로젝트를 만들 때 잘되어있는 Bolierplate를 가져다가 쓸 것이다. 그럴 때는 위에 설명했듯이 <code>vue init</code>만 사용하면 되지만 직접 프로젝트를 생성할 때에는 <code>vue create</code>를 사용한다.</p><p>vue 프로젝트를 생성해 보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">vue create &lt;project-name&gt;<br></code></pre></td></tr></table></figure><p>위와 같이 실행하면 대화형 커맨드로 프로젝트 구성에 필요한 요소들을 선택하여 설치할 수 있다. <code>default</code>를 선택하여 생성하게 되면 표시된 대로 <code>babel</code>과 <code>eslint</code>가 설치된다.<br><code>Manually select features</code>를 선택하게 되면 <code>vuex</code>, <code>vue-router</code> 등과 같은 몇 가지 더 선택적으로 설치할 수 있다. 우리는 <code>Manually select features</code>를 선택하도록 하자.</p><p><img src="/2019/04/22/vue-cli3-tutorial/img1.png" alt="vue-cli-sample1"></p><p>무엇을 설치할지는 본인의 몫이지만 해당 포스트에서는 <strong><code>Babel</code>, <code>Router</code>, <code>Vuex</code>, <code>CSS pre-processors</code>, <code>Linter / Formatter</code></strong>를 선택하여 설치해 보자. <code>Unit Testing</code>에 대해서는 <a href="https://kdydesign.github.io/2017/06/08/Mocha.html">JavaScript 단위 테스트 프레임워크 - Mocha Tutorial</a>을 참고하자.</p><p>필요한 모듈들을 선택하고 다음 단계로 넘어가면 vue-router의 <code>history</code> 기능을 사용할지 여부를 확인한다. 기본 설치이므로 엔터를 치고 넘어가자.</p><p><img src="/2019/04/22/vue-cli3-tutorial/img2.png" alt="vue-cli-sample2"></p><p>다음 단계에서는 <code>CSS 전처리기(CSS pre-processors)</code>에 대해서 어떤 모듈을 사용하지 선택하는 항목이 나온다. 본 포스트에서는 <code>Stylus</code>를 선택하였다.</p><p><img src="/2019/04/22/vue-cli3-tutorial/img3.png" alt="vue-cli-sample3"></p><p>그다음으로는 <code>ESLint</code>에 관련된 항목이 나온다. 어떤 항목을 선택하더라도 ESLint는 기본적으로 설치가 되며 여기서는 ESLint에 대해 어떤 룰을 적용할지를 선택한다. 본 포스트에서는 <code>Standard config</code>를 선택하도록 하겠다.</p><p><img src="/2019/04/22/vue-cli3-tutorial/img4.png" alt="vue-cli-sample4"></p><p>다음으로는 <code>Lint on save</code>를 선택하고 그다음 단계에서는 <code>In package.json</code> 선택하고 넘어가게 되면 선택된 모듈들이 설치됨으로써 프로젝트 구성은 끝이 난다.</p><p>생성된 디렉토리를 보게 되면 우리가 애플리케이션을 구성하는데 필요한 요소들이 이미 준비가 되어있다.</p><h1 id="Vue-CLI-3-UI"><a href="#Vue-CLI-3-UI" class="headerlink" title="Vue-CLI 3 UI"></a>Vue-CLI 3 UI</h1><p>이제 이렇게 구성된 프로젝트를 <code>Vue-CLI 3 UI</code>를 통해 프로젝트 관리를 알아보자.<br>위에서 생성된 프로젝트에서 <code>vue ui</code>를 실행하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">vue ui<br></code></pre></td></tr></table></figure><p>위와 같이 실행하면 <code>Vue 프로젝트 매니저</code>가 <code>locahost:8000</code>으로 자동으로 브라우저가 실행된다. 이 Vue 프로젝트 매니저에서 위에서 생성한 프로젝트를 생성 할 수도 있으며 이미 생성된 프로젝트를 불러와서 관리 포인트로 둘 수도 있다. 우리는 프로젝트를 이미 생성하였으므로 <code>가져오기</code> 버튼을 클릭하여 해당 프로젝트를 가져오자.</p><p><img src="/2019/04/22/vue-cli3-tutorial/vue-ui.png" alt="vue-ui"></p><p>Vue 프로젝트 매니저를 훑어보면 대번 어떤 형태인지 알 수 있다. 우리가 커맨드로 처리하던 행동들을 UI를 통해서 처리할 수 있다고 볼 수 있다.</p><h1 id="프로젝트-실행"><a href="#프로젝트-실행" class="headerlink" title="프로젝트 실행"></a>프로젝트 실행</h1><p><code>Vue 프로젝트 매니저</code>의 <code>작업 목록</code>에서 <code>serve</code>를 통해 구동할 수도 있으며, npm 커맨드를 통해서도 구동할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm run serve<br></code></pre></td></tr></table></figure><p><img src="/2019/04/22/vue-cli3-tutorial/run-serve.png" alt="run-serve"></p><h1 id="Vue-CLI-3-PlugIn-설치"><a href="#Vue-CLI-3-PlugIn-설치" class="headerlink" title="Vue CLI 3 PlugIn 설치"></a>Vue CLI 3 PlugIn 설치</h1><p>Vue CLI를 통해 PlugIn을 설치하기 위해서는 <code>vue add</code> 커맨드를 사용하면 된다. 또는 <code>Vue 프로젝트 매니저</code>에서 PlugIn의 목록을 검색할 수도 있고 설치까지 할 수 있으니 한번 확인해보기 바란다.</p><p>여기서는 <code>vue-cli-plugin-axios</code>를 설치해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">vue add axios // or vue add vue-cli-plugin-axios<br></code></pre></td></tr></table></figure><p>PlugIn이 설치되었으면 확인해보자.<br>먼저 <code>src &gt; plugins</code> 폴더를 보게 되면 <code>axios.js</code>를 확인해 볼 수 있다. 해당 파일의 내용을 보면 이런 내용이 있다.</p><p><strong>axios.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Plugin</span>.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">Vue, options</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">axios</span> = _axios;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">axios</span> = _axios;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>    <span class="hljs-attr">axios</span>: &#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> _axios;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">$axios</span>: &#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> _axios;<br>      &#125;<br>    &#125;,<br>  &#125;);<br>&#125;;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Plugin</span>)<br></code></pre></td></tr></table></figure><p>우리가 Vue CLI를 사용하지 않고 Vue.js 애플리케이션을 만들었다면 <code>axios</code>를 npm으로 설치하고 main.js 또는 app.js에 수동적으로 추가해주었을 <code>Vue.use()</code>가 자동으로<br>생성되어있다.</p><p>그럼 <code>axios.js</code>는 어디에 삽입된 것일까? <code>src &gt; main.js</code>를 열어보자.</p><p><strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./plugins/axios&#x27;</span><br></code></pre></td></tr></table></figure><p>상단에 보면 이미 <code>axios.js</code>가 <code>main.js</code>에 import 된 것을 볼 수 있다.</p><hr><p>여기까지 해서 우리는 <code>Vue CLI 3</code>를 통해 프로젝트를 구성하고 실행했으며, <code>Vue 프로젝트 매니저</code>를 통해 프로젝트를 관리할 수 있다는 것을 알게 되었다. 물론 <code>package.json</code>에도 종속성이 관리되어 설치된 것도 확인이 가능하다.</p><p>Vue CLI 3 PlugIn에 대해서는 <a href="https://cli.vuejs.org/guide/plugins-and-presets.html#plugins">Vue CLI 3 플러그인 및 프리셋</a>을 참고하자.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2019/04/10/vue-store-state/">Vuex Store의 state를 효율적으로 초기화하기</a><br><a href="https://kdydesign.github.io/2019/04/27/vue-component/">Vue.JS Component 개념을 익히고 만들어보자!!</a><br><a href="https://kdydesign.github.io/2020/11/13/vuejs-provide-inject/">Vue Component provide&#x2F;inject 이해하기</a><br><a href="https://kdydesign.github.io/2021/01/14/vue-eventbus-vs-vuex/">Vuex VS Event Bus</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> npm </category>
          
          <category> vue.js </category>
          
          <category> vue cli </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> electron </tag>
            
            <tag> vue.js </tag>
            
            <tag> nuxt.js </tag>
            
            <tag> vue cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Electron] Electron 개념부터 데스크탑 앱 만들기</title>
      <link href="/2019/04/15/electron-tutorial/"/>
      <url>/2019/04/15/electron-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/04/15/electron-tutorial/cover.png" alt="cover"></p><p>웹 기술인 JavaScript, HTML, CSS를 이용하여 크로스 플랫폼 데스크탑 앱을 만들 수 있는 Electron의 활용성과 사례가 어떤지 알아보고, 개념부터 설치 그리고 데스트탑 앱을 한 번에 배우고 만들어보자.</p><p>이제는 JavaScript와 HTML 그리고 CSS를 활용하여 데스크탑 앱을 만들 수 있다. Electron은 다른 JavaScript Framework와도 접목해 개발이 가능하기 때문에 기존의 웹 기술을 가지고 있는 웹 개발자라면 한 번쯤은 도전해 볼 만한 Framework이다.</p><p>처음 Electron을 알게 된 경로는 웹 신기술 관련하여 검색하다가 우연히 알게 되었다. 그때는 그저 글로만 보고 <code>뭐? JavaScript로 데스크 탑 앱을 만든다고? 가능한가 이게?</code> 라는 생각만 하고 좀 찾아보았고 <code>오오~</code> 하다가 말았던 기억이 있다. 그로부터 꽤 시간이 지났고 불과 몇 년 전에 Front-End 컨퍼런스에 참여하였고 Electron 섹션을 듣고 나서 꼭 한번 해보고 싶다고 생각했다. 그걸 인제야 포스팅하고 있다.</p><hr><h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><p>Electron은 <strong><a href="https://ko.wikipedia.org/wiki/%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%97%84_%28%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%29">Chromium</a>과 Node.js를 사용하여 JavaScript, HTML, CSS를 이용하여 윈도우 또는 Mac, 리눅스에서 직접 설치하여 사용할 수 있는 애플리케이션을 개발</strong> 할 수 있다. 크로스 플랫폼 지원으로 이 세 개의 운영체제에서 빌드되고 동작한다. 웹 개발자라면 습득한 기술 그대로 Electron만 익혀서 어느 운영체제에서든 동작하는 설치형 애플리케이션을 프로그래밍할 수 있다는 소리이다.</p><p><a href="https://electronjs.org/">Electron 공식 사이트</a>에 가보면 이런 문구가 있다.</p><hr><p style="text-align: center;font-weight: bold;color: gray;"><i>It's easier than you think</i></p><p style="text-align: center;font-weight: bold;color: gray"><i>Electron은 여러분이 생각한 것보다 쉽습니다.</i></p><hr><p>Electron을 직접 해보면 알겠지만, 문구 그대로인 듯하다. 처음에 생각만 해본다면 웹 기술을 이용하여 데스크 탑 애플리케이션을 만든다고 하면 이것저것 설치하고 설정하고 무지막지하게 복잡할 것 같다. 하지만 그런 복잡한 작업은 Electron이 처리해 준다. 그저 웹 개발자는 그냥 웹으로 생각하고 코딩만 하면 된다. 물론 Electron에 대해서 배워야 하지만 말이다.</p><p>사실 처음 Electron으로 해보면서 너무 신기하였지만 다른 한편으로는 Electron을 이해하는데 힘들었다. 웹 개발자로서 항상 브라우저의 리소스만 사용하다가 웹 기술을 통해서 시스템 지원을 막 가져다 쓴다… 너무 신기했지만, 웹에 항상 국한돼서 개발한 나에게 이 신기한 기술이 내가 기존에 가지고 있던 웹 개념들을 마구 흔들어 놓았다.</p><h1 id="Electron의-추이"><a href="#Electron의-추이" class="headerlink" title="Electron의 추이"></a>Electron의 추이</h1><p>현재 Electron의 버전은 10.x이다. 처음 1.x를 출시한 게 2016년도이고 최초로 0.x를 출시한 것은 2013년도 있다. <a href="https://electronjs.org/releases/stable">Electron Version</a>에서 모든 버전을 볼 수 있다.<br>0.x 버전을 제외하고 1.x부터 본다면 출시한 지 약 3년이 되었다. 그동안 Electron이 얼마나 인지도가 높아졌는지 확인해 보자.</p><div class="alert warning no-icon"><p>Electron의 버전은 빠른 속도로 증가하며 이에 따라 Node의 버전이 변경되어야하니 참고하도록 하자.</p></div><br/><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2213_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"electron js","geo":"","time":"2004-01-01 2020-09-15"}],"category":0,"property":""}, {"exploreQuery":"date=all&q=electron%20js","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script> <p>어느 프레임워크와 비슷하게 상승 중이지만 릴리즈 버전만 보더라도 많은 성장을 이루어온 것을 볼 수 있다.</p><p><a href="https://2018.stateofjs.com/mobile-and-desktop/overview/">2018 The State of JavaScript - Mobile &amp; Desktop 부분</a>을 보자.</p><p><img src="/2019/04/15/electron-tutorial/overall-result.png" alt="cover"></p><p>Electron이 한자리한 것을 볼 수 있다. 배우고 싶은 개발자들의 퍼센테이지와 이미 프로젝트 반영한 개발자들도 상당수 있다. </p><h2 id="Electron의-사용성"><a href="#Electron의-사용성" class="headerlink" title="Electron의 사용성"></a>Electron의 사용성</h2><p>추이는 그저 Electron의 인지도를 감을 잡기 위해서 본 것이고 실제로 이 Electron을 가지고 프로젝트에 도입하고 실제로 서비스를 했다면 이야기는 달라진다. 이런 프로젝트가 무수히 많고 우리가 들으면 모두 알 법한 애플리케이션들이 많다.</p><p>먼저 <a href="https://electronjs.org/apps">Electron 앱 Store</a>에 등록된 애플리케이션을 보자. 수 천은 아니라도 다양한 애플리케이션이 등록되어 있다. 우리가 애플리케이션을 만든다면 이곳에 등록을 할 수가 있다. 찾아보면 Mac에서도 많이 사용되는 <code>Simple-Note</code>도 Electron Application이 있는 것도 볼 수 있다. 이 외에도 <a href="https://github.com/sindresorhus/awesome-electron">Awesome-Electron</a>에 올라온 오픈 소스 애플리케이션이 많으니 참고하면 된다.</p><p>공식 페이지에 바로 나와 있지만, 우리가 많이 사용하고 유명한 애플리케이션들이 많다. vscode, Discord, Slack, Atom.. 훌륭하다!</p><p><img src="/2019/04/15/electron-tutorial/electron-app.png" alt="cover"></p><p>이렇게 본다면 현재 시점에서도 Electron을 도입해도 무방하다고 볼 수 있다.</p><h2 id="Electron과-Web-Application-Framework"><a href="#Electron과-Web-Application-Framework" class="headerlink" title="Electron과 Web Application Framework"></a>Electron과 Web Application Framework</h2><p>Electron은 웹 기반 기술을 사용하기 때문에 우리가 흔히 사용하고 Front-End Framework 3대장인 <strong>Angular, React, Vue Framework도 Electron과 같이 사용</strong>할 수 있다. 물론 능력 있는 개발자들은 Electron에 직접 Web Framework를 얹어 사용할 수도 있지만 이미 능력자들이 만들어 놓은 <code>Boilerplate</code>와 <code>start Template</code>이 많이 있다.</p><p>이 Boilerplate와 Template 몇 가지를 살펴보자.</p><div class="alert danger no-icon"><ul><li>Vue - <a href="https://github.com/SimulatedGREG/electron-vue">electron-vue</a></li><li>React - <a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate">electon-react-boilerplate</a></li><li>Angular - <a href="https://github.com/maximegris/angular-electron">angular-electron</a></li></ul></div><p>위 템플릿 사용한다면 문제없이 훌륭한 Electron Application을 만들 수 있다.</p><h2 id="Electron-설치"><a href="#Electron-설치" class="headerlink" title="Electron 설치"></a>Electron 설치</h2><p>이제 Electron에 대해 어느 정도 파악이 되었을 것이다. 이제 실제로 Electron을 설치해서 실행 보자. Node.js가 설치되었다고 가정하고 진행한다. 만약 Node.js가 무엇인지 모른다면 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념 잡기</a> 포스트를 참고하자.</p><p>다행스럽게도 Electron 자체만으로도 빠르게 진행할 수 있는 <a href="https://github.com/electron/electron-quick-start">electron-quick-start</a>를 제공하고 있다.</p><p>우리는 이 Template를 받아서 실행해 보자.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$ git clone https://github.com/electron/electron-quick-start <br>$ cd electron-quick-start<br>$ npm i &amp;&amp; npm start<br></code></pre></td></tr></table></figure><p>지체 없이 node modules를 설치하고 실행하게 되면 <code>Hello World!</code>가 적힌 Electron Application이 실행된다. 해당 Application에서는 설치되어있는 Node.js, Chromium, Electron 버전이 출력되고 있다.</p><h2 id="Electron-Debug"><a href="#Electron-Debug" class="headerlink" title="Electron Debug"></a>Electron Debug</h2><p>실행까지는 매우 간단하게 진행되었다. 물론 Debugging 하는 것도 쉽다. 이미 Electron은 Chromium을 사용하였기 때문에 우리는 Chrome에서 개발 시 사용하던 <code>devTools</code>를 Electron에서도 사용할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Menu &gt; View &gt; Toggle Developer Tools<br>또는 Ctrl + Shift + I<br></code></pre></td></tr></table></figure><p>흔히 보던 DevTools가 실행이 된다. 여기서 <code>Console 탭</code>으로 가자.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&gt; process<br></code></pre></td></tr></table></figure><p><img src="/2019/04/15/electron-tutorial/process.png" alt="cover"></p><p>간단하지만 현재의 시스템 정보 등 몇 가지 정보를 볼 수 있다.</p><h2 id="Electron-Build"><a href="#Electron-Build" class="headerlink" title="Electron Build"></a>Electron Build</h2><p>이제 이 아주 간단한 Application을 실제로 빌드를 하여 실행 파일로 생성해보자.</p><p>Application을 수동으로 빌드 시스템을 갖출 수도 있겠지만 역시나 <strong>Third-Party Package Tool</strong>이 존재한다.</p><div class="alert info no-icon"><ul><li><a href="https://github.com/electron-userland/electron-forge">electron-forge</a></li><li><a href="https://github.com/electron-userland/electron-builder">electron-builder</a></li><li><a href="https://github.com/electron-userland/electron-packager">electron-packager</a></li></ul></div><p>무엇을 사용할 것인가는 본인들이 판단하기 바라며, 이 포스트에서는 <a href="https://github.com/electron-userland/electron-builder">electron-builder</a>를 사용해 보기로 하자.</p><p>npm을 통해 설치를 진행하자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm i -D electron-builder<br></code></pre></td></tr></table></figure><p>설치가 되었으면 패키지에 필요한 정보를 <code>package.json</code> 가장 하단에 명시하자. </p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;productName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Electron-Application&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;appId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myApp&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>이제 <code>package.json</code>의 npm command를 수정하여 실행해 보자.</p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;electron .&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;electron-builder&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm run pack<br></code></pre></td></tr></table></figure><p>별도의 빌드옵션을 주지 않았기 때문에 가장 기본적으로 빌드가 될 것이다. 그래도 만족하지 않은가?</p><p>빌드 결과를 확인해 보자.</p><p><img src="/2019/04/15/electron-tutorial/build.png" alt="cover"></p><p><code>build</code> 디렉토리가 생성되었을 것이고, 그 안에는 <code>win-unpacked</code> 디렉토리와, 생성된 <code>exe</code> 파일이 존재할 것이다. <code>win-unpacked</code> 안에는 빌드 결과물이 있으며, 이 안에도 <code>exe</code> 파일이 있을 것이다. 이 파일을 실행해 보자.</p><p>우리가 만든 Electron Application이 실행되는 걸 볼 수 있다. 그러면 이제 상위 디렉토리로 올라가 다른 <code>exe</code> 파일을 실행해 보자.</p><p>우리가 만든 Electron Application이 설치되는 것을 볼 수 있다. 바탕화면으로 가면 <code>Electron 기본 아이콘</code>으로 바로 가기가 생성된 것도 확인해 볼 수 있으며, <code>제어판 &gt; 프로그램 및 기능으로 가면 설치된 항목</code>을 볼 수 있다.</p><hr><p>여기까지 해서 Electron이 무엇인지 그리고 Electron의 추이가 어떤지 확인도 해보고 간단하지만, Electron Application을 생성하고 실제로 배포까지 해 보았다. 간단하지만 우리는 지금 Electron의 한 과정을 경험 해 본 것이다. 이제 좀 더 퀄리티있는 Application을 만들기 위해 우리는 <code>Web Framework를 추가해서 실제 그럴싸한 Application</code>을 만들어 보자. 다음 포스팅엔 <strong>Vue.js와 Electron을 사용하는 방법</strong>에 대해서 알아보도록 하자. 그전에 Vue.js가 무엇인지 <a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a>에서 확인해보도록 하자.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2023/09/28/electron-rce/">[Electron] ContextBridge를 사용한 Electron RCE(Remote Code Execution) 보안 취약점 수정</a><br><a href="https://kdydesign.github.io/2020/12/23/electron-ipc-communication/">Electron IPC 모듈로 Electron 통신 방법 파헤치기</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> npm </category>
          
          <category> electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
            <tag> electron </tag>
            
            <tag> electron.js </tag>
            
            <tag> electron 배우기 </tag>
            
            <tag> electron 튜토리얼 </tag>
            
            <tag> electron tutorial </tag>
            
            <tag> electron framework </tag>
            
            <tag> electron 설치 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Nuxt.js] 개념부터 설치까지 빠르게 배우기</title>
      <link href="/2019/04/10/nuxtjs-tutorial/"/>
      <url>/2019/04/10/nuxtjs-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/04/10/nuxtjs-tutorial/cover.png" alt="cover"></p><p>Vue Application을 만들기 위한 강력한 Framework 인 Nuxt.js에 대해 알아보자.<br>Nuxt.js는 Vue.js 응용 프로그램을 만들기 위한 Framework이며, Vue.js Application을 좀 더 손쉽게 만들 수 있으며 Server-Side-Rendering을 지원한다.</p><p>이번 포스팅에서는 Vue.js Application을 쉽게 생성하고 만들 수 있는 프레임 워크인 Nuxt.js에 대해서 알아볼까 한다.<br>Nuxt.js는 React의 Next.js에서 영감을 받아 진행된 프로젝트로 온전히 겉으로만 본다면 프레임워크이기 때문에 leaning curve가 있을 것 같지만 사실상 그렇지는 않다. Nuxt.js를 설치하고 사용해 본다면 그저 Nuxt.js는 Vue.js를 사용할 때 하나하나 작업해줘야 할 요소들을 생성해주고 처리해주는 것임을 알 수 있다.</p><p>본 포스팅으로 써 Nuxt.js 도입에 고민하는 개발자에게 도움이 되었으면 한다. 장담하건데 Nuxt.js를 1년간 사용한 개발자로써 적극 추천하며 프로젝트에 도입해도 문제가 되지 않음을 알려주고 싶다.</p><p>본격적으로 Nuxt.js에 대해서 알아보자.</p><h1 id="Nuxt-js-소개"><a href="#Nuxt-js-소개" class="headerlink" title="Nuxt.js 소개"></a>Nuxt.js 소개</h1><p>먼저 <a href="https://nuxtjs.org/guide">Nuxt.js의 공식 사이트</a> 이다. Vue.js와 마찬가지로 한국어 문서가 존재하지만 Nuxt.js의 발빠른 업데이트에 한국어 문서가 따라가지 못하는 것 같다. Vue.js 역시 동일하지만.. 그렇다고 번역하시는 분을 욕하는 게 아니라 그만큼 Nuxt.js의 활동이 활발하다는 이야기이다. 아무튼 이러한 이유로 영문본으로 보기를 바란다.</p><p>Nuxt.js의 소개를 본다면 이렇게 명시하고 있다.</p><div class="alert info no-icon"><ul><li>주요 범위는 UI Rendering이며, 클라이언트&#x2F;서버 배포를 추상화한다.</li><li>Nuxt.js의 목표는 기본 프로젝트 베이스로 사용할 수 있으며 Node.js 기반의 프로젝트를 유연하게 사용할 수 있는 프레임 워크를 만드는 것이다.</li><li>Nuxt.js는 서버 사이드 렌더링 된 Vue.js 응용 프로그램의 개발을 위해 이에 필요한 모든 구성을 사전 설정한다.</li><li>Nuxt.js는 nuxt generate 라는 배포 옵션을 제공한다. nuxt gererate를 통해 vue.js를 정적인 응용 프로그램으로 빌드한다. 우리는 이 옵션이 마이크로 서비스가 있는 웹 응용 프로그램 개발의 다음 단계일 수 있다고 생각한다.</li><li>Nuxt.js는 단일 응용 페이지(SPA)를 신속하게 만들 수 있다.</li><li>Nuxt.js는 비동기 데이터, 미들웨어, 레이아웃 등과 같이 클라이언트 측과 서버 측 사이에서 개발하는 데 도움이 되는 많은 기능을 제공한다.</li></ul></div><p>어려운 말들이 많을 수 있겠지만 아직도 Nuxt.js를 사용을 해야 할지 말아야 할지 고민하는 당신을 위해 쉽게 설명을 해본다면 이렇다.</p><div class="alert info no-icon"><ul><li>Nuxt.js 설치만으로 이미 scaffolding(프로젝트 구조화)을 해주므로 딱히 프로젝트 구조에 대해서 고민할 필요가 없다.</li><li>Vue.js 하나하나 잡아줘야 할 라우팅을 Nuxt.js에서 파일을 생성하는 것만으로 라우팅을 자동으로 생성해 준다.</li><li>layout, store, middleware와 같은 요소들을 이미 구분을 지어주고 필요한 항목들을 처리해주기 때문에 순전히 개발에만 집중하면 된다.</li><li>Server-Side-Rendering에 필요한 요소가 이미 준비가 되어있다.</li><li>webpack을 통한 빌드 시스템이 이미 구현되어 있다. 그저 npm run만 해주면 된다.</li></ul></div><h1 id="Nuxt-js의-활동성"><a href="#Nuxt-js의-활동성" class="headerlink" title="Nuxt.js의 활동성"></a>Nuxt.js의 활동성</h1><p>Nuxt.js의 활용성과 기능이 아무리 좋다고 하더라고 결국 MIT 라이센스를 가진 오픈 소스이다. 오픈 소스의 단점은 버그 픽스를 하지 않고 버전 업데이트가 거의 없다면 사용할 수 없다는 것이다. 하지만 nuxt.js의 업데이트 주기는 매우 빠르다. </p><p>해당 포스트 작성자는 Nuxt.js를 1.0.0-rc 버전부터 프로젝트에 도입하였고 현재 버전은 최신버전을 유지(포스트 작성 당시 v2.4.3)하지만, 이제는 업데이트된 버전으로 마이그레이션하기가 힘들 정도로 업데이트 주기가 빠르다.</p><p>아래 표를 통해 현재 nuxt.js가 얼마나 업데이트가 활발한지 확인해 보자. Nuxt.js의 버전 계획은 <a href="https://github.com/nuxt/nuxt.js/blob/dev/RELEASE_PLAN.md">Nuxt.js Release Plan</a>에서 확인이 가능하다. </p><p>패치 버전이 많기 때문에 minor 기준으로 확인해보자.</p><table><thead><tr><th>버전</th><th>업데이트 날짜</th></tr></thead><tbody><tr><td>v1.0.0-rc6</td><td>2017-08-22</td></tr><tr><td>v1.0.0-rc7</td><td>2017-08-29</td></tr><tr><td>v1.0.0-rc8</td><td>2017-08-31</td></tr><tr><td>v1.0.0-rc9</td><td>2017-09-06</td></tr><tr><td>v1.0.0-rc10</td><td>2017-09-07</td></tr><tr><td>v1.0.0-rc11</td><td>2017-09-07</td></tr><tr><td>v1.0.0</td><td>2018-01-09</td></tr><tr><td>v1.1.0</td><td>2018-01-13</td></tr><tr><td>v1.2.0</td><td>2018-01-26</td></tr><tr><td>v1.3.0</td><td>2018-02-01</td></tr><tr><td>v1.4.0</td><td>2018-03-02</td></tr><tr><td>v2.0.0</td><td>2018-09-21</td></tr><tr><td>v2.1.0</td><td>2018-10-01</td></tr><tr><td>v2.2.0</td><td>2018-10-14</td></tr><tr><td>v2.4.0</td><td>2019-01-09</td></tr><tr><td>v2.5.0</td><td>2019-03-21</td></tr><tr><td>v2.6.0</td><td>2019-04-05</td></tr><tr><td>v2.7.0</td><td>2019-05-14</td></tr><tr><td>v2.8.0</td><td>2019-05-31</td></tr><tr><td>v2.8.0</td><td>2019-08-20</td></tr><tr><td>v2.10.0</td><td>2019-10-02</td></tr><tr><td>v2.11.0</td><td>2019-12-17</td></tr><tr><td>v2.12.0</td><td>2020-03-18</td></tr><tr><td>v2.13.0</td><td>2020-06-19</td></tr><tr><td>v2.14.0</td><td>2020-07-28</td></tr></tbody></table><h1 id="Nuxt-js-설치"><a href="#Nuxt-js-설치" class="headerlink" title="Nuxt.js 설치"></a>Nuxt.js 설치</h1><p>Nuxt.js 팀이 스캐폴딩 해둔 템플릿을 사용하려면 create-nuxt-app을 npx를 통해서 설치하면된다. <code>npx</code>는 NPM 5.2.0 버전 이후 기본적으로 제공되기 때문에 별도로 설치할 필요는 없다.<br>Node.js에 대해서 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a>를 참고하자.</p><h2 id="Nuxt-js-설치-1"><a href="#Nuxt-js-설치-1" class="headerlink" title="Nuxt.js 설치"></a>Nuxt.js 설치</h2><p><strong>npx</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npx create-nuxt-app &lt;project-name&gt;<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn create nuxt-app &lt;project-name&gt;<br></code></pre></td></tr></table></figure><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm init nuxt-app &lt;project-name&gt;<br></code></pre></td></tr></table></figure><p>위와 같이 실행을 하게 되면 몇 가지 질문들이 나오는데 진행하는 프로젝트에 맞게 선택하여 설치하면 된다.</p><h2 id="vue-cli를-통한-Nuxt-js-설치"><a href="#vue-cli를-통한-Nuxt-js-설치" class="headerlink" title="vue-cli를 통한 Nuxt.js 설치"></a>vue-cli를 통한 Nuxt.js 설치</h2><p>Nuxt.js 버전이 올라가기 전에는 nuxt starter-template을 vue-cli를 통해서 설치하였다. CLI가 아닌 <a href="https://github.com/nuxt-community/starter-template/archive/master.zip">ZIP</a> 파일로 받아 압축을 풀어도 된다.</p><p>먼저 vue-cli를 설치하자. vue-cli에 대해서는 <a href="https://cli.vuejs.org/guide/">Vue CLI 공식 사이트</a>를 참고하자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm i -g @vue/cli<br>npm i -g @vue/cli-init<br></code></pre></td></tr></table></figure><p>그다음으로 template를 설치하고 npm module을 설치하면 된다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vue init nuxt-community/starter-template &lt;project-name&gt;<br><span class="hljs-built_in">cd</span> &lt;project-name&gt;<br>npm i<br></code></pre></td></tr></table></figure><h3 id="offline-설치-방법"><a href="#offline-설치-방법" class="headerlink" title="offline 설치 방법"></a>offline 설치 방법</h3><p>간혹 당신이 속한 소속에서 보안상 문제로 해당 사이트나 커맨드를 차단하여 nuxt-community에 속한 tempate을 vue-cli로 설치가 되지 안는 경우가 있다.<br>이런 경우에는 <code>offline</code>으로 설치가 가능하다.</p><p>우선 사용자 경로에 <strong>.vue-templates</strong> 폴더를 하나 생성하자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">C:\Users\사용자이름\.vue-templates<br></code></pre></td></tr></table></figure><p>그다음 <a href="https://github.com/nuxt-community/starter-template">Starter-Template</a>의 Github에서 해당 소스를 clone을 받고 위에서 생성한 폴더로 옮겨놓자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/nuxt-community/starter-template<br></code></pre></td></tr></table></figure><p>이 상태로 우리는 vue-cli를 통해서 github가 아닌 로컬에 저장된 템플릿을 사용할 수 있다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vue init starter-template &lt;project-name&gt; --offline<br></code></pre></td></tr></table></figure><h2 id="Nuxt-js-단일-설치"><a href="#Nuxt-js-단일-설치" class="headerlink" title="Nuxt.js 단일 설치"></a>Nuxt.js 단일 설치</h2><p>Nuxt.js 단독으로 설치할 경우엔 아래와 같이 명령어를 실행한다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm i nuxt<br></code></pre></td></tr></table></figure><h1 id="Nuxt-js-디렉토리-구조"><a href="#Nuxt-js-디렉토리-구조" class="headerlink" title="Nuxt.js 디렉토리 구조"></a>Nuxt.js 디렉토리 구조</h1><p>Nuxt.js의 기본 템플릿을 사용하였다면 이미 스캐폴딩이 되어 있을 것이다. 만약 단일로 Nuxt.js를 설치하였다 하더라도 해당 섹션을 보아야 하는 이유는 Nuxt.js 자체 내에서 필수로 있어야 하는 폴더들이 있기 때문이다.</p><p>디렉토리 구조를 파악해 보자.</p><h2 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h2><p>css, image, font와 같은 리소스들을 포함한다.</p><h2 id="components"><a href="#components" class="headerlink" title="components"></a>components</h2><p>애플리케이션에서 사용될 컴포넌트들을 포함하며 해당 경로에 위치된 컴포넌트들은 Nuxt.js의 비동기 데이터 함수인 <code>asyncData</code>또는 <code>fetch</code>를 사용할 수 없다.</p><h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><p>content는 <code>@nuxt/content</code> 모듈을 사용하여 애플리케이션을 확장할 수 있다. Markdown, JSON, YAML, XML, CSV와 같은 파일을 가져오고 관리할 수 있다. <a href="https://content.nuxtjs.org/">nuxt&#x2F;contents</a>에서 더 많은 정보를 확인해보자.</p><h2 id="layouts"><a href="#layouts" class="headerlink" title="layouts"></a>layouts</h2><p>애플리케이션 전체에 대한 레이아웃을 포함한다. 기본으로 default.vue가 생성되어 있을 것이고 상황에 맞게 layout을 생성할 수 있다. <code>해당 디렉토리는 이름을 변경할 수 없다.</code></p><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>애플리케이션에서 사용될 middleware를 포함한다. middleware는 페이지 또는 레이아웃이 렌더링 되기 전에 실행이 되며, middleware를 페이지나 레이아웃에 바인딩하였다면 해당 페이지나 레이아웃이 실행되기 전에 매번 실행된다.</p><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>Nuxt Module은 Nuxt 프레임워크의 핵심 기능을 확장하고 통합 및 추가할 수 있다. 사용자가 직접 모듈을 작성할 수 있으며 <a href="https://github.com/nuxt-community/awesome-nuxt">Nuxt 커뮤니티</a>에 이미 많은 모듈이 공개되어있다.</p><h2 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h2><p>실제 애플리케이션의 페이지 구성을 포함하며 해당 디렉토리의 구조에 따라 router가 자동으로 생성된다. <code>해당 디렉토리는 이름을 변경할 수 없다.</code></p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>애플리케이션에 바인딩 될 외부 혹은 내부 plugins를 포함한다.plugins는 애플리케이션이 인스턴스 화 되기 전에 실행하며 전역적으로 구성 요소를 등록하고 함수 또는 상수를 삽입할 수 있다.</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>해당 디렉토리는 정적인 파일들을 포함한다. 구성에 따라서 html, Javascript 파일도 포함 시킬 수 있다. <code>해당 디렉토리는 이름을 변경할 수 없다.</code></p><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>애플리케이션에서 사용될 vuex store 파일들을 포함한다. 기본적으로 비활성화 상태이고 store 디렉토리에 index.js 파일을 작성하면 store가 활성화된다. 구성에 따라서 모듈 형태의 store를 형성할 수 있다.  <code>해당 디렉토리는 이름을 변경할 수 없다.</code></p><h1 id="Nuxt-js-실행"><a href="#Nuxt-js-실행" class="headerlink" title="Nuxt.js 실행"></a>Nuxt.js 실행</h1><p>최초 템플릿을 설치하면 커맨드는 4가지가 존재한다.</p><table><thead><tr><th>COMMAND</th><th>설명</th></tr></thead><tbody><tr><td>dev</td><td>개발 서버를 Hot-reloading 상태로 localhost:3000으로 실행된다.</td></tr><tr><td>build</td><td>Webpack을 통해 애플리케이션을 빌드한다.</td></tr><tr><td>start</td><td>프로덕션(nuxt 배포)모드로 서버를 시작한다.(build 실행 후 진행된다.)</td></tr><tr><td>generate</td><td>애플리케이션을 빌드하고 모든 라우트를 HTML 파일로 생성한다.(정적 호스팅)</td></tr></tbody></table><p>지금까지 설치를 진행했으니 실행을 해보자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm run dev<br></code></pre></td></tr></table></figure><p>설명대로 <code>localhost:3000</code>으로 접속하여 실행된 페이지를 확인해보자.</p><h1 id="Nuxt-js-개발-서버-Host-Port-변경"><a href="#Nuxt-js-개발-서버-Host-Port-변경" class="headerlink" title="Nuxt.js 개발 서버 Host&#x2F;Port 변경"></a>Nuxt.js 개발 서버 Host&#x2F;Port 변경</h1><p>개발 서버는 기본 localhost와 port는 3000로 잡혀져 있지만, 해당 값을 변경하는 방법에는 몇 가지가 있지만 가장 기본적이고 보편적으로 사용되는 방법은 npm script를 수정하는 방법이다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nuxt --hostname &lt;host&gt; --port &lt;port&gt;<br></code></pre></td></tr></table></figure><p>하지만 이런 경우는 드물고 우리는 이미 <code>package.json</code>에 명시되어 있기 때문에 <code>package.json</code>을 수정하자.</p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nuxt --hostname &lt;host&gt; --port &lt;port&gt;&quot;</span><br>  <span class="hljs-punctuation">&#125;</span>  <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="Nuxt-js-Module"><a href="#Nuxt-js-Module" class="headerlink" title="Nuxt.js Module"></a>Nuxt.js Module</h1><p>여기까지 Nuxt.js를 설치하고 초기 상태까지 왔지만 앞으로 더 해야 할 일이 많을 것이다. 그중 가장 많이 처리되는 게 API 통신을 위한 <code>Axios</code>의 설치와 로컬 환경에서 CORS문제를 해결하여 개발을 하기 위한 <code>proxy</code>의 설치이다.</p><p>이 둘 다 <code>plugins</code>를 통해 설치하고 삽입할 수 있지만, 해당 포스트는 Nuxt.js 사용을 위한 포스트이기 때문에 <code>plugins</code>가 아닌 Nuxt.js의 <code>Module</code> 시스템을 설명하려 한다.</p><p>Nuxt.js <code>Module</code>은 핵심 기능은 <strong>확장하고 통합할 수 있는 Nuxt.js의 확장</strong>이다. 직접 Custom 하게 모듈을 만들 수 있으며, 이미 만들어진 모듈을 가져다 쓸 수 있다.</p><h2 id="Axios-Proxy-Module-사용"><a href="#Axios-Proxy-Module-사용" class="headerlink" title="Axios&#x2F;Proxy Module 사용"></a>Axios&#x2F;Proxy Module 사용</h2><p>Axios는 http 통신을 위해 사용되는 훌륭한 오픈 소스이다. 물론 Nuxt.js를 사용할 때 직접이 Axios를 사용해도 무방하다. 하지만 이 Axios를 가지고 Nuxt.js의 모듈화로 만들어진 것 있다. 우리는 그 <a href="https://axios.nuxtjs.org/setup">Axios module</a>을 사용해보자. Axios를 기반으로 생성된 모듈이라 Axios API를 참고해도 무방하며, Axios의 경량화로 볼 수 있다. Axios 모듈은 <a href="https://github.com/nuxt-community/proxy-module">Proxy</a> 모듈과 통합이 가능하기 때문에 Proxy 모듈도 같이 설치를 하자.</p><p>설치는 NPM으로 진행하자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm i @nuxtjs/axios<br>npm i @nuxtjs/proxy<br></code></pre></td></tr></table></figure><p>nuxt.config.js를 열어 설치된 모듈을 import 하자.</p><p><strong>nuxt.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">modules</span>: [<br>        <span class="hljs-string">&#x27;@nuxtjs/axios&#x27;</span><br>    ],<br>    <span class="hljs-attr">axios</span>: &#123;<br>        <span class="hljs-attr">proxy</span>: <span class="hljs-literal">true</span>     <span class="hljs-comment">// proxy 사용</span><br>    &#125;,<br>    <span class="hljs-attr">proxy</span>: &#123;<br>        <span class="hljs-string">&#x27;/prefix-url&#x27;</span>: <span class="hljs-string">&#x27;proxy-url&#x27;</span>    <span class="hljs-comment">// proxy url</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>위 처럼 <code>proxy</code> 옵션에 url-prefix를 지정하게 되면 <code>/prefix-url</code>로 시작되는 API는 모두 <code>proxy-url</code>로 Proxy 된다.</p><p>이제부턴 Axios의 사용이 가능하며 심지어 proxy까지 연동이 되어 있다.</p><h2 id="Module-생성하기"><a href="#Module-생성하기" class="headerlink" title="Module 생성하기"></a>Module 생성하기</h2><p>이번에는 간단하게 <code>console.log</code>를 nuxt의 module로 직접 만들어보자.<br>먼저 프로젝트 Root 경로에 <code>modules</code> 폴더를 만들어 보자. 명칭은 상관없다. 그다음 <code>logs.js</code>와 <code>logs.template.js</code> 파일을 생성하자.</p><p>module을 생성하는데 필요한 파일은 두 가지이다.</p><div class="alert info no-icon"><ol><li><strong>logs.js</strong>: 실제 nuxt.config.js의 modules에 사용될 index 파일</li><li><strong>logs.template.js</strong>: nuxt module에 삽입될 템플릿 파일</li></ol></div><h3 id="logs-js"><a href="#logs-js" class="headerlink" title="logs.js"></a>logs.js</h3><p>logs.js에서는 module의 사용될 템플릿 역할을 하는 소스를 실제 nuxt 인스턴스에 삽입하는 과정을 한다.</p><p><strong>logs.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_moduleOpts</span>) &#123;<br>    <span class="hljs-keyword">const</span> moduleOptions = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">log</span>, _moduleOptions)<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addPlugin</span>(&#123;<br>        <span class="hljs-attr">src</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;logs.template.js&#x27;</span>),<br>        moduleOptions<br>    &#125;)<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">meta</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../../package.json&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="logs-template-js"><a href="#logs-template-js" class="headerlink" title="logs.template.js"></a>logs.template.js</h3><p>logs.template.js는 실제 비즈니스 로직이 코딩되며 프로토타입의 명칭을 정한다.</p><p><strong>logs.template.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (ctx, inject) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">logs</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...args)<br>    &#125;<br><br>    <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;log&#x27;</span>, logs)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h3><p>우리는 logs.template.js에서 inject에 <code>log</code>라고 정의를 하였고 nuxt 프로토타입에 삽입하였기 때문에 사용 시에는 <code>log</code> 앞에 <code>$</code>를 붙여서 사용하면 된다. 실제로 <code>this</code>를 확인해 보면 <code>$log</code>가 생긴 것을 확인해 볼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.$log(<span class="hljs-string">&#x27;test log&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="Root-Source-디렉토리-변경하기"><a href="#Root-Source-디렉토리-변경하기" class="headerlink" title="Root Source 디렉토리 변경하기"></a>Root Source 디렉토리 변경하기</h1><p>현재의 디렉토리 구조를 보면 layout, pages, components 등 모든 폴더가 root 경로로 지정되어있다. 하지만 결국 우리는 어떤 프로젝트에 Nuxt.js를 도입을 하게 되면 현재의 디렉토리 구조대로 쓰지 못할 경우가 발생된다. 예를 들어 root의 경로를 App으로 지정해보자.</p><p>디렉토리 구조는 다음과 같다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">├─ App<br>│   ├─ assets/<br>│   ├─ components/<br>│   ├─ layouts/<br>│   ├─ middleware/<br>│   ├─ pages/<br>│   ├─ plugins/<br>│   ├─ static/<br>│   └─ store/<br>├─ node_modules/<br>└─ package.json<br></code></pre></td></tr></table></figure><p>위 구조를 보면 모든 리소스는 <code>App</code> 경로 하위에 존재한다. 이럴 경우 우리는 <code>source directory</code>를 수정해줄 필요가 있다.</p><p>nuxt.config.js 파일을 열어 수정해주자.</p><p><strong>nuxt.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">srcDir</span>: <span class="hljs-string">&#x27;App/&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>Nuxt.js 는 스캐폴딩부터 Vue.js를 사용하면서 귀찮은 작업을 대신해 주기에 많이 사용하고 있다. 다만 좀 어려운 점은 처음에 제공되는 템플릿에서 좀 더 확장성을 가진 구조를 만들기 위해서는 nuxt.config.js의 옵션들을 자세히 알아야 하고 수정해야 한다는 점이다. nuxt.js에서 옵션이 워낙 많다 보니 프로젝트 구조를 잡을 때는 API 문서를 항상 열어 두는 것이 좋다.</p><p>해당 포스트는 Nuxt.js의 기초를 다루려고 하였지만 Nuxt.js의 API가 워낙 잘 되어있나 보니 불필요한 내용이 끼워지게 되었다. 다음 포스트에서는 Nuxt.js에서 middleware 처리를 어떻게 하는지, 또 pages 구조를 어떻게 잡아야 vue-route의 기능을 사용할 수 있는지 등에 대한 좀 더 깊이 있게 다루는 포스트를 올리도록 하겠다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지를 배워보자!</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> nuxt.js </category>
          
          <category> vue.js tutorial </category>
          
          <category> nuxt.js tutorial </category>
          
          <category> nuxt.js 설치 </category>
          
          <category> nuxt.js 기초 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> nuxt.js </tag>
            
            <tag> nuxt.js tutorial </tag>
            
            <tag> nuxt.js 설치 </tag>
            
            <tag> nuxt.js 기초 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] Vuex Store의 state를 효율적으로 초기화하기</title>
      <link href="/2019/04/10/vue-store-state/"/>
      <url>/2019/04/10/vue-store-state/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/04/10/vue-store-state/cover.png" alt="vue-tutorial"></p><p>Vue.js의 상태 관리 패턴인 Vuex에서 Store의 state를 초기화하는 방법에 대해 알아보자. </p><p>Vuex Store에서 state는 원본 데이터 즉, 모델의 역할을 하며 <code>mutation</code>에 의해 변경이 가능하다. state는 최초에 명시되어 있어야 하며, 때로는 기본값을 가지고 있다. 이러한 state를 mutation에 의해 변경을 하고 이후 어떠한 작업을 하더라도 초기화되지 않는다. 그렇기 때문에 해당 stat를 다시 사용한다면 이전 값이 남아있다. 그렇기 때문에 state의 초기화는 필수적이다. </p><p>이번 포스트에서는 <strong>state를 초기화하는 효율적인 방법</strong>에 대해 알아보자.</p><h1 id="state의-효율적인-선언과-초기화"><a href="#state의-효율적인-선언과-초기화" class="headerlink" title="state의 효율적인 선언과 초기화"></a>state의 효율적인 선언과 초기화</h1><p>당연한 말이지만 state의 초기화는 mutation에 의해서 초기값을 지정해주면 끝이다. 물론 이러한 방법을 공유하려는 것은 아니다. 더욱 효율적이고 가독성이 좋은 코드 스타일을 설명을 하려 한다. </p><p>먼저 아래 코드를 보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// state</span><br><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">userList</span>: [],<br>  <span class="hljs-attr">isFlag</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">userData</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&#x27;programmer&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">companyData</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;company&#x27;</span>,<br>    <span class="hljs-attr">address</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// mutations</span><br><span class="hljs-keyword">const</span> mutations = &#123;<br>  initData (state) &#123;<br>    state.<span class="hljs-property">userList</span> = []<br>    state.<span class="hljs-property">isFlag</span> = <span class="hljs-literal">false</span><br>    state.<span class="hljs-property">userData</span> = &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">password</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>      <span class="hljs-attr">job</span>: <span class="hljs-string">&#x27;programmer&#x27;</span><br>    &#125;<br>    state.<span class="hljs-property">companyData</span> =  &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;company&#x27;</span>,<br>      <span class="hljs-attr">address</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">job</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>  state,<br>  mutations<br>&#125;<br></code></pre></td></tr></table></figure><p>별다를 것 없는 기본적인 state이고 이 state를 초기화하는 <code>initData</code>이라는 mutataion이다. 이러한 방법은 가장 기본적이고 이렇게 밖에 할 수 없을 것이다. 하지만 여기서 <code>userData</code>와 <code>companyData</code>를 보자. 다른 state와는 다르게 <code>object</code>형태를 가지고 있다. 보통 이런 state는 단일로 설정하고 사용하는 경우가 많다. 예를 들면 아래와 같다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// mutations</span><br><span class="hljs-keyword">const</span> mutations = &#123;<br>  setUserData (state, payload) &#123;<br>    state.<span class="hljs-property">userData</span>.<span class="hljs-property">id</span> = payload.<span class="hljs-property">id</span><br>    state.<span class="hljs-property">userData</span>.<span class="hljs-property">password</span> = payload.<span class="hljs-property">password</span><br>    state.<span class="hljs-property">userData</span>.<span class="hljs-property">name</span> = payload.<span class="hljs-property">name</span><br>    state.<span class="hljs-property">userData</span>.<span class="hljs-property">age</span> = payload.<span class="hljs-property">age</span><br>    state.<span class="hljs-property">userData</span>.<span class="hljs-property">job</span> = payload.<span class="hljs-property">job</span><br><br>    <span class="hljs-comment">// or</span><br>    <span class="hljs-comment">// state.userData = &#123;...payload&#125;</span><br>  &#125;,<br><br>  setCompanyData (state, payload) &#123;<br>    state.<span class="hljs-property">companyData</span>.<span class="hljs-property">name</span> = payload.<span class="hljs-property">name</span><br>    state.<span class="hljs-property">companyData</span>.<span class="hljs-property">address</span> = payload.<span class="hljs-property">address</span><br>    state.<span class="hljs-property">companyData</span>.<span class="hljs-property">job</span> = payload.<span class="hljs-property">job</span><br><br>    <span class="hljs-comment">// or</span><br>    <span class="hljs-comment">// state.companyData = &#123;...payload&#125;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>이렇게 같은 레벨의 state지만 독립적으로 별도로 사용되는 경우가 많은데 이런 경우엔 별개로 초기화해야 하는 경우가 생긴다. 초기화 시에 <code>initData</code>와 같은 방식으로 해도 무방하지만 <code>userData</code>와 <code>companyData</code>의 속성들이 수십 개라면 수없이 초기화 코드가 길어진다. 그렇게 되면 초기화 mutation 하나로 store의 코드 가독성이 현저히 떨어지게 된다. 특히 <code>userData</code>와 <code>companyData</code> 같은 state는 주기적으로 초기화해야 하기 때문에 효율적인 코드가 필요하다. </p><p>이런 경우를 대비하여 <code>userData</code>와 <code>companyData</code>는 애초부터 state에 명시를 할 경우 별도의 <strong>함수로 분리</strong>해 주는 것이 좋다. </p><p>아래 코드를 보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// initialized userData</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">USER_DATA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&#x27;programmer&#x27;</span><br>  &#125;<br>&#125; <br><br><span class="hljs-comment">// initialized companyData</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">COMPANY_DATA</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;company&#x27;</span>,<br>    <span class="hljs-attr">address</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-keyword">void</span> <span class="hljs-number">0</span><br>  &#125;<br>&#125; <br><br><span class="hljs-comment">// state</span><br><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">userList</span>: [],<br>  <span class="hljs-attr">isFlag</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">userData</span>: <span class="hljs-title function_">USER_DATA</span>(),<br>  <span class="hljs-attr">companyData</span>: <span class="hljs-title function_">COMPANY_DATA</span>()<br>&#125;<br><br><span class="hljs-comment">// mutations</span><br><span class="hljs-keyword">const</span> mutations = &#123;<br>  initData (state) &#123;<br>    state.<span class="hljs-property">userList</span> = []<br>    state.<span class="hljs-property">isFlag</span> = <span class="hljs-literal">false</span><br>    state.<span class="hljs-property">userData</span> = <span class="hljs-title function_">USER_DATA</span>()<br>    state.<span class="hljs-property">companyData</span> = <span class="hljs-title function_">COMPANY_DATA</span>()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>  state,<br>  mutations<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드를 보면 <code>userData</code>와 <code>companyData</code>는 객체 상수 형태의 함수로 미리 선언을 하고 state에 해당 함수를 대입하여 초기화하고 있다. 물론 <code>initData</code>에서 다시 초기화 시에 이미 선언된 함수를 통해 초기화를 한다. 앞으로 <code>userData</code>와 <code>companyData</code>를 초기화할 땐 이미 정의된 함수를 쓰면 그만인 것이다. 이런 구조는 특히나 객체 안에 객체를 가진 복잡한 형태의 state를 정의하거나 초기화할 때 효율적이고 가독성도 좋아진다. 우리는 초기화 코드에 신경을 쓸 필요가 없다. 또한 특정 조건에 따른 초기화라면 이미 정의해 놓은 초기화 코드는 함수로 선언되어있기 때문에 인자를 받아 처리할 수 도 있다. </p><hr><p>state를 초기화하는 것은 사실 중요한 부분은 아니다. 초기화하는 것에 문제가 될게 무엇인가. 하지만 대부분 vuex의 store는 모듈별로 선언하게 되고 그 안에는 무수히 많은 state, mutations, actions가 포함된다.(물론 state, mutation, action을 분리할 수도 있다.) 이런 상황에서 작은 단위 하나하나를 지나치지 않고 효율적으로 처리한다면 더 나은 Application을 개발할 수 있을 것이다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2019/04/27/vue-component/">Vue.JS Component 개념을 익히고 만들어보자!!</a><br><a href="https://kdydesign.github.io/2020/11/13/vuejs-provide-inject/">Vue Component provide&#x2F;inject 이해하기</a><br><a href="https://kdydesign.github.io/2021/01/14/vue-eventbus-vs-vuex/">Vuex VS Event Bus</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> nuxt.js </category>
          
          <category> vuex </category>
          
          <category> vuex tutorial </category>
          
          <category> vue.js tutorial </category>
          
          <category> nuxt.js tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</title>
      <link href="/2019/04/10/vuejs-performance/"/>
      <url>/2019/04/10/vuejs-performance/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/04/10/vuejs-performance/cover.png" alt="cover"></p><p>Vue.js에서 대용량 데이터 처리 시에 성능을 최적화하는 방법에 대해 알아보자. 남들은 모르는 Vue.js 성능 개선과 Vue.js에서 대용량 데이터를 처리하는 방법을 배워보자. Vue.js 성능 개선에서 가장 중요한 핵심은 Observe이며, 부가적으로 defineReactive를 이해하여야 하며 나아가 computed와 getter의 사용을 최소한으로 하는 것이다.</p><p>1년간 대규모 프로젝트를 진행하면서 어려운 점이 한 두 가지가 아니다. 그 중 멘탈이 나갈뻔한 <code>Top 1</code>을 뽑자면 역시 <strong>Vue 성능</strong>이었다. 절대적으로 <strong>Vue의 성능이 느리다는 것은 아니다.</strong> Vue는 제 할 일을 다하고도 감탄하게 만드는 프레임워크라는 것에 변함은 없지만, 프로젝트를 진행하면서 수많은 변수가 존재하고 이 변수로 인해서 Vue 성능을 개선해야 되는 경우가 생겼었다. <code>Vue의 성능 최적화는 Vue의 core를 수정하는 것이 아니며, Vue의 반응형에 대해서 깊이 있게 알고 확인해본다면 충분히 해결할 수 있다.</code></p><p>이 포스트에서는 애플리케이션의 하나의 페이지에서 많은 양의 데이터를 표현을 해야 하는 경우 성능이 저하되기 때문에 성능을 높이고자 하는 개발자에게 도움이 되기를 바라며 작성한다.</p><h1 id="진행된-프로젝트-환경"><a href="#진행된-프로젝트-환경" class="headerlink" title="진행된 프로젝트 환경"></a>진행된 프로젝트 환경</h1><p>먼저 위에서 자꾸 프로젝트.. 프로젝트.. 하는데 어느 형태의 프로젝트 또는 어느 상황 속에서 Vue의 성능을 최적 화해야 하는가를 알아야 하므로 조건을 몇 가지 나열한다.</p><div class="alert info no-icon"><ol><li>SPA(Single Page Application)</li><li>빅데이터 처리(10만건의 데이터 출력)</li><li>Server-Side에서 Paging 처리가 아닌 Client 측면서의 Paging 처리</li><li>jQuery 컴포넌트의 사용(데이터 테이블)</li></ol></div><p>1번이야 당연하니 넘어가자…</p><h3 id="빅-데이터-처리"><a href="#빅-데이터-처리" class="headerlink" title="빅 데이터 처리"></a>빅 데이터 처리</h3><p>이 부분부터가 문제가 되기 시작한다. 근무하는 회사의 분야와 진행되는 프로젝트의 특징으로 인해서 한 페이지에서 출력하여 보여줘야 하는 row 데이터는 10만건 정도 된다. 표현은 데이터 테이블 형태로 표현을 해야 한다. 쉽게 보자면… <code>TR 태그의 Element 개수가 최소 10만개</code>를 넘어간다. 당연히 웹에서 표현하기 어렵다. 브라우저가 뻗어버리거나 사용이 불가능할 정도의 성능이 나오기 때문이다.</p><h3 id="Client-페이징-처리"><a href="#Client-페이징-처리" class="headerlink" title="Client 페이징 처리"></a>Client 페이징 처리</h3><p>물론 10만건의 데이터를 한 번에 표현할 수는 있다. <code>Virtual scroll 기법</code>을 사용하여 현재 화면에서 실질적으로 보여지는 row 만 DOM을 생성하고 이후 scrolling 시에 이어서 DOM을 업데이트 (화면에서 사라지는 부분을 삭제하든. 아니면 업데이트를 해주든.) 해 주면 10만 건이든 100만 건이든 생성되는 DOM의 개수는 제한적이다. 최초 기능의 컨셉을 이렇게 잡고 진행을 하였지만, <code>Virtual Scroll을 구현하기 위한 조건에 충족하지 못하기 때문에</code> (모든 TR 태그의 높이는 동일해야 한다.) 페이징 처리를 하는데 특성상 Client 측면에서 페이징 처리를 해야 한다.<br>이 말인즉슨 페이지를 넘길 때마다 API를 통해서 데이터를 조회하는 것이 아닌 최초 모든 데이터를 조회 후 Front-End 측면에서 페이징을 해야 한다는 의미이다.</p><h3 id="jQuery-컴포넌트의-사용"><a href="#jQuery-컴포넌트의-사용" class="headerlink" title="jQuery 컴포넌트의 사용"></a>jQuery 컴포넌트의 사용</h3><p>데이터는 데이터 테이블 형태로 출력하고 데이터 테이블은 Vue가 아닌 jQuery로 구현되어있고 이 jQuery 플러그인을 Vue로 Wrapping 하여 Vue Component로 재생성하였다. 그렇기 때문에 Vue Component로 생성한 데이터 테이블은 Vue의 반응형 대상에 들어가지만, 내부에 있는 jQuery는 Vue의 반응형 대상이 되지 않는다. 즉 데이터가 변경되면 jQuery 내부에서 DOM을 수동적으로 업데이트를 해줘야 한다.</p><hr><p>조건은 위와 같다. Front-End 개발자 입장에서는 뭔 이런 구조가 있나… 싶을 것이지만. 모든 게 내 마음대로 되면 얼마나 좋을까?</p><p>그럼 본론으로 들어가 이러한 환경 속에서 어떻게 성능을 최적화하는지 알아보자.</p><h1 id="JS-Heap-Memory의-최소화"><a href="#JS-Heap-Memory의-최소화" class="headerlink" title="JS Heap Memory의 최소화"></a>JS Heap Memory의 최소화</h1><p>Vue의 성능 최적화를 시키는 방법 결론부터 말하자면 <strong>js heap memory를 최소화</strong>하는 것이다.</p><p>대용량 데이터에 대해 서버 페이징 처리 없이 Front-End 측면에서 처리하기 위해서는 최대한 <code>js heap memory</code>를 낮춰야 한다. js heap memory가 증가하면 할수록 UI 상의 모든 컴포넌트가 느려지고 렌더링 역시 느려진다.</p><p>메모리가 증가하는 이유는 무언가가 읽고 쓰고 하는 행위를 할 때 증가한다고 볼 수 있다. 변수를 선언할 때에도, <strong>객체의 속성을 읽거나 수정</strong>할 때도 증가한다. 이렇게 증가한 메모리는 Garbage Collect에 의해 주기적으로 불필요하게 잡힌 메모리를 해제하여 메모리를 확보하는데 그렇지 않고 계속 쌓이는 경우가 있다. 이럴 경우 일반적으로는 메모리 누수로 판단한고 적절한 조치를 진행한다. 메모리 누수에 대한 몇 가지 조치방법이다.</p><blockquote><ul><li>전역 변수의 사용</li><li>타이머와 콜백</li><li>외부에서의 참조</li><li>Closures의 사용</li></ul></blockquote><p>자세한 내용은 검색을 통해 확인해 보기 바란다.</p><p>Vue에서는 이 내용도 중요하지만 가장 중요한 것은 위에서 언급한 <strong>객체의 속성을 읽거나 수정</strong> 항목이다.</p><p>Vue는 data, state, computed, getters와 같은 모델이 선언되면 <code>defineReactive</code>를 통해 해당 객체는 반응형 관리 대상으로 등록되어 반응적으로 변경이 되는데 이 과정에서 각 개체마다 <code>Observe</code> 생성되고 내부적으로 getter&#x2F;setter가 생성된다. 실제로 모델의 데이터를 열어보면 <code>__Ob__</code>이 붙은 것을 확인할 수 있다.</p><p>생각해보자 10만건에 대해서 객체가 반응형이라면 개체 1개마다 getter&#x2F;setter가 생성될 것이다. 10만개의 데이터가 단순 배열이 아닌 객체구조라면?? 10만건에 대해 이러한 과정을 거치는 것이(memory write) js heap memory의 증가 이유가 된다.</p><p>-p.s 이 부분이 항상 문제가 되는 것은 아니다. 하지만 데이터가 많을 때는 고려하는 것이 좋을 것으로 보인다.-</p><p><strong>그래서 가장 중요한 것은 대용량의 데이를 가지고 있는 모델은 Vue의 반응형 관리대상에서 제외를 시키는 것이다.</strong></p><h2 id="모델에-대한-가공은-최소화"><a href="#모델에-대한-가공은-최소화" class="headerlink" title="모델에 대한 가공은 최소화"></a>모델에 대한 가공은 최소화</h2><p>API를 통해서 데이터를 조회하고 Model 또는 State에 담아 놓는 게 일반적이다. 하지만 API를 통해 조회된 데이터가 실제로 화면에서는 다른 형태의 데이터로 표현해야 하는 경우가 있을 것이다.</p><p>예를 들면 use라는 속성값이 0&#x2F;1 또는 true&#x2F;false로 올 경우 Front-End 개발자들은 사용&#x2F;미사용과 같은 형태로 출력해야 하는데 이러한 데이터 가공은 computed나 watch 또는 Store의 getters를 이용한다.</p><p>하지만 대용량 데이터를 가져야 하는 모델에 대해서는 최대한 데이터를 가공하지 말아야 한다. 이는 computed를 최소화하고 getters를 최대한 사용하지 말아야 한다는 말과 같다. 위에서 반응형에서 언급했듯이 모델이 반응 적이라면 그만큼 js heap memory를 차지하기 때문이다.</p><h2 id="모델에-대한-반응형-제거"><a href="#모델에-대한-반응형-제거" class="headerlink" title="모델에 대한 반응형 제거"></a>모델에 대한 반응형 제거</h2><p>해결방법은 단순하다. 대용량 데이터를 가진 모델에 대해 Vue의 감지 대상에서 제거하면 된다. 즉 <code>Observe가 생성되지 않게 처리하면 되는데 이는 vue의 관점에 처리해야 한다.</code></p><h3 id="Object-freeze-사용"><a href="#Object-freeze-사용" class="headerlink" title="Object.freeze() - 사용"></a>Object.freeze() - 사용</h3><p>이를 해결하기 위해서는 대용량 데이터를 가지고 있는 model 또는 state에 대해서 <code>Object.freeze()</code>를 사용하여 처리한다. <code>Object.freeze()</code>는 해당 객체를 <strong>read only로 처리를 하기 때문에 이 객체에 대해서는 속성을 추가할 수도 없고 제거할 수도 없으며, 수정할 수도 없다.</strong> 또한 해당 객체에 대한 프로토타입 역시 변경할 수 없다. 이렇게 순수하게 read only 객체로 되기 때문에 vue에서도 감지의 대상이 되지 않는다.</p><p><code>Object.freeze()</code>를 사용해야 하는 시점은 API를 통해 데이터를 조회 후 state에 매핑할 때 진행하면 된다</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//state</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> state = &#123;<br>    <span class="hljs-attr">bookList</span>: []<br>&#125;<br><br><span class="hljs-comment">// mutations</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutations = &#123;<br>    setBookList (state, payload) &#123;<br>        state.<span class="hljs-property">bookList</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(payload)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// actions</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> actions = &#123;<br>    getBookList (&#123;commit&#125;) &#123;<br>        <span class="hljs-comment">// API call</span><br>        <span class="hljs-comment">// ...</span><br>        <br>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setBookList&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Object-freeze-수정"><a href="#Object-freeze-수정" class="headerlink" title="Object.freeze() - 수정"></a>Object.freeze() - 수정</h3><p>하지만 위에서 언급한 바와 같이 <code>Object.freeze()</code>를 사용하게 되면 해당 객체는 변경이 불가능하기 때문에 기능상 CRUD의 행위들은 모두 불가능하게 된다. 이 부분은 객체를 복사하는 방향으로 진행할 수 있으며, 객체를 복사한다 하더라고 기존에 증가되는 메모리 양보다는 비용이 적게든다. 중요한 것은 복제된 객체는 전혀 다른 객체가 되므로 <code>Object.freeze()</code>의 대상이 되지 않으며 (map의 경우 동일) 변경이 가능하게 되지만 최종적으로는 다시 <code>Object.freeze()</code>로 vue의 감지 대상에서 제거해야한다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//state</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> state = &#123;<br>    <span class="hljs-attr">bookList</span>: []<br>&#125;<br><br><span class="hljs-comment">// mutations</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutations = &#123;<br>    addBookList (state, boolList) &#123;<br>        <span class="hljs-comment">// lodash clone</span><br>        <span class="hljs-keyword">let</span> cloneBookList = _.<span class="hljs-title function_">cloneDeep</span>(bookList)<br><br>        cloneBookList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;add book&#x27;</span>, <span class="hljs-attr">date</span>: <span class="hljs-string">&#x27;2019-04-08&#x27;</span>&#125;)<br><br>        state.<span class="hljs-property">bookList</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(cloneBookList)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Object-freeze-Array-prototype-map"><a href="#Object-freeze-Array-prototype-map" class="headerlink" title="Object.freeze - Array.prototype.map"></a>Object.freeze - Array.prototype.map</h3><p>배열 또는 Collection의 경우 map을 통해 객체를 확장, 수정을 진행하게 되는데 map의 경우 clone과 같이 유사한 패턴을 가질 수 있기 때문에(배열을 새로운 배열 요소로 변경) clone을 사용하지 않는 범위에서 위와 같은 절차대로 진행하며, map의 return 자체를 <code>Object.freeze()</code>로 처리한다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//state</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> state = &#123;<br>    <span class="hljs-attr">bookList</span>: []<br>&#125;<br><br><span class="hljs-comment">// mutations</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutations = &#123;<br>    addBookList (state, boolList) &#123;<br>        <span class="hljs-comment">// lodash map</span><br>        <span class="hljs-keyword">let</span> cloneBookList = bookList.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">book</span> =&gt;</span> book.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;kdydesign&#x27;</span>)<br><br>        state.<span class="hljs-property">bookList</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(cloneBookList)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>그 간 웹 Front-End 개발을 하면서 항상 부닥치는 문제는 성능이었다. 대부분이 메모리 누수로 인한 문제였지만 이번만은 좀 다른 형태였던 것 같다. Vue의 겉핥기식으로 배워 프로젝트에 도입하고 1년간 진행하면서 크게 배운 것 하나가 또 이 내용이다. <code>Object.freeze()</code> 사용이 어떻게 보면 비효율적일 수 있을 것이다. 객체를 read only로 변환을 하지만 CRUD의 루틴을 위해 다시 Vue의 감지대상으로 바꾼 후 또다시 <code>Object.freeze()</code>를 통해 read only로 변환한다는 것이.. 좀 더 파고들고 노하우가 더 쌓이면 더욱더 좋은 루틴으로 성능을 최적화하는 방법이 떠오른다면 그때 가서 이 포스트는 수정할 것이다. 그때까지는 이 방법으로 해결하는 것이 좋을 듯하다.</p><p>다음 포스트에는 성능 측정 방법에 대해 올려 볼 예정이다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vue-store-state/">Vuex Store의 state를 효율적으로 초기화하기</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2019/04/27/vue-component/">Vue.JS Component 개념을 익히고 만들어보자!!</a><br><a href="https://kdydesign.github.io/2020/11/13/vuejs-provide-inject/">Vue Component provide&#x2F;inject 이해하기</a><br><a href="https://kdydesign.github.io/2021/01/14/vue-eventbus-vs-vuex/">Vuex VS Event Bus</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> nuxt.js </category>
          
          <category> vue.js tutorial </category>
          
          <category> nuxt.js tutorial </category>
          
          <category> vue.js performance </category>
          
          <category> vue.js big data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> vue.js performance </tag>
            
            <tag> vue.js big data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] Vuex Store를 바인딩하는 4가지 방법!!</title>
      <link href="/2019/04/06/vuejs-vuex-helper/"/>
      <url>/2019/04/06/vuejs-vuex-helper/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2019/04/06/vuejs-vuex-helper/cover.png" alt="cover"></p><p>Vue.js의 Vuex Store 패턴에서 Vue.js Component에 Store를 바인딩 시키는 여러가지 방법을 알아보자. Vuex의 Store를 Component에 바인딩하는 방법에는 여러가지가 있으며 상황에 따라 그 쓰임이 다르다. 그 중에서 가장 실무에 적합하고 가독성이 좋은 방법이 무엇인지 알아보고 활용해보자.</p><p>해당 포스트에서는 Vuex의 설명과 사용법에 대해서는 언급하지 않았으며, 오로지 Vuex Store를 컴포넌트에 바인딩하는 방법을 설명한다.</p><p>프로젝트의 규모가 크거나 작든 <code>Vuex를 사용할 때는 Store를 Module 별로 분리</code>하는 것이 바람직하다. 그렇지 않으면 각 컴포넌트마다 바인딩 된 Store의 state들이 다른 컴포넌트의 루틴에 의해 오염될 가능성과 코드의 복잡성이 높아지게 되어 있다. </p><p>이번 포스트에서는 모듈별로 분리된 Store를 각 컴포넌트에서 효율적으로 바인딩시키는 여러 가지 방법들과 코드 스타일을 알아보자.</p><h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><p>Vue 공식 API에서는 명시된 기본 Store 바인딩 방법이다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;mapState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">computed</span>: <span class="hljs-title function_">mapState</span>(&#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span>,<br>        <span class="hljs-attr">countAlias</span>: <span class="hljs-string">&#x27;count&#x27;</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>위 내용은 <code>mapState</code>라는 Helper를 이용하여 객체의 형태로 <code>count</code>를 바인딩 한 형태이고 아래처럼 state의 이름을 그대로 상속받아 정의할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;mapState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">computed</span>: <span class="hljs-title function_">mapState</span>([<br>        <span class="hljs-string">&#x27;count&#x27;</span><br>    ])<br>&#125;)<br></code></pre></td></tr></table></figure><p>기본적인 바인딩 방법은 가장 단순한 구조를 가진 Store를 바인딩하였을 때이다. 하지만 Store가 여러 모듈별로 분리되어 있고 하나의 컴포넌트에서는 여러 Store 모듈을 바인딩해야 한다면 매우 복잡해질 것이다.</p><p>아래 가정을 가지고 각 바인딩 Style을 살펴보자.</p><div class="alert danger no-icon"><p>각각 <strong>User</strong>, <strong>Book</strong> 이라는 Store 모듈이 존재하고, <strong>User</strong>는 <code>A/B</code> 경로에 있으며, <strong>Book</strong>은 <code>A/B/C</code> 경로에 위치한다.</p></div><p>프로젝트 구조는 다음과 같다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">└─ A<br>   └─ B<br>      ├─ User<br>      └─ C<br>         └─ Book<br></code></pre></td></tr></table></figure><h1 id="Style-1-Vuex-Helper"><a href="#Style-1-Vuex-Helper" class="headerlink" title="Style 1 - Vuex Helper"></a>Style 1 - Vuex Helper</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;mapState, mapActions&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        ... <span class="hljs-title function_">mapState</span>(&#123;<br>            <span class="hljs-attr">bookList</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">A</span>.<span class="hljs-property">B</span>.<span class="hljs-property">C</span>.<span class="hljs-property">Book</span>.<span class="hljs-property">list</span><br>        &#125;)<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        ...<span class="hljs-title function_">mapActions</span>([<br>            <span class="hljs-string">&#x27;A/B/C/Book/setList&#x27;</span><br>        ])<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>또는</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;mapState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        ... <span class="hljs-title function_">mapState</span>(<span class="hljs-string">&#x27;A/B/C/Book&#x27;</span>, &#123;<br>            <span class="hljs-attr">bookList</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">list</span><br>        &#125;)<br>    &#125;,<br>     <span class="hljs-attr">methods</span>: &#123;<br>        ...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&#x27;A/B/C/Book&#x27;</span>, [<br>            <span class="hljs-string">&#x27;setList&#x27;</span><br>        ])<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>특정 경로에 포함된 Store 모듈을 사용하기 위해서는 해당 경로를 모두 명시해줘야 한다. 이렇게 사용을 한다면 어느 경로에 있든 서로 다른 Store 모듈을 하나의 컴포넌트 또는 여러 컴포넌트에서 바인딩하여 사용이 가능하다. 하지만 위 예제에서 A&#x2F;B&#x2F;C의 단순하고 짧은 명칭이지만 폴더나 Store 모듈의 명칭이 꽤나 길다면 역시나 가독성이 좀 떨어질 것이다. 그래서 우리는 Vuex에서 제공하는 Namespace Helper를 생성할 수 있는 <code>createNamespacedHelpers</code> 이용하여 바인딩하는 것을 가장 인상적으로 볼 수 있다.</p><h1 id="Style-2-createNamespacedHelpers-1"><a href="#Style-2-createNamespacedHelpers-1" class="headerlink" title="Style 2 - createNamespacedHelpers 1"></a>Style 2 - createNamespacedHelpers 1</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">const</span> &#123;mapState&#125; = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;A/B/C/Book&#x27;</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        ... <span class="hljs-title function_">mapState</span>(&#123;<br>            <span class="hljs-attr">bookList</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">list</span><br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>또는</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">const</span> &#123;mapState&#125; = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;A/B/C/Book&#x27;</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        ... <span class="hljs-title function_">mapState</span>([<br>            <span class="hljs-string">&#x27;list&#x27;</span><br>        ])<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>모듈의 이름이 길고 구조가 복잡하다면 <code>createNamespacedHelpers</code>를 사용하여 바인딩한다면 computed 또는 methods가 간결하고 뛰어난 가독성을 보이는 것을 알 수 있다.</p><p>Store 모듈들의 경로를 computed와 methods에 정의를 안 했을 뿐이지 무엇이 다르겠냐고 한다면 생각해보자. 우리는 개발을 하면서 코드를 살펴볼 때나 구현을 할 때 가장 상단에 삽입하거나 명시해 놓은 구현체는 자주 보지 않는다. 오히려 data, computed, methods를 가장 많이 볼 것이다. 이러한 상황에서 수많은 모듈의 경로가 명시되어 있다면 state나 mutation, action의 개체들을 찾기 어려울 것이다.</p><h1 id="Style-3-createNamespacedHelpers-2"><a href="#Style-3-createNamespacedHelpers-2" class="headerlink" title="Style 3 - createNamespacedHelpers 2"></a>Style 3 - createNamespacedHelpers 2</h1><p>그러면 여기서 좀 더 깊이 한번 보자.</p><p>만약 <code>createNamespacedHelpers를</code> 사용을 한다고 하지만 만약 하나의 컴포넌트에 서로 다른 경로에 있는 Store 모듈을 여러 개 바인딩할 경우에는 어떻게 해야 할까?<br>지금까지 <code>Book</code>이라는 모듈만을 가지고 예제를 보았지만, 여기에서 <code>User</code> 모듈을 추가해보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">const</span><br>    &#123;<span class="hljs-attr">mapState</span>: userMapState, <span class="hljs-attr">mapActions</span>: userMapActions&#125; = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;A/B/User&#x27;</span>),<br>    &#123;<span class="hljs-attr">mapState</span>: bookMapState, <span class="hljs-attr">mapActions</span>: bookMapActions&#125; = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;A/B/C/Book&#x27;</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        ... <span class="hljs-title function_">userMapState</span>(&#123;<br>            <span class="hljs-attr">userList</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>.<span class="hljs-property">userList</span><br>        &#125;),<br>        ... <span class="hljs-title function_">bookMapState</span>([<br>            <span class="hljs-string">&#x27;list&#x27;</span><br>        ])<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        ...<span class="hljs-title function_">userMapActions</span>(&#123;<br>            <span class="hljs-attr">setUserList</span>: <span class="hljs-string">&#x27;setUserList&#x27;</span><br>        &#125;),<br>        ...<span class="hljs-title function_">bookMapActions</span>([<br>            <span class="hljs-string">&#x27;setBookList&#x27;</span><br>        ])<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>아래처럼 정의도 가능하다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">const</span><br>    userListHelper = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;A/B/User&#x27;</span>),<br>    bookListHelper = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;A/B/C/Book&#x27;</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        ... userListHelper.<span class="hljs-title function_">mapState</span>(&#123;<br>            <span class="hljs-attr">userList</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>.<span class="hljs-property">userList</span><br>        &#125;),<br>        ... bookListHelper.<span class="hljs-title function_">mapState</span>([<br>            <span class="hljs-string">&#x27;list&#x27;</span><br>        ])<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        ...userListHelper.<span class="hljs-title function_">mapActions</span>(&#123;<br>            <span class="hljs-attr">setUserList</span>: <span class="hljs-string">&#x27;setUserList&#x27;</span><br>        &#125;),<br>        ...bookListHelper.<span class="hljs-title function_">mapActions</span>([<br>            <span class="hljs-string">&#x27;setBookList&#x27;</span><br>        ])<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>이렇게 한다면 하나의 컴포넌트에서도 많은 모듈을 바인딩하기가 쉬우며, 코드의 가독성 역시 좋아진다.</p><hr><p>각 개발자마다 코드 스타일은 모두 다르고 해당 포스트에 언급한 내용 이외에 더 좋은 방법이 있을 수 있다. 다만 중요한 것은 개발하기 전 또는 하면서 어느 방법이 가장 좋은지 몸소 느끼며 차근차근 수정해 나아가는 것이 중요하다고 본다. 어느 스타일이든 결과는 같겠지만 업무&#x2F;개발의 속도는 확연히 차이가 날 것이다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/10/vue-store-state/">Vuex Store의 state를 효율적으로 초기화하기</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2019/04/27/vue-component/">Vue.JS Component 개념을 익히고 만들어보자!!</a><br><a href="https://kdydesign.github.io/2020/11/13/vuejs-provide-inject/">Vue Component provide&#x2F;inject 이해하기</a><br><a href="https://kdydesign.github.io/2021/01/14/vue-eventbus-vs-vuex/">Vuex VS Event Bus</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> vue.js tutorial </category>
          
          <category> vuex tutorial </category>
          
          <category> vuex helper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> vuex </tag>
            
            <tag> vue.js tutorial </tag>
            
            <tag> vuex component binding </tag>
            
            <tag> store </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Vue.JS] 빠르게 배우는 Vue.js</title>
      <link href="/2017/11/15/vuejs-tutorial/"/>
      <url>/2017/11/15/vuejs-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/11/15/vuejs-tutorial/cover.png" alt="cover"></p><p>한창 상승 중인 Front-End를 위한 JavaScript Framework인 Vue.js를 시작하기 앞서 먼저 Vue.js에 대해 알아보고 개념을 잡고 시작하자.</p><p>이번 프로젝트를 위해 2시간의 세미나를 걸쳐 Vue.js 약(?)을 팔았다. 다행히 결과가 좋아 기존에 Survey 된 프레임워크인 <code>Backbone.js</code>를 <code>Vue.js</code>로 변경하기로 하였다. 물론 Backbone.js가 Vue.js보다 못하다는 말이 아니다. 앞으로 진행되어야 할 프로젝트에서 컴포넌트 방식의 개발 요소가 매우 필요하였고, 이러한 구성을 Backbone.js로 프로토타입을 구현하니 막상 복잡함 감이 없지 않았다. 이에 따라 다른 기술을 survey하다 Vue.js를 채택하게 되었다. 한창 상승 중인 프레임워크인지라 물론 여러 번 지나가다 보기만 하였지만 이번에 제대로 접근해 보니 매우 진보적이고 훌륭한 프레임워크라고 생각이 들어 포스팅하게 되었다.</p><p>그럼 먼저 <code>Vue.js</code>에 대해 기본적인 개념부터 알아보고 다음 포스팅부터 실제로 만져 보면서 학습해보자.</p><h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p><a href="https://kr.vuejs.org/">Vue.js 공식 사이트</a>에 접속해 보면 첫 페이지에 딱 3글자로 요약을 해 놓았다.</p><div class="alert info no-icon"><ul><li>Approachable(접근성)</li><li>Versatile(유연성)</li><li>Performant(고성능)</li></ul></div><p>단어만 보아도 대강 유추는 가능하다. JavaScript 프레임워크로 HTML, CSS, JavaScript를 알고 있다면 가이드를 통해 충분히 빠른 시간내에 습득이 가능하며, 작은 용량으로 빠른 <code>Virtual DOM</code>을 제공한다. 다른 의미로 Vue.js를 본다면 다음과 같을 것이다.</p><div class="alert info no-icon"><ul><li>View를 위한 JavaScript 프레임워크</li><li>사용자 인터페이스를 만들기 위한 진보적인 프레임워크</li><li>MVVM 디자인 패턴에서 영감을 얻은 프레임워크</li></ul></div><h1 id="추이"><a href="#추이" class="headerlink" title="추이"></a>추이</h1><p>JavaScript Web Front-End Framework는 무수히 많다. 그중 가장 활성화되어 있고 많이 사용하는 대표적인 프레임워크에는 <code>Angular.js</code>와 <code>React.js</code>가 있다. 이 두 프레임워크에 비한다면 Vue.js는 아직 갈길이 멀다. 하지만 전체적으로 본다면 그렇지만 최근의 기록을 본다면 Vue.js가 곧 Angular.js와 React.js 앞지를 가능성이 보인다는 것을 알 수 있다.</p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1173_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"Vue.js","geo":"","time":"today 5-y"}],"category":0,"property":""}, {"exploreQuery":"date=today 5-y&q=Vue.js","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><p>또한, <a href="https://risingstars2016.js.org/?ref=freecodecamp-loves-you#all">Most Popular Projects in 2016</a>에서 확인해 보면 2016년도에 Github에서 star를 받은 수가 월등히 Vue.js가 높다는 것을 알 수 있을만큼 상승 중에 있다.(해당 내용은 <a href="https://velopert.com/3007">VELOPERT.LOG</a>의 포스트를 참조하였습니다.)</p><h1 id="사용성"><a href="#사용성" class="headerlink" title="사용성"></a>사용성</h1><p>어느 프로젝트이든 또는 어떤 제품이든 그 결과적인 솔루션이 어떤 프레임워크를 사용하였는지는 알기 어렵다. 물론 해당 담당자나 개발자가 공표하지 않는다는 조건에서 말이다. 그래서 우리는 현재 널리 분포되어있는 웹 중 얼마나 Vue.js가 적용되었는지는 수치상 알 수 없지만 다른 방법으로 유추가 가능하다. 이에 대한 답을 먼저 보고 가자.</p><div class="alert info no-icon"><ul><li>stackoverflow 질문 수 - <strong>약 20,890</strong></li><li>npm 다운로드 수 - <strong>약 1,219,567</strong></li><li>github 이슈 - <strong>약 82</strong></li></ul></div><p>우리는 <code>StackOverflow</code> 에 등록된 질문 수와 <code>NPM의 다운로드 수</code> 그리고 <code>Vue.js의 github에 올라와 있는 이슈의 수</code>를 통해 얼마나 활성화가 되어 있는지 감을 잡을 수 있다. 이런 내용을 포스팅에 추가한 이유는 아무래도 Vue.js의 도입을 망설이는 개발자 또는 담당자 또는 기획자가 있을 수 있기 때문이다. 아무리 상승 중인 프레임워크라고는 하나 이에 대한 정보가 부족하다면 우리는 개발을 하면서 큰 난관에 자주 봉착 될 것이다. 그렇기에 이렇게 대강이나마 도움이 되었으면 하는 바램으로 수치상의 데이터를 남겨본다. </p><p>또한 눈치가 빠른 사람이라면 알 수 있을 것이다. github에 등록된 이슈의 수에 대해 말이다. <a href="https://npmcompare.com/compare/angular,react,vue">NPMCompare</a>에서 Angular와 React를 본다면 각각 등록된 이슈의 수는 약 700건과 400건이다. 이에 비해 Vue.js는 약 80건 밖에 되지 않는다. 직관적으로 본다면 그만큼 Vue.js의 사용자가 Angular.js나 React.js보다 매우 적다라는 것으로 볼 수 있지만 또 다른 관점으로 본다면 등록된 이슈의 건수가 낮은 Vue.js는 그만큼 안정적이란 말이 될 수 있다.</p><p>개인적으로 생각해보건데 프레임워크의 개발 규모 관점에 보았을 때 Angular.js나 React의 경우 각각 Google과 Facebook이라는 매우 규모가 큰 타이틀이 붙는 반면 Vue.js는 Evan You라는 단일 개발자가 개발이 되었다. 규모의 차이가 매우 크지만 전혀 Vue.js가 밀리지 않는다고 생각된다.</p><h1 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h1><p>Vue.js의 특징을 몇가지 꼽아 보자면 다음과 같을 수 있다.</p><div class="alert info no-icon"><ul><li>MVVM 패턴에서 영감을 받아 개발</li><li>Virtual DOM의 사용</li><li>Learning curve가 낮음</li><li>Angular.React에 비해 매우 작고 가벼우며 복잡도가 낮음</li><li>Template과 Componenet를 사용하여 재사용이 가능한 사용자 인터페이스를 묶고 View Layer를 정리</li><li>Model을 통한 양방향 데이터 바인딩을 동하게 제공하지만 Component간 통신의 기본틀은 단방향(부모-&gt;자식)</li><li>Server side Rendering 지원</li></ul></div><p>Vue.js를 대강 아는 사람들이고 들어본 사람들은 이렇게도 들어보았을 것이다. <code>angular + react = vue</code>. 맞는 말이기는 하다. angular의 지시자(Directive)가 있을 뿐더라 react와 같이 <code>Virtual DOM</code>을 제공한다. </p><p>그렇다면 이렇게 장점만 합쳐 놓았다면 다른 프레임워크와 다른점이 무엇인가?<br>그것은 해당 공식 사이트에서 확인 할 수 있다. Vue.js 개발 팀은 편견을 버리고 객관적으로 Vue.js와 Angular.js, React.js 그리고 Ember.js와 같은 여러 프레임워크를 비교해 놓았다. 해당 내용은 <a href="https://kr.vuejs.org/v2/guide/comparison.html">다른 프레임워크와의 비교</a>에서 확인 할 수 있다.</p><hr><p>무엇인가 Vue.js에 대해 설명 포스팅을 하자고 생각했을 때는 거창하게 글을 써보려하였지만 막상 그렇게 하려니 마음대로 되지 않는다. 글을 아무리 설명을 해도 실제로 피부로는 와 닿지 않기 때문이다. 그래서 해당 Vue.js의 소개 포스팅은 짧게 가보고 이어지는 Tutorial을 길게 가볼 생각이다.</p><p>현재 Vue.js를 사내에 도입하여 앞으로 진행된 차기 제품(프로젝트라고 하기 보다 Vendor사이기에..)의 UI는 Vue.js로 가기로 하였고 기존에 jQuery와 Backbone으로 만들어 놓은 여러 Component를 Vue.js로 Converting 하고 있는데 훌륭하다. 훌륭하다. 매우 훌륭하다라고 자꾸 느껴지는 Vue.js이다. 오래만에 개발을 하면서 설레이고 흥분되는 느낌을 받는다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a><br><a href="https://kdydesign.github.io/2019/04/22/vue-cli3-tutorial/">Vue-CLI 3 시작하기</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vue-store-state/">Vuex Store의 state를 효율적으로 초기화하기</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2019/04/27/vue-component/">Vue.JS Component 개념을 익히고 만들어보자!!</a><br><a href="https://kdydesign.github.io/2021/01/14/vue-eventbus-vs-vuex/">Vuex VS Event Bus</a><br><a href="https://kdydesign.github.io/2020/11/13/vuejs-provide-inject/">Vue Component provide&#x2F;inject 이해하기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> nuxt.js </category>
          
          <category> vue.js tutorial </category>
          
          <category> nuxt.js tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 완전정복하기!!</title>
      <link href="/2017/11/04/webpack-tutorial/"/>
      <url>/2017/11/04/webpack-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/11/04/webpack-tutorial/cover.png" alt="cover"></p><p>지금까지 우리는 <a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a> 포스트에서 webpack에 대한 기본 개념을 먼저 살펴보았다. 왜 webpack이 많이 사용되는지와 <code>Gulp</code>와의 차이점을 알았다면 이제 실제로 webpack을 설치해보고 사용해 보면서 하나하나 짚어나가 보자. <strong>이 포스트에 올린 예제들은 <a href="https://webpack.js.org/">webpack 공식 사이트</a>들의 예제를 포함하고 있다.</strong></p><h1 id="Webpack-설치-및-Build"><a href="#Webpack-설치-및-Build" class="headerlink" title="Webpack 설치 및 Build"></a>Webpack 설치 및 Build</h1><p>webpack은 npm으로 쉽게 설치할 수 있다. 만약 이 포스트를 보는 당신은 npm이 무엇인지 모른다면 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a> 포스트를 참고하자. 자! 이제 설치를 해보자. 먼저 적당한 경로에 <code>Webpack_Project</code>라는 이름의 프로젝트 폴더를 생성하고 해당 폴더에서 명령 프롬프트를 실행하여 <code>webpack</code>을 설치하자.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm init -y<br>npm install webpack webpack-cli -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn init -y<br>yarn add webpack webpack-cli --dev<br></code></pre></td></tr></table></figure><p>먼저 <code>npm init -y</code>를 통해 package.json을 생성하고 <code>npm install webpack webpack-cli webpack-dev-server --save-dev</code>명령을 통해 webpack을 설치하면서 동시에 package.json에 적용하였다. 실제로 webpack의 설치는 이것으로 끝이다. 우리는 항상 설치가 정상적으로 됐는지 확인은 버전으로 확인을 한다. 확인해보자.</p><div class="alert info no-icon"><p>Webpack 4에서는 <code>webpack</code>과 <code>webpack-cli</code>를 같이 설치해줘야한다.</p></div><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">webpack -v<br></code></pre></td></tr></table></figure><p>버전이 출력된다면 정상적으로 설치가 완료된 것이다.</p><h2 id="CLI를-사용한-Build"><a href="#CLI를-사용한-Build" class="headerlink" title="CLI를 사용한 Build"></a>CLI를 사용한 Build</h2><p>가장 기초적인 방법으로 <code>webpack cli</code>명령어를 통해 javascript를 build 해 보자. 테스트에 필요한 파일은 <code>index.js</code>와 <code>index.html</code>이다. webpack 4에서는 기본 경로가 <code>src</code>로 되어 있기 때문에 이전과는 다르게 <code>src</code>경로가 존재해야한다. </p><p><code>src</code>디렉토리를 하나 생성하고 하위에 <code>index.js</code>와 <code>index.html</code>을 생성하자. </p><p><strong>src&#x2F;index.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br>  element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;Hello Webpack!!&#x27;</span><br><br>  <span class="hljs-keyword">return</span> element<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>())<br></code></pre></td></tr></table></figure><p><strong>src&#x2F;index.html</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../dist/bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>코드는 간단하다. <code>Hello Webpack!!</code>이라는 문구를 출력할 뿐이다. 그런데 html에서는 조금 다르다. 먼저 .js파일을 불러오는 것은 이해가 되지만 우리가 만든 파일은 <code>index.js</code>인데 왠 <code>../dist/bundle.js</code>라는 파일을 호출하였을까. 일단 궁금증은 접어두고 webpack을 통해 build를 해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">webpack --output dist/bundle.js --mode=development<br></code></pre></td></tr></table></figure><p>여기서 <code>bundle.js</code>가 나왔다. 대강 이해가 가는가? 우리는 위에 있는 cli를 통해 <code>index.js</code>를 <code>../dist/bundle.js</code>로 build 한 것이다. 그렇기 때문에 <code>index.html</code>에서는 처음에는 존재하지는 않지만, build 후에 생성 될 <code>../dist/bundle.js</code>를 호출한 것이다. 비록 지금은 코드나 그 프로젝트 구조가 복잡하지 않기 때문에 별 느낌이 없을지 모르겠지만 이 포스트를 끝까지 읽는다면 어느 정도 감이 올 것이다.</p><h2 id="config를-사용한-Build"><a href="#config를-사용한-Build" class="headerlink" title="config를 사용한 Build"></a>config를 사용한 Build</h2><p>cli를 통한 build는 단순한 구조의 파일을 build 하기에는 편하지만 실제로 우리가 어떤 프로젝트에 임하면 그 프로젝트는 <code>절.대.로</code> 간단한 구조로 되어 있지 않다. build 시에 더욱 부가적인 요소들을 요구하며 이 요소들을 통하여 build를 하게 된다. 이렇게 복잡한 build의 경우 webpack에서는 어떤 특정한 설정 파일에 build에 필요한 요소들을 나열하고 해당 설정 파일을 통해 build를 진행하게끔 지원한다.</p><p>먼저 <code>Webpack_Project</code> 경로에 <code>webpack.config.js</code>라는 javascript 설정 파일을 만들고 간단한 설정부터 진행하자.</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>이렇게 작성된 설정 파일은 webpack 명령어를 통해 실행할 수 있다. (물론 실행 시에는 해당 디렉토리 경로에서 실행하자.)</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">webpack --mode=development<br></code></pre></td></tr></table></figure><p>결과는 <code>webpack cli</code>명령어를 통하여 build 한 내용과 동일하지만 <code>bundle.js</code>의 생성 위치가 다르다. 하나씩 살펴보자. </p><div class="alert info no-icon"><ul><li><strong>path</strong> - 파일의 경로를 다루고 변경하는 유틸리티</li><li><strong>output</strong> - build 결과를 저장할 경로</li><li><strong>entry</strong> - build의 대상이 될 파일</li></ul></div><p>처음 우리가 webpack cli를 통해 build 할 때는 build 될 대상과 build 된 파일을 명시해줬지만 여기서는 그저 webpack 이라는 단순한 명령어를 사용하였다. 그 이유는 우리가 webpack의 설정을 정의한 <code>webpack.config.js</code>를 생성하였고 이 파일은 webpack 명령어의 기본 파일이기 때문이다. 만약 우리가 설정파일이 <code>webpack.config.js</code>가 아닌 <code>webpack.build.js</code>와 같은 다른 파일로 정의를 하였다면 아래와 같은 명령어를 통해 실행 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">webpack --config webpack.build.js<br></code></pre></td></tr></table></figure><h1 id="Loader-사용하기"><a href="#Loader-사용하기" class="headerlink" title="Loader 사용하기"></a>Loader 사용하기</h1><p>우리는 이전 포스트인 <a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a>에서 <code>webpack은 크게 Entry, Output, Loader, Plug-In 이 4가지로 나눌 수 있다.</code> 라고 하였다. 이미 앞서 webpack을 설치하고 build 해 보면서 <code>entry</code>와 <code>output</code>이 무엇인지 대강 감을 잡았으니 이제 파일을 사전 처리하여 정적인 리소스들을 javascript와 같이 하나의 bundle로 만들 수 있는 <code>Loader</code>를 알아보자.</p><h2 id="style-loader-css-Loader"><a href="#style-loader-css-Loader" class="headerlink" title="style-loader, css-Loader"></a>style-loader, css-Loader</h2><p><code>style-loader</code>와 <code>css-loader</code>는 같이 사용되며 <code>style-loader</code>는 <code>&lt;style&gt;</code>태그를 삽입하여 CSS를 추가해주는 역할을 한다. 모든 설치는 npm을 통해 설치를 진행한다.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install style-loader css-loader -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add style-loader css-loader --dev<br></code></pre></td></tr></table></figure><p>설치가 완료되었으면 <code>webpack.config.js</code>에 <code>style-loader</code>와 <code>css-loader</code>를 정의하자.</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          <span class="hljs-string">&#x27;style-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span><br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>loader는 <code>module</code>에 추가해주며, 정규식(test)을 통해 loader가 인식될 파일을 잡아준다. 그리고 어떤(use) loader를 사용하는지 정의해 주면 된다. 이제 <code>style.css</code>파일을 추가하고 <code>index.js</code>파일을 수정하자.</p><p><strong>style.css</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.hello</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>index.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./style.css&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br>  element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;Hello Webpack!!&#x27;</span><br>  element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br>  <span class="hljs-keyword">return</span> element<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>())<br></code></pre></td></tr></table></figure><p>우선 추가된 코드는 <code>hello</code>클래스와 이 클래스를 element에 추가하는 코드이다. 코드는 어렵지 않다. 그런데 왜 <code>style.css</code>를 <code>index.html</code>에 <code>&lt;link&gt;</code> 태그나 <code>&lt;style&gt;</code>태그를 통해 삽입하지 않고 <code>index.js</code>에 삽입을 하였을까? 이유는 처음에 설명한 style-loader의 역할 때문이다. 이렇게 <code>index.js</code>에 <code>style.css</code>를 명시하고 이 <code>index.js</code>를 build하게 되면 <code>loader</code>를 통해 <code>style.css</code>의 클래스는 <code>&lt;script&gt;</code>태그로 CSS가 추가되도록 되어 있다.</p><p>위 코드를 build하여 실행하고 결과를 확인해 보도록 하자.</p><h2 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h2><p><code>file-loader</code>를 사용하면 시스템에 존재하는 파일. 즉 이미지나 폰트와 같은 자산들을 하나로 통합할 수 있다. 사용 방식은 위에서 설명한 css-loader와 style-loader와 동일하다. <code>file-loader</code>를 먼저 설치하고 <code>webpkac.config.js</code>를 열어 loader를 추가하자.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install file-loader -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add file-loader --dev<br></code></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpe?g|gif)$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>여기서 loader를 보면 <code>css-loader</code>와 <code>style-loader</code>에서 사용한 <code>user:[]</code>가 사용되지 않고 <code>loader</code>로 사용되었다. 둘 다 적용이 가능한 옵션이며, <code>use:[]</code>경우 여러 <code>loader</code>를 지정할 때 사용되며 <code>loader</code>는 단일로 사용이 된다. 또한 각 <code>loader</code>는 각각의 특성에 따라 옵션을 지정할 있으며 아래와 같이 정의 할 수 있다.</p><p><strong>example</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpe?g|gif)$/</span>,<br>      <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>      <span class="hljs-attr">options</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;[hash].[ext]&#x27;</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>이어서 가자. file-loader를 정의 하였으니 <code>Webpack_Project</code>안에 <code>asset</code>폴더를 하나 만들고 <code>image.png</code>파일과 같은 이미지 파일을 넣어놓자. 이렇게 넣어 놓은 이미지 파일을 <code>index.js</code>에서 불러 올 것이다.</p><p><strong>index.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./style.css&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Icon</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./asset/image.png&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>  <br>  element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;Hello Webpack!!&#x27;</span><br>  element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br>  <span class="hljs-keyword">var</span> myIcon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()<br>  <br>  myIcon.<span class="hljs-property">src</span> = <span class="hljs-title class_">Icon</span><br>  element.<span class="hljs-title function_">appendChild</span>(myIcon)<br><br>  <span class="hljs-keyword">return</span> element<br>&#125;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>())<br></code></pre></td></tr></table></figure><p>이제 다시 build 하고 확인해 보자.</p><p>해당 예제는 이미지로 진행하였지만 폰트 역시 동일하다. 다른게 있다면 폰트의 확장자를 통해 걸러내는 정규식이 다를 뿐이다.</p><p><strong>example</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,<br>      <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;file-loader&#x27;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h2><p><code>file-loader</code>를 사용해 보았다면 한 번쯤 생각해 볼 것이다. 웹을 표한하는데 있어서 리소스를 가장 많이 잡아먹는 것 중 하나가 이 이미지 파일들인데 이 파일을 더 효율적으로 관리 할 수 없을지 말이다. webpack에서는 이 단계 이후에 진행될 논리적 단계는 <code>이미지를 축소하고 최적화하는 것이다.</code> 라고 말한다. <code>url-loader</code>는 이 이미지 로딩 프로세스를 향상 시킬 수 있는 하나의 방법이며, 특정 파일을 <code>base64</code>로 인코딩된 URL를 로드해주는 역할을 한다.</p><p><code>url-loader</code>를 설치하고 <code>webpack.config.js</code>를 열어 <code>url-loader</code>를 추가해 주자.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install url-loader -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add url-loader --dev<br></code></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpe?g|gif)$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>url-loader</code>는 <code>file-loader</code>와 같이 작동한다. 그렇기에 정규식 역시 동일하지만 다른 점은 <code>limit</code>이라는 옵션을 준 것이다. <code>options</code>에 <code>limit</code>는 파일의 크기를 말하는데 현재 예제에서 10KB 미만은 <code>url-loader</code>로 처리가 되고 그 이상의 파일은 <code>file-loder</code>와 같이 처리가 된다.</p><p>다시 build를 하고 <code>dist</code>폴더를 확인해 보자. 해당 이미지 파일이 존재하지 않는 것을 확인할 수 있다. 만약 파일이 존재한다면 파일의 용량을 확인해 보고 그 용량 이상의 값을 <code>limit</code>에 적용해보다. 그리고 브라우저를 열어 실제로 파일이 <code>base64</code>로 인코딩이 되었는지 확인해 보자.</p><hr><p>지금까지 <code>Loader</code>를 알아 보았는데 여기서 언급한 <code>Loader</code>이외에도 <code>xml-loader</code>, <code>babel-loader</code>, <code>i18n-loader</code> 등과 같이 효율적인 <code>Loader</code>들이 무수히 존재한다. 해당 <code>Loader</code>들은 <a href="https://webpack.js.org/loaders/">Webpack - Loader</a>에서 확인해 보자.</p><h1 id="Plug-In"><a href="#Plug-In" class="headerlink" title="Plug-In"></a>Plug-In</h1><p>webpack은 풍부한 Plug-In이 있으며 webpack 자체의 대부분의 기능은 이 Plug-In을 사용한다. Plug-In 을 통해 우리가 할 수 있는 일들은 build 된 bundle 파일을 동적으로 특정 html 페이지에 추가 할 수 있으며 build 시에 javscript, css, html 등의 파일을 난독화 및 압축을 진행할 수 있다. 이 외에도 많은 기능을 지원하며 필수 적으로 사용한다 해도 무방하다. 그럼 몇 가지 Plug-In을 살펴보겠다.</p><h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>엔트리 포인트 중 하나의 모듈의 이름을 변경하거나 새로운 것을 추가하는 경우 생성된 번들은 빌드에서 이름이 변경되지만 <code>index.html</code>에 script는 여전히 이전의 이름을 참조한다. 그렇게 때문에 우리는 주기적으로 번들링 된 파일을 <code>index.html</code>에 삽입을 시켜야하는 번거로움이 있다. 이런 불편함을 <code>html-webpack-plugin</code>이 해결해 준다. <code>html-webpack-plugin</code>은 정의되어있는 기본 template을 기준으로 번들링 시에 새로운 html 파일을 생성해 준다. 이때 파일을 생성할 때 번들링된 javascript 파일을 삽입해준다. </p><p><code>html-webpack-plugin</code>을 설치하고 <code>webpack.config.js</code>에 추가해 주자.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install html-webpack-plugin -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add html-webpack-plugin --dev<br></code></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">favicon</span>: <span class="hljs-string">&#x27;./static/asset/favicon.ico&#x27;</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./static/index.html&#x27;</span>,<br>      <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;app&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;monitor&#x27;</span>]<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="commonChunk"><a href="#commonChunk" class="headerlink" title="commonChunk"></a>commonChunk</h2><p><code>commonChunk</code> Plug-In은 여러 개의 엔트리 포인트 사이에서 공유되는 공통 모듈로 구성된 파일(Chunk)을 별도의 엔트리로 분리함으로써 종속성을 관리 할 수 있다. 예를 들면 어떤 프로젝트에서 jquery를 사용하고 jquery를 필요로 하는 모든 모듈에 jquery를 참조한다고 했을 때 이후 build를 하게 되면 jquery 모듈이 중복되는데 이렇게 common하게 사용되는 모듈을 여러 모듈이 참조를 한다고 하더라도 <code>commonChunk</code>를 사용하여 build 시에 하나의 별도의 vendor 모듈로 분리 할 수 있다.</p><p><code>commonChunk</code>는 webpack의 내장 모듈이기 때문에 별도의 설치는 필요하지 않다. 대신에 webpack을 참조해야 한다.</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;source/_posts/webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">favicon</span>: <span class="hljs-string">&#x27;./static/asset/favicon.ico&#x27;</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./static/index.html&#x27;</span>,<br>      <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;app&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;monitor&#x27;</span>]<br>    &#125;),<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h2><p>우리는 <code>webpack.config.js</code>에 build 시 output을 통해 어디로 가는지 지정을 해줬다. <code>clean-webpack-plugin</code>은 이 output 디렉토리를 build를 할때마다 삭제를 해주는 Plug-In이다.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install clean-webpack-plugin -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add clean-webpack-plugin --dev<br></code></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CleanWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>([<span class="hljs-string">&#x27;dist&#x27;</span>]),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">favicon</span>: <span class="hljs-string">&#x27;./static/asset/favicon.ico&#x27;</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./static/index.html&#x27;</span>,<br>      <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;app&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;monitor&#x27;</span>]<br>    &#125;),<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="uglify"><a href="#uglify" class="headerlink" title="uglify"></a>uglify</h2><p>javascript 소스를 보게 되면 <code>xxx.min.js</code> 라는 파일과 그 안의 코드는 알아볼 수 없는 형태로 되어있는 것을 봤을 것이다. 이는 난독화와 압축을 진행했기 때문인데 javascript를 build 할 때 다른 중요한 부분은 난독화와 압축이다. 이 프로세스를 걸침으로 인해 내부 코드의 내용을 쉽게 파악하지 못하게 함과 파일의 용량을 줄일 수 있다. 압축하는 방법이야 여러 가지가 있지만 <code>uglify</code>는 간단하게 난독화와 압축을 진행할 수 있는 Plug-In이다.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install uglifyjs-webpack-plugin -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add uglifyjs-webpack-plugin --dev<br></code></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UglifyWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">favicon</span>: <span class="hljs-string">&#x27;./static/asset/favicon.ico&#x27;</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./static/index.html&#x27;</span>,<br>      <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;app&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;monitor&#x27;</span>]<br>    &#125;),<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">UglifyWebpackPlugin</span>()<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h2><p><code>webpack.ProvidePlugin</code>을 통해 등록된 모듈을 자유 변수로 사용이 가능하다.</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UglifyWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">favicon</span>: <span class="hljs-string">&#x27;./static/asset/favicon.ico&#x27;</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./static/index.html&#x27;</span>,<br>      <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;app&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;monitor&#x27;</span>]<br>    &#125;),<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">UglifyWebpackPlugin</span>(),<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProvidePlugin</span>(&#123;<br>      <span class="hljs-attr">$</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>      <span class="hljs-attr">jQuery</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>      <span class="hljs-attr">_</span>: <span class="hljs-string">&#x27;underscore&#x27;</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>module A</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span>)<br><span class="hljs-title function_">jQuery</span>(<span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span>)<br><br><span class="hljs-keyword">const</span> array = _.<span class="hljs-title function_">map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)&#123;<br>  <span class="hljs-keyword">return</span> num * <span class="hljs-number">3</span>;<br>&#125;)<br></code></pre></td></tr></table></figure><hr><p><code>Loader</code>에 이어 <code>Plug-in</code>을 알아보았다. 이밖에 <code>Plug-in</code>은 <a href="https://webpack.js.org/plugins/">Webpack Plugin-in</a>을 참고하자.</p><h1 id="DevServer-HMR"><a href="#DevServer-HMR" class="headerlink" title="DevServer &amp;&amp; HMR"></a>DevServer &amp;&amp; HMR</h1><p><code>DevServer</code>는 webpack의 주요 기능 중 하나이다. 실제로 우리는 자산들을 bundling 후에도 테스트가 필요하다. 또한 자산의 추가, 수정, 삭제에 따라 반영 작업이 필요한데 webpack의 DevServer를 이용한다면 매우 편리하게 개발에 임할 수 있다. DevServer는 말 그대로 개발 서버이며 이와 관련된 또 하나의 webpack 주요 기능인 <code>HMR(Hot Module Replacement)</code>가 있다. 이 <code>핫 모듈 교체(한국어 풀이)</code>는 특정 모듈이 변경되더라도 새로고침 할 필요없이 런타임에 모든 종류의 모듈을 업데이트해 주는 기능이다. 이 기능을 사용하기 위해서는 DevServer의 설정을 추가하고 webpack에 내장된 HMR 플러그 인을 사용하는 것 뿐이다. 그렇기에 DevServer와 같이 설명하려 한다. HMR의 자세한 내용은 <a href="https://webpack.js.org/guides/hot-module-replacement/">Webpack HMR</a>을 참고하자.</p><p>살을 덧붙여 요약을 하자면.</p><div class="alert info no-icon"><ul><li><strong>webpack-dev-server</strong>는 빠른 실시간 리로드 기능을 갖춘 개발 서버</li><li><strong>webpack-dev-serve</strong>는 디스크에 저장되지 않는 메모리 컴파일을 사용하기 때문에 컴파일 속도가 빨라짐</li><li><strong>webpack.config.js</strong>에도 devServer 옵션을 통해 옵션을 지정하여 사용이 가능</li></ul></div><p><code>webpack-dev-server</code>의 간략한 프로세스는 이렇다.</p><div class="alert info no-icon"><ol><li>서버 실행 시 소스 파일들을 번들링하여 메모리에 저장</li><li>소스 파일을 감시하고 있다가 소스 파일이 변경되면 변경된 모듈만 새로 번들링</li><li>변경된 모듈 정보를 브라우저에 전송</li><li>브라우저는 변경을 인지하고 새로고침되어 변경사항이 반영된 페이지를 로드</li></ol></div><p>이제 <code>webpack-dev-server</code>를 설치하고 설정을 적용해보자.</p><p><strong>npm</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install webpack-dev-server -D<br></code></pre></td></tr></table></figure><p><strong>yarn</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">yarn add webpack-dev-server --dev<br></code></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UglifyWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">favicon</span>: <span class="hljs-string">&#x27;./static/asset/favicon.ico&#x27;</span>,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./static/index.html&#x27;</span>,<br>      <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;app&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;monitor&#x27;</span>]<br>    &#125;),<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">UglifyWebpackPlugin</span>(),<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProvidePlugin</span>(&#123;<br>      <span class="hljs-attr">$</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>      <span class="hljs-attr">jQuery</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>      <span class="hljs-attr">_</span>: <span class="hljs-string">&#x27;underscore&#x27;</span><br>    &#125;)<br>  ],<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,<br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>devServer의 설정을 보면 감이 올 것으로 생각된다. 간단한 설명으로 넘어가겠다.</p><table><thead><tr><th>option</th><th>description</th><th>CLI 사용</th></tr></thead><tbody><tr><td>host</td><td>사용될 호스트 지정</td><td>webpack-dev-server –host 127.0.0.1</td></tr><tr><td>contentBase</td><td>콘텐츠를 제공할 경로지정(정적파일을 제공하려는 경우에만 필요)</td><td>webpack-dev-server –content-base &#x2F;path&#x2F;to&#x2F;content&#x2F;dir</td></tr><tr><td>compress</td><td>모든 항목에 대해 gzip압축 사용</td><td>webpack-dev-server –compress</td></tr><tr><td>hot</td><td>webpack의 HMR 기능 활성화</td><td>-</td></tr><tr><td>inline</td><td>inline 모드 활성화</td><td>webpack-dev-server –inline&#x3D;true</td></tr><tr><td>port</td><td>접속 포트 설정</td><td>webpack-dev-server –port 9000</td></tr><tr><td>open</td><td>dev server 구동 후 브라우저 열기</td><td>webpack-dev-server –open</td></tr></tbody></table><p><code>webpack-dev-server</code>의 구동은 CLI로 실행을 하고 이 CLI를 npm script에 등록하여 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">webpack-dev-server --config webpack.config.js --mode=development<br></code></pre></td></tr></table></figure><p>open 옵션으로 인해 서버가 구동 후 브라우저가 열리는 것을 볼 수 있다. 여기서 F12를 통해 개발자 콘솔을 열고 모듈을 변경, 수정하면서 console 창을 확인해 보자. 당신은 지금 <code>HMR</code>이라는 훌륭한 기능을 보고 있는 것이다.</p><hr><p>여기까지 해서 webpack의 핵심적인 사용법을 알아보았다. webpack에 대한 디테일한 가이드는 <a href="https://webpack.js.org/guides/">webpack guides</a>를 참고하면서 하나씩 따라 해보자. </p><p>webpack은 초기 설정이 까다롭게 느껴질 수 있다. 당연한 것이다. webpack 자체의 configulation과 Loader, plug-in 제각기 옵션이 존재하기 때문이다. 하지만 초기 설정만 끝난다면 webpack이 왜 떠오르고 많이 사용하는지 몸소 느낄 것이다. 현재 내가 진행하고 있는 프로젝트에도 webpack을 도입하기로 하였기에 Test하고 Prototype을 만들고 실제로 프로젝트에 적용해 보면서 매번 정말 훌륭하다고 느껴진다. Web Front-End의 Bundling tool을 고민하는 당신에게 적극적으로 추천한다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a><br><a href="https://kdydesign.github.io/2020/09/23/parcel-intro/">불꽃 튀게 빠른 번들러 Parcel 개념잡기!</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> build tool </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> webpack </tag>
            
            <tag> build tool </tag>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 개념잡기</title>
      <link href="/2017/07/27/webpack/"/>
      <url>/2017/07/27/webpack/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/07/27/webpack/cover.png" alt="cover"></p><p><code>Web front-end build tool</code>에는 여러 가지가 있다. 이러한 <code>build tool</code>은 단순히 소스를 묶고 컴파일하고 압축하는 단순한 형태에서 벗어나 하나의 기술로 자리잡혔다. 이 <code>build tool</code>들을 활용함으로써 우리가 진행하는 프로젝트에 엄청난 시너지를 안겨 줄 수 있다. 수많은 <code>build tool</code> 중 이 포스트에서는 **떠오르는 build tool인 <code>webpack</code>**에 대한 소개와 프로젝트를 진행하면서 왜 <code>Build Tool</code>이 필요한지 포스팅하겠다.</p><h1 id="Build-Tools"><a href="#Build-Tools" class="headerlink" title="Build Tools"></a>Build Tools</h1><p><code>Build</code>는 서버 사이드에서만 사용하는 것이 아닌 <code>Web Front-End</code>에서도 필수이다. JavScript와 CSS를 축소하고 단위 테스트도 수행하며 프로젝트에 필요한 자산들(Image, Font)을 효율적으로 관리할 수 있을 뿐만 아니라 패키지화까지 진행할 수 있다. 이러한 사항들로 인해 결국 해당 프로젝트의 성능과 개발의 편의, 그리고 개발 속도가 향상될 수 있다. 물론 build를 실행하지 않고 직접적으로 시스템 파일을 <code>Linking</code>하여 사용할 수도 있겠지만 우리는 언제나 <code>Performance</code> 대립하게 되어있다. 그럼 이 <code>Front-End</code>의 <code>build tool</code>에는 어떤 것이 있을까?</p><blockquote><p>Jake<br>Brunch<br>Grunt<br>Gulp<br>Webpack<br>Brocolli<br>Cha</p></blockquote><p>너무 많다. 그냥 “이런 게 있구나..”라고 기억만 하자. </p><p>그럼 왜 저 많은 <code>build tool</code> 중에서 <code>Webpack</code>을 포스팅하는 것일까? 저 <code>build tool</code> 중 가장 많이 사용하는 tool은 <code>Gulp</code>와 <code>Grunt</code> 그리고 <code>Webpack</code>이다. 이 세 가지를 비교해 볼 수는 없다. 셋 모두 훌륭한 시스템이다. 단지 <a href="https://npmcompare.com/compare/grunt,gulp">NPMCOMPARE</a>에서 <code>Gulp</code>와 <code>Grunt</code>를 비교해 보았을 때 <code>Gulp</code>가 좀 더 활성화되어 있는 것을 볼 수 있다. 그렇다면 <code>Webpack</code>은??</p><h1 id="Webpack-VS-Gulp"><a href="#Webpack-VS-Gulp" class="headerlink" title="Webpack VS Gulp"></a>Webpack VS Gulp</h1><p>사실 <a href="https://webpack.js.org/">Webpack</a>와 <a href="https://gulpjs.com/">Gulp</a>은 다르게 볼 수 있다. <code>Webpack</code>은 <code>Package Bundler</code>이며, <code>Gulp</code>는 <code>Task Runner</code>이다. 크게 다르다고는 할 수 없지만, 이 이유가 <code>Webpack</code>을 포스팅하는 이유이다. 그럼 <code>Task Runner</code>와 <code>Package Bundler</code>는 무슨 차이일까.</p><div class="alert info no-icon"><ul><li><strong>Package Bundler</strong> - 종속성을 가진 애플리케이션 모듈을 정적인 소스로 재생산</li><li><strong>Task Runner</strong> - 반복 가능한 특정 작업을 자동화</li></ul></div><p>쉽게 말하면 <code>Task Runner</code>는 그저 미리 정의해 놓은 어떠한 작업을 실행하는 것이고 <code>Package Bundler</code>는 말 그대로 어떤 소스들을 하나의 패키지화 하는 것이다. </p><p>구글 트렌드를 통해 <code>Gulp</code>와 <code>Webpack</code>의 검색 추이를 보게 되면 처음에는 <code>Gulp</code>가 우세한 면을 보이지만 최근 들어 <code>Webpack</code>이 <code>Gulp</code>를 넘어서 더 우세한 것을 볼 수 있다. </p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1101_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"Webpack","geo":"","time":"today 5-y"},{"keyword":"Gulp","geo":"","time":"today 5-y"}],"category":31,"property":""}, {"exploreQuery":"cat=31&date=today 5-y&q=Webpack,Gulp","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><p>이는 프로젝트 규모와 그리고 <code>Task Runner</code>로는 진행할 수 없는 <code>Webpack</code>만의 중요한 종속성 관리에 따라 변화된 것으로 보인다. 이러한 종속성 관리는 프로젝트 규모가 클수록 더 빛을 발하며 그리고 날이 갈수록 <code>단일 웹 애플리케이션(SPA)</code>의 확산에 따라 중요한 자리를 차지하고 있다. 이 그래프에서 우리가 유추해 볼 수 있는 또 다른 하나는 <code>Webpack</code>과 <code>Gulp</code>의 교차 지점이다. 이 기간에서는 <code>Webpack</code>과 <code>Gulp</code>를 같이 사용했다고 볼 수 있다. 물론 지금도 그렇게 사용하는 개발자도 있다. <code>jsHint</code>나 <code>jsLint</code>등의 코드 검사 도구 또는 <code>mocha</code>나 <code>jasmine</code>과 같은 테스트 도구를 <code>Gulp</code>를 통해 실행하고 이 후 프로젝트의 패키징은 <code>Webpack</code>으로 사용하는 것처럼 말이다. 하지만 <code>Webpack</code>에서도 <code>Gulp</code>와 마찬가지로 전처리 작업을 지원하면서 <code>Webpack</code>이 더욱 상승세를 보인다. </p><p><code>Webpack</code>과 <code>Gulp</code>의 <a href="https://npmcompare.com/compare/gulp,webpack">NPM COMPARE</a>를 보게 되면 <code>Gulp</code>가 종속된 모듈수가 적고 발생 이슈가 낮지만, 전체적인 면에서 보면 현재로서는 <code>Webpack</code>이 좀 더 활성화가 된 것을 볼 수 있다. 그럼 먼저 간단하게 <code>Webpack</code>와 <code>Gulp</code>의 특징을 알아보도록 하겠다.</p><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>위에서 말했듯이 <code>Webpack</code>은 JavaScript 애플리케이션을 위한 <code>Package Bundler</code>이고 목적은 종속성을 가진 애플리케이션 모듈을 정적인 소스들로 생산하는 것이다. 애플리케이션을 처리할 때 필요한 모든 모듈을 종속성 그래프로 반복적으로 작성한 다음 모든 모듈을 브라우저에서 로드 할 수 있는 하나의 Bundle로 패키지화한다. 이 외의 특징은 다음과 같다. </p><div class="alert info no-icon"><ul><li>Loader를 통해 Javascript, Image file, Font, CSS, SCSS 등과 같은 자산을 하나의 모듈로 취급</li><li>Entry 별로 Bundle 생성 가능</li><li>Bundle에 대한 압축 및 난독화, 소스 맵에 대한 옵션을 제공</li><li>Plug-In 사용을 통한 사용자 정의 기능 수행</li><li>비동기 I&#x2F;O와 다중 캐시 레벨을 사용하기 때문에 컴파일 속도가 매우 빠름</li><li>CommonJS(nodejs)와 AMD(requires) 스펙 지원</li></ul></div><p><code>Webpack</code>은 크게 <code>Entry</code>, <code>Output</code>, <code>Loader</code>, <code>Plug-In</code> 이 4가지로 나눌 수 있다. </p><div class="alert info no-icon"><ul><li><p><strong>Entry</strong> - Webpack은 모든 애플리케이션에 대한 종속성 그래프를 작성하고 이 그래프의 시작점을 Entry Point라고 한다. 이 Entry Point를 통해 모듈이 어디서부터 시작하는지를 명세하는 애플리케이션을 시작하는 첫 번째 파일로 나타낼 수 있다.</p></li><li><p><strong>Output</strong> - Output은 모든 애플리케이션의 자산(resources 또는 assets)을 하나의 Bundle로 묶었으면 해당 Bundle을 처리하는 방법을 명세한다.</p></li><li><p><strong>Loader</strong> - Loader는 사전에 처리할 작업을 나타내며 css, html, jpg, scss 등의 자산을 하나의 모듈로 취급하며 이러한 파일들을 종속성 그래프에 추가할 때 모듈로 변환한다.</p></li><li><p><strong>Plug-In</strong> - Plug-In은 일반적인 Compile 또는 모듈 처리에 필요한 작업 및 사용자 정의 기능을 수행하는데 사용한다.</p></li></ul></div><p><code>Webpack</code>의 장점은 이렇게 많지만 단점이라 하면 초기 구축에 대한 시간적인 비용이 많이 투자되며 Learning Curve가 길다는 점이다.</p><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><p><code>Gulp</code>는 <code>Task Runner</code>이며, <code>Work Flow</code>를 자동화 및 향상할 수 있는 도구이다. 개발 <code>Work Flow</code>에서 번거로운 작업들이나 시간적인 소모가 많이 들어가는 작업을 자동화하여 쉽게 처리할 수 있다. <code>Gulp</code>의 특징을 보자.</p><div class="alert info no-icon"><ul><li>반복 가능한 작업을 자동화</li><li>JavaScript 테스트 실행 및 파일 병합</li><li>js, css, html등의 자산 파일을 압축</li><li>Node stream 기반으로 빠른 빌드 속도를 제공</li><li>작업을 정의하고 실행하는 것이 수월</li></ul></div><p><code>Gulp</code>는 <code>Webpack</code>에 비하여 <code>Learning Curve</code>가 낮기 때문에 사용하기 쉬운 편이며, 코드에 대한 가독성이 좋다. 대신 <code>Webpack</code>과 같이 모든 모듈에 대한 종속성 관리가 이루어지지 않기에 규모가 큰 프로젝트에서 패키지화하기가 쉽지 않다. 나도 <code>Gulp</code>를 사용하지만 개인 오픈 소스 프로젝트를 진행하는데에는 이만한 Tool도 없다.</p><hr><p>지금까지 우리는 <code>Webpack</code>과 <code>Gulp</code>를 알아 보았다. 전체적으로 본다면 <code>Build Tools</code>를 알아 본 것이다. 이번 포스팅에서는 <code>Webpack</code>이 기준이기 때문에 <code>Webpack</code>에 대해 좀 더 자세히 알아보았지만, 명심해야 할 것은 무조건 <code>Webpack</code>이 좋다는 것이 아니다. <code>Gulp</code>, <code>Grunt</code> 역시 훌륭한 <code>Build Tool</code>이다. 우리가 진행해야 할 프로젝트에 어떤 것이 더 효과적이고 필요한지를 되새김하고 그에 걸 맞는 <code>Build Tool</code>을 선정해야 할 것이다.</p><p>다음 포스팅에서는 실제로 <code>Webpack</code>을 어떻게 사용하지. <code>Webpack</code> 설치부터 응용까지 해 보기로 하자.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/11/04/webpack-tutorial/">Webpack 완전정복하기!!</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2020/09/23/parcel-intro/">불꽃 튀게 빠른 번들러 Parcel 개념잡기!</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> build tool </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> webpack </tag>
            
            <tag> build tool </tag>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</title>
      <link href="/2017/07/15/nodejs-npm-tutorial/"/>
      <url>/2017/07/15/nodejs-npm-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/07/15/nodejs-npm-tutorial/cover.png" alt="cover"></p><p><code>node.js</code>와 <code>npm</code>은 웹 개발에 종사하고 있는 개발자라면 웬만해서는 알만큼 중요한 기술 중의 하나이다. 많이 들어보기도 했을 것이다. 이와 관련된 포스팅도 많고 정보도 많으니까. 그럼 <code>node.js</code>와 <code>npm</code>이 무엇인지 알아보고 설치를 진행해 보자.</p><h2 id="Node-js와-NPM-개념잡기"><a href="#Node-js와-NPM-개념잡기" class="headerlink" title="Node.js와 NPM 개념잡기"></a>Node.js와 NPM 개념잡기</h2><p><a href="https://nodejs.org/">Node.js 공식 사이트</a>에서는 이렇게 정의하고있다.</p><div class="alert info no-icon"><p><strong>Node.js®는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다. Node.js는 이벤트 기반, Non 블로킹 I&#x2F;O 모델을 사용해 가볍고 효율적입니다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.</strong></p></div><p><code>node.js</code>와 <code>npm</code>이 무엇인지 대강 알겠다.</p><p><code>node.js</code>는 JavaScript 기반으로 구성된 서버 사이드 서비스를 JavaScript로 구현할 수 있게 만든 런타임이고, <code>npm</code>은 <code>node.js</code> 기반의 모듈을 모아둔 집합 저장소이다. <code>npm</code>은 <code>Node Package Manager</code> 또는 <code>Node Package Modules</code>라고도 한다.</p><p><code>node.js</code>를 구글 트렌드에서 검색하게 되면 계속되는 상승곡선을 볼 수 있다.</p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2213_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"/m/0bbxf89","geo":"","time":"2004-01-01 2020-09-15"}],"category":0,"property":""}, {"exploreQuery":"date=all&q=%2Fm%2F0bbxf89","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><p>그만큼 오늘날 <code>node.js</code>는 개발에 있어서 중요한 한 부분을 차지하고 있다는 것이다. 그럼 <code>node.js</code>를 사용해서 우린 무엇을 할 수 있을까?</p><p>다음은 <code>node.js</code>로 할 수 있는 것들이다. 꼭 여기에 국한되지는 않지만 <code>node.js</code>가 가장 빛을 발하는 곳은 실시간 웹 애플리케이션이다. 이유는 <a href="https://nodejs.org/en/about/">About Node.js</a> <code>node.js</code> 정보에 잘 나와 있다. 설명하자면 <code>node.js</code>는 <strong>lock</strong>이 없으므로 프로세스를 <strong>dead-locking</strong> 할 걱정이 없고 I&#x2F;O를 직접 수행하지 않으므로 프로세스가 절대 차단되지 않기 때문이다. <strong>non Block</strong>이기에 확장 가능한 시스템은 노드에서 개발하는 것이 합리적이다.</p><blockquote><ul><li>정적 파일 서버</li><li>웹 응용프로그램</li><li>메시징 미들웨어</li><li>HTML5 멀티 플레이어 게임용 서버</li></ul></blockquote><p><code>npm</code>은 훌륭한 개발자들이 Node.js 기반의 JavaScript로 개발된 오픈 소스를 모듈로 올려놓은 곳이다. 우리는 웹 개발에 필요한 jQuery, gulp, webpack 등의 모듈들을 <code>npm</code>명령어를 통해 쉽게 다운받고 쓸 수가 있다.</p><h2 id="Node-js와-NPM-설치하기"><a href="#Node-js와-NPM-설치하기" class="headerlink" title="Node.js와 NPM 설치하기"></a>Node.js와 NPM 설치하기</h2><p><code>node.js</code>와 <code>npm</code> 설치는 간단하다. <code>npm</code>의 경우는 <code>Node Package Manager</code>이기 때문에 <code>node.js</code>를 설치하면 같이 설치된다. 먼저 <a href="https://nodejs.org/">Node.js</a>에서 다운받은 후 원클리으로 설치하면 된다.</p><p>설치가 완료되었다면 확인해보자. 명령 프롬프트를 실행하여 아래 명령어를 쳐보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">node -v<br></code></pre></td></tr></table></figure><p>정상적으로 다운로드 받고 설치한 버전 정보가 출력된다면 설치는 완료된 것이다. 물론 <code>npm</code>도 설치가 되었겠지만 그래도 확인은 해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm -v<br></code></pre></td></tr></table></figure><p>이것으로 설치는 완료되었다. 별도의 Path도 잡을 필요 없고 원클릭으로 <code>node.js</code>와 <code>npm</code>을 설치할 수 있다.</p><h2 id="Node-js-테스트해보기"><a href="#Node-js-테스트해보기" class="headerlink" title="Node.js 테스트해보기"></a>Node.js 테스트해보기</h2><p><code>node.js</code>를 설치하였으니 한번 실행해보자. 명령 프롬프트를 열어 <code>node</code>명령어를 실행하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">node<br></code></pre></td></tr></table></figure><p>이제 우리는 명령 프롬프트에 JavaScript 코드를 입력하여 실행할 수 있다. 아래 코드를 <code>Enter</code>와 함께 입력해보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">//enter</span><br>a           <span class="hljs-comment">//enter  //print `1`</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;  <span class="hljs-comment">//enter</span><br>b           <span class="hljs-comment">//enter  //print `2`</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum = &#x27;</span> + a + b);  <span class="hljs-comment">//enter  //print &#x27;sum = 3&#x27;</span><br></code></pre></td></tr></table></figure><p>명령 프롬프트에서 이렇게 JavaScript 코드를 입력할 수도 있지만 이렇게 개발할 수는 없다. JavaScript 파일을 만들고 해당 파일을 실행해보자. 먼저 정당한 곳에 <code>NodeTest</code>폴더 하나를 만들고 그 폴더 안에 <code>main.js</code>파일을 만들자.</p><p><strong>main.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum = &#x27;</span> + <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p><code>main.js</code>파일을 만들었으면 <code>NodeTest</code>경로로 이동하자. 명령 프롬프트로 이동해도 되고 아니면 <code>NodeTest</code>폴더에서 <code>Shift + 마우스 우클릭</code>을 통해 <code>여기서 명령 창 열기</code>를 통해 명령 프롬프트를 실행할 수 있다.</p><p>어쨌든 명령 창을 실행하였으면 <code>main.js</code>를 실행하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">node main.js<br></code></pre></td></tr></table></figure><p>결과를 확인하였는가? 이처럼 미리 생성된 JavaScript 파일을 우리는 <code>node</code>명령어를 통해 실행할 수가 있다.</p><h2 id="NPM-테스트해보기"><a href="#NPM-테스트해보기" class="headerlink" title="NPM 테스트해보기."></a>NPM 테스트해보기.</h2><p>이제 <code>npm</code>을 테스트해보자. <code>npm</code>을 통해 특정 모듈을 다운받고 그 모듈을 통해 어떤 작업을 수행할 것이다. 먼저 <code>NodeTest</code>폴더로 이동하여 명령 프롬프트를 실행 후 명령어를 입력하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm init -y<br></code></pre></td></tr></table></figure><p><code>npm init</code>명령어를 입력하면 <code>package.json</code>파일이 생성된 것을 볼 수 있다. 진행하기에 앞서 먼저 <code>package.json</code>을 보고 가자.</p><hr><h3 id="Package-json"><a href="#Package-json" class="headerlink" title="Package.json"></a>Package.json</h3><p>우리가 만든 <code>package.json</code>을 열어보자.</p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NodeTest&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>package.json</code>은 프로젝트에 대한 명세라고 할 수 있다. 해당 프로젝트의 이름, 버전, 사용되는 모듈 등의 스펙이 정해져 있으며, 이 <code>package.json</code>을 통해 모듈 의존성 모듈 관리도 진행할 수 있다. 만약 어떤 오픈 소스를 다운 받을 때 이 <code>package.json</code>만 있다면 해당 오픈 소스가 의존하고 있는 모듈이 어떤 것인지. 그리고 그 모듈들을 아래 명령어로 한 번에 설치할 수 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install<br></code></pre></td></tr></table></figure><hr><p>이어서 가자.</p><p>여기까지 해서 <code>package.json</code>이 생성되었으니 <code>npm</code>을 통해 모듈을 설치해보자. 모듈은 <code>mocha</code>라는 Front-End 단위 테스트(TDD) 프레임워크를 설치해보겠다. <code>mocha</code>와 관련된 포스트는 <a href="https://kdydesign.github.io/2017/06/08/Mocha.html">JavaScript 단위 테스트 프레임워크 - Mocha</a>를 참고하도록하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install mocha --save-dev<br></code></pre></td></tr></table></figure><p>해당 명령어를 통해 mocha를 설치해만 <code>NodeTest</code>폴더 안에는 <code>node_modules</code>폴더가 생성되고 그 안에는 <code>mocha</code>모듈이 설치된 것을 확인할 수 있다. 그리고 다시 <code>package.json</code>을 열어보면 <code>devDependencies</code>에 <code>mocha</code>가 추가된 것을 볼 수 있다. 이는 <code>mocha</code>를 설치할 때 <code>--save-dev</code>옵션을 추었기에 추가가 된 것이다.</p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.4.2&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>이렇게 설치한 <code>npm</code>모듈은 해당 프로젝트에서 사용할 수 있는 흔히 말하는 지역변수와 같은 개념이 되는 것이다. 그럼 지역변수가 있으니 전역으로 사용할 수 있는 모듈도 있지 않을까?</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install mocha -g<br></code></pre></td></tr></table></figure><p>전역으로 설치하기 위해서는 <code>-g</code>옵션을 추가해주면 된다. 이렇게 전역으로 설치된 모듈은 <code>C:\Users\사용자명\AppData\Roaming\npm</code>경로에 설치가 된다. (폴더가 없다면 숨김포더를 해제하라.) 이렇게 전역으로 설치한 모듈을 해당 프로젝트에서 <code>심볼릭 링크</code>로도 사용이 가능하다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm <span class="hljs-built_in">link</span> mocha<br></code></pre></td></tr></table></figure><p><code>npm</code>을 통해 설치된 모듈의 목록 역시 확인할 수 있다. 아래 명령어를 하나씩 입력해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm list            // 현재 경로에 설치된 npm 목록 조회<br>npm list -g         // Global 경로에 설치된 npm 목록 조회<br>npm <span class="hljs-built_in">ls</span>              // list의 축약형<br>npm <span class="hljs-built_in">ls</span> --depth=0    // 현재 경로에 설치된 최상위 모듈만 조회<br>npm <span class="hljs-built_in">ls</span> -g --depth=0 // Global 경로에 설치된 최상위 모듈만 조회<br></code></pre></td></tr></table></figure><p>자세한 <code>npm</code>명령어 또는 옵션은 <a href="https://docs.npmjs.com/">NPM DOCUMENT</a>를 참고하자.</p><h2 id="Node-js-Version-관리"><a href="#Node-js-Version-관리" class="headerlink" title="Node.js Version 관리"></a>Node.js Version 관리</h2><p>보통 오픈 소스인 NPM 패키지는 각 패키지 종속성에 따라서 Node.js의 버전 영향을 받는다. 예를 들어 위에서 예제를 든 <code>mocha</code>는 <strong>10.12.0 이상의 Node.js 버전에서 동작이 된다.</strong></p><p>이는 <code>mocha</code>의 <code>package.json</code>에서 확인해 볼 수 있다. </p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;engines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;= 10.12.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>그래서 우리는 <code>10.12.0</code>이상의 Node.js를 설치를 했지만 만약 사용 중인 다른 모듈이 <code>10 이하의 버전에서 동작이 된다면</code> 이 떄 우리는 Node.js 버전을 변경해 줘야한다. 이런 경우 버전에 맞는 Node.js를 재설치해줘도 되지만 매우 번거로운 일일 것이다.</p><p>이런 경우를 위해 사용할 수 있는 것이다 <code>NVM (Node Version Manager)</code>이다. <a href="https://github.com/nvm-sh/nvm">NVM</a>은 오픈 소스로 <code>Mac OS</code>에 많이 사용되지만 <code>Window</code>나 <code>Linux</code>환경에서 사용할 수 있다. </p><p>이 <code>NVM</code>을 사용하면 여러 버전의 <code>Node.js</code>를 설치하고 상황에 따라서 Version을 변경해 가면서 사용이 가능하다. </p><p><code>NVM</code>에 관련해서는  <a href="https://kdydesign.github.io/2020/09/16/nvm-for-windows/">NVM으로 Windows 환경에서 Node 버전 관리하기</a>를 통해서 확인해보자.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/2023/09/25/pnpm-tutorial/">Performant NPM - PNPM</a><br><a href="https://kdydesign.github.io/2020/10/19/open-source-flow/">오픈 소스(Open-Source) 구조와 모듈 파악하기</a><br><a href="https://kdydesign.github.io/2020/08/28/npm-tutorial/">빠르게 배우는 NPM 패키지 생성부터 배포까지 완벽 가이드</a><br><a href="https://kdydesign.github.io/2017/11/15/vuejs-tutorial/">빠르게 배우는 Vue.js</a><br><a href="https://kdydesign.github.io/2020/08/31/npm-scope-tutorial/">NPM-Scope 패키지 어디까지 알고 있니?</a><br><a href="https://kdydesign.github.io/2019/04/15/electron-tutorial/">Electron 완전정복!! - 개념부터 데스크탑 앱 만들기</a><br><a href="https://kdydesign.github.io/2019/04/06/vuejs-vuex-helper/">Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</a><br><a href="https://kdydesign.github.io/2019/04/10/vuejs-performance/">Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</a><br><a href="https://kdydesign.github.io/2019/04/10/nuxtjs-tutorial/">Nuxt.js 개념부터 설치까지 빠르게 배우기</a><br><a href="https://kdydesign.github.io/2020/09/16/nvm-for-windows/">NVM으로 Windows 환경에서 Node 버전 관리하기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo와 Github page로 만든 블로그에 Hexo 테마 적용하기</title>
      <link href="/2017/07/07/hexo-theme/"/>
      <url>/2017/07/07/hexo-theme/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/07/07/hexo-theme/cover.png" alt="cover"></p><p><code>hexo</code>와 <code>github page</code>에 테마를 입히는 것이 <code>hexo</code>와 <code>github page</code>를 사용하여 블로그를 구축하는 것보다 어려울 수 있다. 일단 <strong>Document가 한글이 아니기 때문</strong>인데 먼저 이 포스트에서 하나의 테마를 잡아 적용을 해보고 원하는 테마를 골라서 별도로 적용해보자.</p><hr><h2 id="Hexo-테마-선택하기"><a href="#Hexo-테마-선택하기" class="headerlink" title="Hexo 테마 선택하기"></a>Hexo 테마 선택하기</h2><p>먼저 테마가 어떤 것들이 있는지 살펴보자.<br><a href="https://hexo.io/themes/index.html">Hexo Theme</a>에서 개발자들이 <code>hexo</code>를 사용하여 만든 테마 목록을 확인하고 다운받을 수 있다. 물론 우리도 <code>hexo</code> 테마를 제작할 수 있다.</p><p>대충 둘러보면 알겠지만 그저 그런 테마들이 아니다. 모두 개인의 <code>Identity</code>가 들어가 있는 디자인뿐만 아니라 더 나아가 <code>반응형 디자인</code>으로 제작되어 있다. 이 <code>반응형 디자인</code>으로 인해 우리는 하나의 페이지를 모바일에서 볼 때와 PC 브라우저에서 볼 때 모두 다른 형태의 UI, UX로 보이는 것이다. 훌륭하다. 우린 그저 가져다 쓰기만 하면 된다.</p><p>이 훌륭한 테마 중 우리는 <a href="http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/">Clean Blog</a>를 선택하고 적용해 보자. 이 <a href="http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/">Clean Blog</a>는 매우 깔끔한 디자인을 가지고 있고 <code>jekyll</code>에서도 지원하는 블로그 테마이다.</p><p><img src="/2017/07/07/hexo-theme/thumb02.png" alt="thumb02"></p><h2 id="Hexo-테마-설치하기"><a href="#Hexo-테마-설치하기" class="headerlink" title="Hexo 테마 설치하기"></a>Hexo 테마 설치하기</h2><p>처음에 말했듯이 테마들은 모두 오픈소스로 되어있다. 그리고 그 오픈소스들은 <code>github</code>에 올려져 있다. 우리는 <a href="https://kdydesign.github.io/2017/07/07/hexo-theme/">Hexo와 Github Page로 시작하는 블로그 만들기</a>에서 블로그를 구축하며 대충 배워 본 <code>git</code>과 <code>github</code>사용 방법을 통해 테마 역시 <code>github</code>에서 <code>git</code>을 통해 다운 받을 것이다.</p><p><a href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog Github</a>에 가보면 <code>Clean Blog</code>를 적용하는데 필요한 프로젝와 적용 방법과 기타 기능들에 대한 설명이 나와있다. 여기만 잘 읽고 따라하면 문제없이 적용된다. 물론 영어지만.</p><p>이전에 <a href="https://kdydesign.github.io/2017/07/07/hexo-theme/">Hexo와 Github Page로 시작하는 블로그 만들기</a> 포스팅에서 만들어 놓은 폴더 경로로 이동하자. 해당 폴더에 가면 <code>themes</code>라는 폴더가 존재할 것이다. 이 <code>themes</code> 경로로 가보면 처음에 <code>hexo</code> 블로그를 만들 때 기본으로 적용되는 <code>landscape</code>테마가 있다. <code>themes</code>경로에는 여러 개의 테마 폴더가 존재해도 상관없다 <code>hexo</code>에서 설정된 단 하나의 테마만 적용된다. 그리고 <code>themes</code> 경로에서 <code>마우스 우클릭</code>을 눌러 <code>Git Bash Here</code>메뉴를 클릭하자. 이후에 실행되는 <code>git bash</code>창에 명령어를 입력하여 <code>github</code>에 있는 소스를 다운받자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/klugjo/hexo-theme-clean-blog.git<br></code></pre></td></tr></table></figure><p>또는 <a href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog Github</a>에서 우측 상단에 <code>Clone or download</code>버튼을 통해 zip 압축파일로 다운받을 수 있다.</p><p><img src="/2017/07/07/hexo-theme/thumb01.png" alt="thumb01"></p><p>다운을 받게 되면 <code>themes</code>경로 안에 <code>hexo-theme-clean-blog</code>라는 폴더가 생성되었을 것이다. 이 폴더명을 <code>clean-blog</code>로 변경해 주자.</p><h3 id="테마-소스-구조-살펴보기"><a href="#테마-소스-구조-살펴보기" class="headerlink" title="테마 소스 구조 살펴보기"></a>테마 소스 구조 살펴보기</h3><p>잠깐 테마의 소스들이 어떻게 구성되어있는지 보자. </p><table><thead><tr><th>File</th><th>Description</th></tr></thead><tbody><tr><td>language</td><td>blog를 구성하는 다국어 파일</td></tr><tr><td>layout</td><td>blog를 구성하는 파일</td></tr><tr><td>source</td><td>blog 구성에 필요한 리소스 파일</td></tr><tr><td>_config.yml</td><td>해당 테마의 설정 파일</td></tr></tbody></table><p>대표적인 파일을 보게 되면 <code>language</code>, <code>layout</code>, <code>source</code>, <code>_config.yml</code>이다. 이 파일들은 대부분의 테마들이 가지고 있으며 <code>_config.yml</code>의 경우는 필수이다. <code>hexo</code>블로그를 구성하는 설정파일 역시 <code>_config.yml</code>파일이다. <strong>두 파일을 혼동해서는 안된다.</strong></p><h2 id="테마-설정하기"><a href="#테마-설정하기" class="headerlink" title="테마 설정하기"></a>테마 설정하기</h2><p>우리는 <code>themes/clean-blog</code>경로에 있는 <code>_config.yml</code>을 수정하여 메뉴, 블로그 타이틀 등 블로그를 구성하는 내용들을 변경할 수 있다. <code>_config.yml</code>을 열어 원하는 내용대로 수정하자. 설정 파일의 내용은 아래 주석을 보자.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Header</span><br><span class="hljs-attr">menu:</span><br>  <span class="hljs-attr">Home:</span> <span class="hljs-string">/</span>                               <span class="hljs-comment">#메인 페이지 경로 </span><br>  <span class="hljs-attr">Archives:</span> <span class="hljs-string">/archives</span>                   <span class="hljs-comment">#Archives 메뉴 경로</span><br>  <span class="hljs-attr">Tags:</span> <span class="hljs-string">/tags</span>                           <span class="hljs-comment">#tags 메뉴 경로</span><br>  <span class="hljs-attr">Categories:</span> <span class="hljs-string">/categories</span>               <span class="hljs-comment">#categories 메뉴 경로</span><br>  <span class="hljs-attr">Github:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">https://github.com/klugjo/hexo-theme-clean-blog</span>             <span class="hljs-comment">#사용자 github url                      </span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">github</span>               <span class="hljs-comment">#github icon</span><br><br><span class="hljs-comment"># Title on top left of menu. Leave empty to use main blog title</span><br><span class="hljs-attr">menu_title:</span> <span class="hljs-string">Configurable</span> <span class="hljs-string">Title</span>          <span class="hljs-comment">#좌측 상단 메뉴 타이틀</span><br><br><span class="hljs-comment"># URL of the Home page image</span><br><span class="hljs-attr">index_cover:</span> <span class="hljs-string">http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg</span>       <span class="hljs-comment">#커버 이미지 경로</span><br><br><span class="hljs-comment"># Default post title</span><br><span class="hljs-attr">default_post_title:</span> <span class="hljs-string">Untitled</span>             <span class="hljs-comment">#포스트 생성 시 기본 타이틀</span><br><br><span class="hljs-comment"># Comments. Choose one by filling up the information</span><br><span class="hljs-attr">comments:</span><br><span class="hljs-comment"># Disqus comments</span><br><span class="hljs-attr">disqus_shortname:</span><br><span class="hljs-comment"># Facebook comments</span><br><span class="hljs-attr">facebook:</span><br>  <span class="hljs-attr">appid:</span>                <span class="hljs-comment">#사용자 facebook app id</span><br>  <span class="hljs-attr">comment_count:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">comment_colorscheme:</span> <span class="hljs-string">light</span><br><br><span class="hljs-comment"># Google Analytics Tracking ID</span><br><span class="hljs-attr">google_analytics:</span>         <span class="hljs-comment">#사용자 google analytics id</span><br><br><span class="hljs-comment"># Addthis ID</span><br><span class="hljs-attr">addthis:</span>                  <span class="hljs-comment">#사용자 addthis id</span><br><br><span class="hljs-comment"># set your own favicon</span><br><span class="hljs-attr">favicon:</span>                  <span class="hljs-comment">#브라우저 탭에 표시된 favicon 이미지 경로</span><br><br><span class="hljs-comment"># Social Accounts</span><br><span class="hljs-attr">twitter_url:</span>              <span class="hljs-comment">#사용자 twitter url</span><br><span class="hljs-attr">twitter_handle:</span><br><span class="hljs-attr">facebook_url:</span>             <span class="hljs-comment">#사용자 facebook url</span><br><span class="hljs-attr">github_url:</span> <span class="hljs-string">https://github.com/klugjo/hexo-theme-clean-blog</span>         <span class="hljs-comment">#사용자 github url</span><br><span class="hljs-attr">gitlab_url:</span>               <span class="hljs-comment">#사용자 gitlab url</span><br><span class="hljs-attr">linkedin_url:</span>             <span class="hljs-comment">#사용자 linkin url</span><br><span class="hljs-attr">mailto:</span>                   <span class="hljs-comment">#사용자 메일</span><br></code></pre></td></tr></table></figure><p>여기까지가 <code>hexo clean-blog</code>에 대한 설정이고 이제 <code>hexo</code>블로그 자체의 설정을 변경해 보자.<br>블로그가 존재하는 최상위 폴더로 이동해서 <code>hexo</code>블로그의 설정 파일인 <code>_config.yml</code>을 열어 수정하자.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">title</span>                   <span class="hljs-comment">#블로그 메인 타이틀 입력</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">subtitle</span>             <span class="hljs-comment">#블로그 서브 타이틀 입력</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">description</span>       <span class="hljs-comment">#블로그 설명</span><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">keywords</span>             <span class="hljs-comment">#블로그 키워드</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">author</span>                 <span class="hljs-comment">#블로그 관리자 이름</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">en</span>                   <span class="hljs-comment">#블로그 언어(한국어 지원은 없으므로 en인 영어로 하자.)</span><br><span class="hljs-attr">timezone:</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://[계정이름].github.io</span><br></code></pre></td></tr></table></figure><p><code>_config.yml</code>이 <code>hexo</code> 기본 구조와 <code>themes</code>에 동일하게 포함되어 있어서 혼동할 수 있다. 정리를 해보면..</p><div class="alert info no-icon"><ul><li><strong>블로그 폴더 경로의 _config.yml</strong> - hexo 블로그 전반적인 설정</li><li><strong>themes&#x2F;테마 폴더 경로의 _config.yml</strong> - hexo 블로그에 적용된 테마의 설정</li></ul></div><h2 id="Tags-페이지-만들기"><a href="#Tags-페이지-만들기" class="headerlink" title="Tags 페이지 만들기"></a>Tags 페이지 만들기</h2><p><code>Tags</code>페이지를 만들어 <code>tag</code>들을 관리하자. <code>tags</code>페이지는 <code>post</code>를 작성할 때와 비슷한 명령어를 사용한다. 우리는 페이지를 만들 것이기 때문에 <code>post</code>가 아닌 <code>page</code>를 사용하면 된다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$ hexo new page &quot;tags&quot;<br></code></pre></td></tr></table></figure><p><code>page</code>를 생성하게 되면 <code>source</code>경로에 <code>tags</code>라는 폴더가 생기고 <code>index.md</code>라는 <code>markdown</code>파일이 생성된다. 이 <code>index.md</code>파일을 열어 아래와 같이 수정하고 저장하다.</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">---<br>title: All tags<br><span class="hljs-section">type: &quot;tags&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h2 id="Catetories-페이지-만들기"><a href="#Catetories-페이지-만들기" class="headerlink" title="Catetories 페이지 만들기"></a>Catetories 페이지 만들기</h2><p><code>Categories</code>페이지도 <code>Tags</code>페이지와 동일하게 만들면 된다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo new page <span class="hljs-string">&quot;categories&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">---<br>title: All tags<br><span class="hljs-section">type: &quot;categories&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h2 id="Post-쓰기"><a href="#Post-쓰기" class="headerlink" title="Post 쓰기"></a>Post 쓰기</h2><p>이제 어느 정도 테마의 설정이 끝났다. 이제 실제로 포스트를 써보도록 하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo new post <span class="hljs-string">&quot;post-clean-blog&quot;</span><br></code></pre></td></tr></table></figure><p><code>post</code>파일을 생성하고 수정하자.</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">---<br>title: &quot;Clean-blog 테마를 적용하다.&quot;           #post 제목<br>date: 2017-07-07 00:23:23                     #post 생성 날짜<br>tags: [&quot;hexo&quot;, &quot;clean-blog&quot;, &quot;theme&quot;]         #tags<br>cover: /assets/contact-bg.jpg                 #post 커버 이미지<br><span class="hljs-section">subtitle: &quot;처음으로 테마를 적용해보다.&quot;         #post 부제</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p><code>post</code>를 작성하는 <code>md</code>파일에서 상단에 들어가는 <code>post</code>와 관련된 설정값들이다. 적당하게 입력하도록 한다.</p><h2 id="테마-적용하기"><a href="#테마-적용하기" class="headerlink" title="테마 적용하기"></a>테마 적용하기</h2><p><code>hexo</code>테마인 <code>clean-blog</code>를 다운받았으면 이제 실제로 <code>hexo</code>블로그에서 이 테마를 사용하겠다는 언급을 해줘야 한다. 블로그 최상위 폴더로 이동하여 <code>_config.yml</code>파일을 열어 아래처럼 수정하자.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">clean-blog</span><br></code></pre></td></tr></table></figure><p>그다음 <code>hexo</code> 명령어를 통해 다시 <code>markup</code>으로 변환하고 로컬에서 확인해 보자. <code>hexo server</code>포트는 4000번이므로 <a href="http://localhost:4000/">http://localhost:4000</a>으로 접속하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><hr><p><code>hexo</code>가 <code>jekyll</code>보다는 많은 테마를 제공하지는 않지만 그래도 나름대로의 깔끔한 테마들이 넘치기에 테마를 적용하는 데는 문제가 없다. 다만 그 테마를 적용하기 위해서는 테마의 설정 파일은 <code>_config.yml</code>을 다룰 줄 알아야 하고 그 테마의 Document를 봐야한다. 물론 영어라 파악하기가 쉽지만은 않겠지만(난 그렇다.ㅠㅠ) 내가 원하는 테마를 처음에 구축해 놓으면 그 이후부터 포스팅은 <code>복붙</code>이기에 어렵지 않게 느낄 것이다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/posts/hexo-blog.html">Hexo와 Github page로 시작하는 블로그 만들기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> hexo </category>
          
          <category> github </category>
          
          <category> theme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> 블로그 </tag>
            
            <tag> hexo theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo와 Github page로 시작하는 블로그 만들기</title>
      <link href="/2017/06/23/hexo-blog/"/>
      <url>/2017/06/23/hexo-blog/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/23/hexo-blog/cover.png" alt="cover"></p><p>Jekyll보다 쉬운 hexo와 github page를 이용하여 블로그를 쉽고 빠르게 만들어보자.  <code>github page</code>는 <code>Jekyll</code>과 많이 사용되지만 hexo가 <code>Jekyll</code>보다 더욱 쉽고 빠르게 블로그를 만들 수 있다.</p><p>블로그를 호스팅해주는 포털 사이트는 많지만 이번 포스팅에서는 <strong>hexo</strong>와 <strong>github page</strong>를 이용하여 블로그를 만드는 방법을 적어보겠다. <code>github page</code>는 <code>Jekyll</code>과 많이 사용되지만 hexo가 <code>Jekyll</code>보다 더욱 쉽고 빠르게 블로그를 만들 수 있다.</p><p>자세한 설명은 건너뛰고  <strong><code>Hexo와 Github io로 시작하는 블로그 만들기</code></strong>  바로 시작하자.</p><hr><h2 id="Git과-Github"><a href="#Git과-Github" class="headerlink" title="Git과 Github"></a>Git과 Github</h2><p>개발자들이라면 <code>github</code>가 무엇인지는 알 것이다. (몰라도 상관없다.) 이 <code>github</code>에 대해 주야장천 떠들기만 하면 이 포스트의 목적을 이룰 수 없다. 그리고 이 포스트는 <strong>일반인이 보고 따라하는 것도 목적이 있기에</strong> 간단하게 설명하고 바로 시작한다.</p><p>먼저 <code>git</code>을 대충 설명하면 <code>버전 관리 도구</code>이다. <code>subversion</code> 같은 거.. (아.. 뭔가 점점 깊게 설명하게 될 것 같은..) 그냥 이 포스트에서는 이렇게 이해하자.</p><div class="alert info no-icon"><p><strong>git</strong> - 내 포스트를 웹에 올리기 위해 필요한 도구</p></div><p><code>hexo</code>와 <code>github page</code>를 통해 만드는 블로그는 일반 블로그처럼 웹에서 직접 작성하지 않는다. 내 컴퓨터에서 먼저 글을 쓰고 그걸 웹으로 보내서 브라우저에서 볼 수 있도록 하는 것이다.</p><p>그럼 <code>github</code>와 <code>github page</code>는 무엇인가?</p><div class="alert info no-icon"><p><strong>github</strong> - 내 포스트를 웹에 저장하는 저장 공간<br><strong>github page</strong> - 저장된 내 포스트를 브라우저에 출력하는 페이지</p></div><p><code>github</code>는 어떤 저장소라 생각하자. 그리고 <code>github page</code>는 저장소에 올린 글을 브라우저에서 보여주는 페이지라고 생각하면 된다. (실제 정의와 차이가 있다.)</p><h3 id="Git-설치"><a href="#Git-설치" class="headerlink" title="Git 설치"></a>Git 설치</h3><p><strong>내 포스트를 웹에 올리기 위해</strong> <code>git</code>을 설치하자.<br><a href="https://git-scm.com/">Git 공식 사이트</a>에 접속해서 우측에 Download를 진행한 후 그저 Next를 통해 빠르게 설치한다. <code>git</code>이 설치가 잘 되었다면 바탕화면에서 <code>마우스 우클릭</code>을 눌러보자. <code>Git GUI Here</code>과 <code>Git Bash Here</code>라는 Context가 생겼을 것이다. <code>Git Bash Here</code>을 눌러 Bash를 실행한 후에 아래처럼 입력하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git --version<br></code></pre></td></tr></table></figure><p>버전이 출력되는 것이 보이는가? 그럼 설치가 끝난 것이다.</p><h3 id="Github-가입-및-생성"><a href="#Github-가입-및-생성" class="headerlink" title="Github 가입 및 생성"></a>Github 가입 및 생성</h3><p><strong>내 포스트를 웹에 저장하기 위해</strong> <code>github</code>에 가입하고 저장소를 생성하자.<br>설치는 필요 없고 웹에서 가입하고 저장소를 만들 수 있다. <a href="https://github.com/">Github 공식 사이트</a> 에 접속하여 적당하게 회원가입을 한다. 그리고 로그인을 하게 되면 <code>New Repository</code>가 보일 것이다. 클릭하자.</p><p><img src="/2017/06/23/hexo-blog/thumb01.png" alt="thumb01"></p><p><code>New Repository</code>를 누르면 저장소를 생성하는 화면이 나온다. 여기서 <code>Repository Name</code>와 <code>Description</code>을 적어주는데 <code>Repository Name</code>은 아래와 같은 형식으로 적어준다.</p><div class="alert info no-icon"><p>Repository Name - <strong>계정이름.github.io</strong></p></div><p>위와 같이 생성하면 블로그를 접속할 도메인은 <strong><code>https://계정이름.github.io</code></strong>이 될 것이다. 왜 이렇게 생성해야하는 이유는 넘어가도록하겠지만 추후에 도메인 이름을 변경하는 방법을 포스팅하겠다.</p><h2 id="Git-설정"><a href="#Git-설정" class="headerlink" title="Git 설정"></a>Git 설정</h2><p><code>git</code>을 설치 후 최초에 한번 기본 설정을 진행하면 된다. 설정은 <code>이름</code>과 <code>email</code>을 등록하는 것이다. <code>github</code>를 가입하고 <code>git</code> 설정을 넣은 이유는 설정 시에 복잡하게 생각할 것 없이 <code>github</code>로 생성한 아이디나 이메일로 등록하자라는 취지에서 순서를 좀 섞었다. <code>git</code>설치 시에 열었던 <code>git bash</code>창을 다시 열어 설정을 진행하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git config --global user.name 사용자 명<br>git config --global user.email 사용자 이메일<br></code></pre></td></tr></table></figure><h2 id="Node-js와-NPM-설치"><a href="#Node-js와-NPM-설치" class="headerlink" title="Node.js와 NPM 설치"></a>Node.js와 NPM 설치</h2><p>여기까지 해서 블로그를 저장할 공간과 그 공간에 업로드할 수 있는 도구까지 설치하였다. 이제 우리가 할 일은 저장될 블로그를 만드는 것이다. 블로그는 이 포스트의 타이틀 대로 <code>hexo</code>를 이용하여 블로그를 만들 것이다. <code>hexo</code>를 사용하기 위해서는 먼저 <code>node.js</code>를 설치하여야 한다. <a href="https://nodejs.org/ko/">Node.js 공식 사이트</a>에서 <code>6.x</code> 버전을 다운받은 후 설치하도록 하자.</p><p>설치가 완료되었으면 Command( <em>window 키 + R 후에 cmd 입력</em>)창에 명령어를 입력해 보자. <code>node.js</code>와 <code>npm</code>에 대해서는 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a>를 참고하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">node -v<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm -v<br></code></pre></td></tr></table></figure><p>위 두 명령어를 입력하여 정상적으로 version이 출력된다면 설치가 완료된 것이다. </p><p><code>node.js</code>는 javascript 런타임으로 생각하고 <code>npm</code>은 <code>node.js</code>의 오픈 소스 모듈들의 집합 저장소라고 생각하자. 우리는 이 <strong>npm을 통해 hexo를 설치</strong>할 것이다.</p><h2 id="Hexo-설치"><a href="#Hexo-설치" class="headerlink" title="Hexo 설치"></a>Hexo 설치</h2><p>이제 hexo를 설치하자. 위에서 <code>npm</code>을 통해 hexo를 설치한다고 하였다. 그대로 실행해 보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>명령어 <code>npm</code>을 통해 <code>hexo-cli</code> 모듈을 <code>global</code>하게 설치한다는 명령어이다. 우리는 이 <code>Hexo</code>를 통해 여러 가지를 진행할 것이다.</p><div class="alert info no-icon"><ol><li>기본 블로그 구조 생성</li><li>새로운 포스트 생성</li><li>github page에 올리기 위해 markdown을 html로 변환</li><li>local(내 컴퓨터)에서 실행 테스트</li><li>github에 업로드</li></ol></div><hr><p>여기까지 해서 필요한 프로그램들을 모두 설치를 완료하였다. 이제 블로그를 만들고 포스팅을 하기만 하면 된다. 블로그를 생성 및 운영하면서 부가적으로 필요한 모듈들은 모두 <code>npm</code>을 통해 설치하면 된다. 필요한 모듈은 그때그때 필요할 때 설치하도록 하겠다.</p><h2 id="Hexo-블로그-생성"><a href="#Hexo-블로그-생성" class="headerlink" title="Hexo 블로그 생성"></a>Hexo 블로그 생성</h2><p>블로그와 관련된 모든 행동은 hexo명령어로 시작된다. 이는 hexo를 설치할 때 <code>-g</code> 옵션을 통해 global로 설치하였기에 가능한 것이다.</p><p>이제 블로그를 생성해 보겠다. 먼저 적당하게 폴더를 하나 만든 후에 그 폴더에 접근 후 <code>Shift + 마우스 우클릭</code>을 통해 <code>여기서 명령 창 열기</code>를 실행하자. 그리고 명령어를 입력하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo init myBlog<br><span class="hljs-built_in">cd</span> myBlog<br>npm install<br></code></pre></td></tr></table></figure><p><code>hexo init</code>명령어를 입력하게 되면 지정된 블로그 명으로 hexo가 알아서 기본적인 블로그를 만들어 준다. 그리고 생성된 블로그 경로로 이동하여 <code>npm install</code>명령어를 통해 필요한 모듈을 설치한다. 모듈은 <code>package.json</code>에 명시되어 있다.  </p><p>만들어진 블로그 폴더를 열어 내용을 확인해보자.</p><div class="alert info no-icon"><ul><li><strong>node_modules</strong> - hexo 블로그 사용에 필요한 기본적인 node.js 모듈</li><li><strong>scaffolds</strong> - hexo 페이지를 구성할 기본적인 markdown파일</li><li><strong>source</strong> - 실제로 포스트를 작성한 파일(markdown)과 이미지 등의 리소스가 저장되는 경로</li><li><strong>theme</strong> -  테마 파일이 저장되는 경로로 처음 hexo를 설치하게 되면 <code>landscape</code> 테마가 설치</li><li><strong>.gitignore</strong> - git을 통해 github에 블로그를 업로드할 때 업로드를 제외할 파일의 목록을 정의하는 파일</li><li><strong>_config.yml</strong> - hexo 블로그의 옵션을 지정하는 설정 파일</li></ul></div><h3 id="Hexo-블로그-Github에-연동하기"><a href="#Hexo-블로그-Github에-연동하기" class="headerlink" title="Hexo 블로그 Github에 연동하기"></a>Hexo 블로그 Github에 연동하기</h3><p>hexo로 생성한 블로그는 <code>github</code>에 업로드해야지만 블로그에 접속하여 확인할 수 있다. 이미 생성한 블로그를 <code>github</code>에 업로드하기 위해서는 <code>git 명령어(add, commit, push)</code>를 통해서 업로드할 수 있겠지만 <strong>hexo를 사용하면 별도의 git 명령어가 없이도 알아서 github에 업로드</strong>를 해준다. 그러기 위해서는 <code>hexo</code>와 <code>github</code>간의 연결고리가 있어야 하는데 이 연결고리는 <code>_config.yml</code>을 통해 지정할 수 있다.</p><p><code>_config.yml</code>을 열어보자.  여러 설정이 있지만 일단 넘어가고 마지막에 있는 <code>#Depolyment</code>를 보자. 여기에 <code>deploy</code>에 처음에 만든 <code>github repository</code>를 적어주면 <code>github</code>와 연동되게 된다. </p><p>아래처럼 수정하자.</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/계정이름/계정이름.github.io.git</span><br></code></pre></td></tr></table></figure><p>그리고 hexo에서 <code>github</code>에 업로드하기 위해 필요한 <code>npm</code>모듈을 설치하자. 생성한 블로그 폴더 경로로 이동하여 명령 창을 실행하여 <code>npm</code>명령어를 입력하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>위와 같이 설정하고 <code>hexo deploy</code> 명령어를 실행하게 되면 <code>_config.yml</code>에 작성해둔 주소로 소스를 업로드하게 된다.</p><p><code>_config.yml</code>에서는 블로그의 공통적인 속성을 설정할 수 있다. 예를들면 <code>title</code>은 블로그의 타이틀을 나타낸다. 자세한 내용은 <a href="https://hexo.io/ko/docs/">HEXO DOCUMENT</a>에서 확인하고 수정하도록 하자.</p><h3 id="포스트-생성하기"><a href="#포스트-생성하기" class="headerlink" title="포스트 생성하기"></a>포스트 생성하기</h3><p>이제 포스트를 작성해보도록 하자. 모든 것은 hexo를 통해 이루어진다. 생성한 블로그 폴더 경로로 이동하여 명령 창을 실행하여 아래처럼 입력하자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo new post first-post<br></code></pre></td></tr></table></figure><p>hexo의 <code>new post [포스트 파일명]</code>명령어를 입력하게 되면 포스팅이 가능한 파일을 만들어 준다. <code>Jekyll</code>과 비교했을 때 <code>hexo</code>가 편리하고 좋은 점이 이 부분이다. <strong>단 하나의 명령어 하나로 포스트 파일을 아주 쉽게 만들 수가 있다.</strong></p><p><code>블로그명/source/_posts</code>경로로 가보면 <code>first-post.md</code>파일이 생성된 것을 볼 수 있다. <code>github page</code>를 사용하기 위해서는 <code>markdown</code>언어를 사용하여 글을 작성해야 한다. <code>markdown</code>언어는 <code>md 확장자</code>를 가지며 <a href="https://ko.wikipedia.org/wiki/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4">WIKI</a>를 참고하면 그리 어려운 언어가 아니다. 모든 포스트는 <code>markdown</code>언어로 이루어진다.</p><p>생성한 파일을 열어보자. 참고로 <code>markdown</code>을 지원하는 에디터는 다양하다. 웹으로도 지원하는 에디터를 참고하여 작성하자. 나는 <a href="https://stackedit.io/">StackEdit</a>를 사용한다.</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">---<br>title: first-post<br>date: 2017-06-30 13:53:51<br><span class="hljs-section">tags:</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>기본 옵션에 대한 설명은 아래와 같다.</p><div class="alert info no-icon"><p><strong>title</strong> - 실제 페이지에 출력될 포스트의 제목<br><strong>date</strong> - 포스트를 생성한 날짜(<em>hexo 빌드 시 date 날짜별로 폴더가 생성</em>)<br><strong>tags</strong> - hexo 블로그에서 관리 될 tag 목록</p></div><p>글을 작성해 보자.</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">---<br>title: first-post<br>date: 2017-06-30 13:53:51<br><span class="hljs-section">tags:</span><br><span class="hljs-section">---</span><br><br><span class="hljs-section">## 제목</span><br>나의 첫번째 포스트입니다.<br>...<br>...<br></code></pre></td></tr></table></figure><h3 id="Hexo-빌드"><a href="#Hexo-빌드" class="headerlink" title="Hexo 빌드"></a>Hexo 빌드</h3><p>우리는 포스트 작성을 <code>markdown</code>으로 작성하였다. hexo로 이 <code>markdown</code>으로 구성된 파일을 빌드하게 되면 <code>github page</code>에 적합한 구조로 재 생성하고 <code>md</code>파일들은 <code>html</code>파일로 변경해준다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo generate 또는 hexo g<br></code></pre></td></tr></table></figure><p>빌드 후에 블로그 경로로 들어가보면 <code>public</code> 폴더가 생겼을 것이다. 이 안에는 테마에 맞게 css 파일도 생겼고 <code>first-post.md</code>파일도 <code>index.html</code>로 변경된 것을 볼 수 있다. 포스트는 날짜 별로 폴더가 생성되고 그 안에 생성된다.  <code>hexo</code>를 통해 <code>github</code>에 파일을 업로드하게 되면 실제로 업로드되는 파일은 이 <code>public</code> 폴더가 업로드된다.</p><h3 id="로컬에서-확인하기"><a href="#로컬에서-확인하기" class="headerlink" title="로컬에서 확인하기"></a>로컬에서 확인하기</h3><p>포스트를 작성하고 <code>generate</code>까지 하였다면 로컬에서 먼저 확인해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo server<br></code></pre></td></tr></table></figure><p>hexo의 내장 서버 구동하고 브라우저를 실행하여 <strong><a href="http://localhost:4000/">http://localhost:4000</a></strong>으로 접속하자. 그러면 실제로 서비스 될 블로그를 로컬에서 확인할 수 있다.</p><h3 id="Github에-업로드하기"><a href="#Github에-업로드하기" class="headerlink" title="Github에 업로드하기"></a>Github에 업로드하기</h3><p>로컬에서 확인하고 수정할 곳이 없다고 판단되면 블로그 소스들을 <code>github</code>에 업로드하여 실제 블로그 페이지 띄워 서비스해보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo deploy 또는 hexo d<br></code></pre></td></tr></table></figure><p>위의 명령어를 통해  <code>github</code>에 업로드를 하며, <code>generate 명령어</code>와 동시에 작성할 수도 있다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">hexo g --d<br></code></pre></td></tr></table></figure><p><code>deploy</code>가 되었다면 <code>github</code>에 접속하여 <code>계정명.github.io</code>의 <code>Repository</code>를 보자. 파일이 업로드가 되었는가? 그렇다면 브라우저 주소창에 <strong>https:&#x2F;&#x2F;계정명.github.io</strong>를 입력해보자. 우리가 지금까지 해온 결과물이 출력 될 것이다.</p><hr><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><code>git</code>, <code>github page</code>, <code>npm</code>, <code>node.js</code>, <code>hexo</code> 같은 단어들이 많이 나왔다. 그리고 설명도 복잡해졌다. 하지만 우리는 아무것도 몰라도 된다. <strong>목적은 포스트를 만들기</strong>이기 때문이다. 간단하게 요약하면 이렇게 된다.</p><div class="alert info no-icon"><ol><li>git 설치</li><li>github 가입 및 Repository 생성</li><li>node.js 설치</li><li>npm으로 hexo 설치</li><li>hexo로 블로그 생성</li><li>hexo와 github 연동</li><li>hexo로 새로운 포스트 생성</li><li>hexo로 빌드</li><li>로컬에서 확인</li><li>github에 업로드</li></ol></div><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2022/03/04/firebase-pwa-tutorial/">Firebase를 활용한 PWA(Progressive Web App) 앱 만들기</a><br><a href="https://kdydesign.github.io/2017/07/07/hexo-theme/">Hexo와 Github page로 만든 블로그에 Hexo 테마 적용하기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> hexo </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> 블로그 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 09. Mocha로 실제 TDD 해보기</title>
      <link href="/2017/06/21/Mocha-step-09/"/>
      <url>/2017/06/21/Mocha-step-09/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/21/Mocha-step-09/cover.png" alt="cover"></p><p>지금까지의 Tutorial을 통해 Mocha에 대해서 어느 정도 인지하고 습득하였다. 아직도 Mocha에 대해 애매모호한 기분이 들거나 뭔가 아쉬움이 남는다면 다시 돌아가 <a href="https://kdydesign.github.io/2017/06/08/Mocha/">JavaScript 단위 테스트 프레임워크 - Mocha</a>부터 살펴보도록 하자.</p><p>이제 지금까지 배운 내용을 토대로 실제로 Mocha를 가지고 TDD를 진행해 보자. 이 Tutorial을 추가한 이유는 두 가지로 분류하였다.</p><blockquote><ol><li>TDD를 이해하기 위함이며,</li><li>Mocha를 실전에 사용해 보기 위함이다.</li></ol></blockquote><p>이 두 가지를 생각하며 Tutorial을 시작해보자.</p><hr><h2 id="TDD-Test-Driven-Development-Cycle"><a href="#TDD-Test-Driven-Development-Cycle" class="headerlink" title="TDD(Test-Driven-Development) Cycle"></a>TDD(Test-Driven-Development) Cycle</h2><p>TDD는 <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-03/">Step 03: Hooks</a>에서 살짝 설명한 바가 있다. TDD는 짧은 Cycle을 반복적으로 테스트하는 개발 프로세스로 테스트 코드를 먼저 작성하고 작성된 테스트 코드를 패스할 수 있도록 비즈니스 로직을 개발하는 방법이다. 자세한 TDD가 무엇인지는 구글링을 통해 알아보자. </p><p>시작하기에 앞서 TDD의 프로세스를 생각해두자. 위에서 말했듯이 하나의 짧은 Cycle을 반복적으로 수행하는 것이다. 이 Cycle의 대략적인 순서는 이렇다.</p><div class="alert info no-icon"><ol><li>개발 <strong>명세 작성</strong></li><li>개발 명세에 따른 <strong>테스트 코드 작성</strong></li><li>테스트 실행</li><li>테스트가 성공하도록 <strong>최소한의 비스니스 로직 작성</strong></li><li>테스트 실행</li><li><strong>테스트 케이스 추가</strong></li><li>테스트 실행</li><li>테스트 코드 및 테스트 케이스 <strong>Refactoring</strong></li><li>테스트 실행</li></ol></div><p>위의 순서대로 우리는 간략하게 <strong>Validation Check Plug-in</strong>을 만들어 보면서 TDD와 Mocha를 동시에 파악할 것이다.</p><h2 id="1-명세-작성"><a href="#1-명세-작성" class="headerlink" title="1. 명세 작성"></a>1. 명세 작성</h2><p>프로세스 순서에 따라 명세를 작성한다. 명세를 작성하기 위해서는 우리가 무엇을 개발해야 하는지 목표를 정확하게 파악하는 것이 좋다. 우리는 <strong>Validation Check Plug-in</strong> 만드는 것을 목표로 필요한 사항을 명세에 적어볼 수 있겠다. </p><div class="alert info no-icon"><ul><li>이메일의 형식을 검증한다.</li><li>전화번호의 형식을 검증한다.</li><li>이름의 형식을 검증한다.</li></ul></div><p>간략하게 3가지의 명세를 적어보았다. Validation Check를 진행하는데 필요한 몇 가지의 기능을 나열한 것이다.</p><h2 id="2-개발-명세에-따른-테스트-코드-작성"><a href="#2-개발-명세에-따른-테스트-코드-작성" class="headerlink" title="2. 개발 명세에 따른 테스트 코드 작성"></a>2. 개발 명세에 따른 테스트 코드 작성</h2><p>개발 명세를 작성하였으니 테스트 코드를 작성해 보자. 첫 번째로 <code>이메일의 형식을 검증한다.</code>는 것에 대해 테스트 코드를 작성해 볼 것이다. <code>Assertions</code>는 <code>Chai</code>를 사용할 것이다. <code>Chai</code>에 대해서는 <a href="https://kdydesign.github.io/2017/06/15/Mocha-step-02/">Step 02: Assertion-chai</a>를 참고하자.</p><p>해당 파일은 <code>test.js</code>와 같은 테스트 파일이 될 것이다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>);<br><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">suite</span>(<span class="hljs-string">&#x27;#Validation Check&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;이메일의 형식을 검증한다.&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> validate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Validate</span>();<br>        <span class="hljs-keyword">var</span> result = validate.<span class="hljs-title function_">email</span>(<span class="hljs-string">&#x27;test@naver.com&#x27;</span>);<br><br>        <span class="hljs-title function_">expect</span>(result).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">true</span>;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>우리는 TDD를 진행할 것이니 테스트 스위트의 스타일을 <code>describe</code>, <code>it</code>이 아닌 <code>suite</code>, <code>test</code>를 사용했다. 물론 Mocha의 옵션 역시 <code>--ui tdd</code>로 주어야 한다. <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-03/">Step 03: Hooks</a>을 참고하자.</p><h2 id="3-테스트-실행"><a href="#3-테스트-실행" class="headerlink" title="3. 테스트 실행"></a>3. 테스트 실행</h2><p>위에 테스트 코드를 실행해보자. 당연히 <strong>비즈니스 코드</strong>가 없기 때문에 오류가 발생 될 것이다. 여기까지만 보아도 왜 TDD가 <code>테스트 주도 개발</code>인지 알 수 있다. 테스트 코드를 먼저 작성 후 이후에 비즈니스 코드를 작성한다.</p><h2 id="4-테스트가-성공하도록-최소한의-비즈니스-로직-작성"><a href="#4-테스트가-성공하도록-최소한의-비즈니스-로직-작성" class="headerlink" title="4. 테스트가 성공하도록 최소한의 비즈니스 로직 작성"></a>4. 테스트가 성공하도록 최소한의 비즈니스 로직 작성</h2><p>이제 작성한 테스트 코드가 통과될 수 있도록 최소한으로써 비즈니스 코드를 작성해보자. 해당 파일은 <code>validate.js</code>와 같은 적당한 파일이 될 것이다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Validate</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><br><span class="hljs-title class_">Validate</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">email</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">email</span>) &#123;<br>        <span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]&#123;2,3&#125;$/i</span>;<br><br>        <span class="hljs-keyword">return</span> regex.<span class="hljs-title function_">test</span>(email);<br>    &#125;<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Validate</span>;<br></code></pre></td></tr></table></figure><p><code>validate.js</code>를 만들었으니 이미 만든 테스트 코드가 있는 <code>test.js</code>에 해당 모듈을 불러오자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Validate</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./validate&#x27;</span>);<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>여기서 언급할 내용은 코드의 설명이 아닌 TDD에 대한 내용이다. 처음 TDD를 접하게 되면 다소 난감한 상황에 부딪힌다. 그 부분은 첫 테스트 코드를 작성할 때이다. 막막하기 그지없다. 무엇을 시작해야 할지 모르기 때문이다. 이때 기억해야 할 것은 이것이다.</p><div class="alert info no-icon"><ul><li><strong>given</strong> - 어떤 조건이 필요한가.</li><li><strong>when</strong> - 어떻게 동작이 진행되는가.</li><li><strong>then</strong> - 동작에 대한 결과가 어떠한가.</li></ul></div><p>?????… 무슨 말이지..<br>이 내용을 위에 작성한 코드에 대입해보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>);<br><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">suite</span>(<span class="hljs-string">&#x27;#Validation Check&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;이메일의 형식을 검증한다.&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//given</span><br>        <span class="hljs-keyword">var</span> validate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Validate</span>();<br>        <br>        <span class="hljs-comment">//when</span><br>        <span class="hljs-keyword">var</span> result = validate.<span class="hljs-title function_">email</span>(<span class="hljs-string">&#x27;test@naver.com&#x27;</span>);<br><br>        <span class="hljs-comment">//then</span><br>        <span class="hljs-title function_">expect</span>(result).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">true</span>;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>주석을 적어놓으니 이해가 되는 듯하다. TDD에 익숙하지 않다면 <code>given</code>, <code>when</code>, <code>then</code> 패턴을 기억하고 주석을 먼저 적고 시작하자.</p><h2 id="5-테스트-실행"><a href="#5-테스트-실행" class="headerlink" title="5. 테스트 실행"></a>5. 테스트 실행</h2><p>이제 테스트 코드를 실행해보자. 적당하게 비즈니스 코드를 작성하였다. 테스트 코드가 실패한다면 비즈니스 코드를 수정하자.</p><h2 id="6-테스트-케이스-추가"><a href="#6-테스트-케이스-추가" class="headerlink" title="6. 테스트 케이스 추가"></a>6. 테스트 케이스 추가</h2><p>5번에서 테스트가 성공하였다면 바로 변칙적인 다른 테스트 케이스를 추가하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>);<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Validate</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./validate&#x27;</span>);<br><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">suite</span>(<span class="hljs-string">&#x27;#Validation Check&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;이메일의 형식을 검증한다.&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//given</span><br>        <span class="hljs-keyword">var</span> validate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Validate</span>();<br><br>        <span class="hljs-comment">//when</span><br>        <span class="hljs-keyword">var</span> result1 = validate.<span class="hljs-title function_">email</span>(<span class="hljs-string">&#x27;test@naver.com&#x27;</span>);<br>        <span class="hljs-keyword">var</span> result2 = validate.<span class="hljs-title function_">email</span>(<span class="hljs-string">&#x27;test_1234@naver.com&#x27;</span>);<br>        <span class="hljs-keyword">var</span> result3 = validate.<span class="hljs-title function_">email</span>(<span class="hljs-string">&#x27;!@test@naver.com&#x27;</span>);<br>        <span class="hljs-keyword">var</span> result4 = validate.<span class="hljs-title function_">email</span>(<span class="hljs-string">&#x27;test#naver.com&#x27;</span>);<br>        <span class="hljs-keyword">var</span> result5 = validate.<span class="hljs-title function_">email</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>        <span class="hljs-keyword">var</span> result6 = validate.<span class="hljs-title function_">email</span>(<span class="hljs-string">&#x27;naver.com&#x27;</span>);<br><br>        <span class="hljs-comment">//then</span><br>        <span class="hljs-title function_">expect</span>(result1).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">true</span>;<br>        <span class="hljs-title function_">expect</span>(result2).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">true</span>;<br>        <span class="hljs-title function_">expect</span>(result3).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">false</span>;<br>        <span class="hljs-title function_">expect</span>(result4).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">false</span>;<br>        <span class="hljs-title function_">expect</span>(result5).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">false</span>;<br>        <span class="hljs-title function_">expect</span>(result6).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">false</span>;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="7-테스트-실행"><a href="#7-테스트-실행" class="headerlink" title="7. 테스트 실행"></a>7. 테스트 실행</h2><p>테스트를 실행해보자. 여기서 테스트 실패가 나온다면 비즈니스코드가 잘못된 것이니 테스트가 성공하도록 비즈니스 코드를 수정하면 된다.</p><h2 id="8-테스트-코드-및-테스트-케이스-Refactoring"><a href="#8-테스트-코드-및-테스트-케이스-Refactoring" class="headerlink" title="8. 테스트 코드 및 테스트 케이스 Refactoring"></a>8. 테스트 코드 및 테스트 케이스 Refactoring</h2><p>테스트 케이스를 추가하고도 완료되었다면 테스트 코드 및 비즈니스 코드를 <code>Refactoring</code>을 진행하면 된다. 테스트 코드를 <code>Refactoring</code>하는 이유는 당연히 유지관리를 위해서이다. 테스트 코드는 일회성이 아닌 유지관리 포인트에 포함되는 사항이기 때문이다.<br>6번에서 작성한 코드가 반복적인 부분이 많다. result1, 2, 3, 4….라니… 수정하도록 하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>);<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Validate</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./validate&#x27;</span>);<br><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">suite</span>(<span class="hljs-string">&#x27;#Validation Check&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;이메일의 형식을 검증한다.&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//given</span><br>        <span class="hljs-keyword">var</span> successTestCase = [<br>            <span class="hljs-string">&#x27;test@naver.com&#x27;</span>, <span class="hljs-string">&#x27;test_1234@naver.com&#x27;</span><br>        ];<br><br>        <span class="hljs-keyword">var</span> failTestCase = [<br>            <span class="hljs-string">&#x27;!@test@naver.com&#x27;</span>, <span class="hljs-string">&#x27;test#naver.com&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;naver.com&#x27;</span><br>        ];<br><br>        <span class="hljs-keyword">var</span> validate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Validate</span>();<br><br>        successTestCase.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">testCase</span>) &#123;<br>            <span class="hljs-comment">//when</span><br>            <span class="hljs-keyword">var</span> result = validate.<span class="hljs-title function_">email</span>(testCase);<br><br>            <span class="hljs-comment">//then</span><br>            <span class="hljs-title function_">expect</span>(result).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">true</span>;<br>        &#125;);<br><br>        failTestCase.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">testCase</span>) &#123;<br>            <span class="hljs-comment">//when</span><br>            <span class="hljs-keyword">var</span> result = validate.<span class="hljs-title function_">email</span>(testCase);<br><br>            <span class="hljs-comment">//then</span><br>            <span class="hljs-title function_">expect</span>(result).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">false</span>;<br>        &#125;);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>가독성을 위해 <code>success</code>와 <code>fail</code>로 나눠 보았다. 자세히 보니 명세에 적힌 기능을 구현해본다면 <code>Validate</code> 객체를 테스트 케스트마다 생성할 테니 미리 <code>Refactoring</code>을 하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>);<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Validate</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./validate&#x27;</span>);<br><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">suite</span>(<span class="hljs-string">&#x27;#Validation Check&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> validate = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">var</span> successTestCase = [];<br>    <span class="hljs-keyword">var</span> failTestCase = [];<br><br>    <span class="hljs-title function_">suiteSetup</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        validate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Validate</span>();<br>    &#125;);<br><br>    <span class="hljs-title function_">suiteTeardown</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        validate = <span class="hljs-literal">null</span>;<br>        successTestCase = [];<br>        failTestCase = [];<br>    &#125;);<br><br>    <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;이메일의 형식을 검증한다.&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">//given</span><br>        successTestCase = [<br>            <span class="hljs-string">&#x27;test@naver.com&#x27;</span>, <span class="hljs-string">&#x27;test_1234@naver.com&#x27;</span><br>        ];<br><br>        failTestCase = [<br>            <span class="hljs-string">&#x27;!@test@naver.com&#x27;</span>, <span class="hljs-string">&#x27;test#naver.com&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;naver.com&#x27;</span><br>        ];<br><br>        successTestCase.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">testCase</span>) &#123;<br>            <span class="hljs-comment">//when</span><br>            <span class="hljs-keyword">var</span> result = validate.<span class="hljs-title function_">email</span>(testCase);<br><br>            <span class="hljs-comment">//then</span><br>            <span class="hljs-title function_">expect</span>(result).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">true</span>;<br>        &#125;);<br><br>        failTestCase.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">testCase</span>) &#123;<br>            <span class="hljs-comment">//when</span><br>            <span class="hljs-keyword">var</span> result = validate.<span class="hljs-title function_">email</span>(testCase);<br><br>            <span class="hljs-comment">//then</span><br>            <span class="hljs-title function_">expect</span>(result).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">false</span>;<br>        &#125;);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="9-테스트-실행"><a href="#9-테스트-실행" class="headerlink" title="9. 테스트 실행"></a>9. 테스트 실행</h2><p>실행해보자. 테스트가 실패한다면 비즈니스 코드 수정 후 7번으로 돌아가 반복적으로 테스트를 진행하면 된다.</p><hr><p>여기까지가 Mocha의 마지막 지점이다. 물론 명세에 있는 내용을 다 포스팅하진 않았지만, 처음에 말했듯이 <code>하나의 짧은 Cycle을 반복적으로 수행하는 것</code>이다. 물론 테스트함에 있어서 특수한 케이스가 나올 수 있지만, TDD를 사용하는 목적을 다시 생각해 보면 어느 부분부터 다시 시작해야 하는지 알 수 있을 것이다. </p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 08. IDE Edit Plug-in (IntelliJ)</title>
      <link href="/2017/06/19/Mocha-step-08/"/>
      <url>/2017/06/19/Mocha-step-08/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/19/Mocha-step-08/cover.png" alt="cover"></p><p>개발자들은 자기가 사용하는 IDE가 있을 것이다. IDE를 사용하는 이유는 더 편리하기 때문이다. 당연하다. bash, nodepad 보다는 훨씬 편하니까. 나 역시 <code>IntelliJ</code>를 사용하고 있다. 이 <code>IntelliJ</code>에서는 Mocha를 좀 더 다루기 쉽게 Plug-in을 지원하고 있다. <code>IntelliJ</code>뿐만 아니라 <code>Webstorm</code> 등의 <code>JETBRAIN</code> 제품군에서 지원하고있다.<br>이번 Tutorial은 <code>IntelliJ</code>에서 Mocha를 손쉽게 사용하는 방법을 배워보도록 하겠다. <code>JETBRAINS</code> 제품군을 사용하지 않는다면 해당 Tutorial은 건너 뛰도록하자.</p><hr><h2 id="Node-js-및-Plug-in-설치"><a href="#Node-js-및-Plug-in-설치" class="headerlink" title="Node.js 및 Plug-in 설치"></a>Node.js 및 Plug-in 설치</h2><p>Mocha를 사용해보기에 앞서 먼저 <code>Node.js</code> 와 <code>IntelliJ NodeJs Plug-in</code>을 설치하자. 먼저 <a href="https://nodejs.org/ko/">여기서</a> Node.js를 설치한다. 기본적으로 <code>IntelliJ</code>를 설치할 때 별도의 설치 여부가 나오지만 설치가 되어있지 않다면 설치하도록 하자.<br><code>ctrl + shift + a</code> 또는 <code>IntelliJ</code>설정 창에서 <code>plugins</code>를 검색하여 해당 창을 실행 후 <code>nodejs</code>를 검색하였을 때 설치가 되어있지 않으면 <code>Browser Repositories</code>에서 <code>nodejs</code>를 설치하도록 하자. </p><h2 id="Mocha-Configurations"><a href="#Mocha-Configurations" class="headerlink" title="Mocha Configurations"></a>Mocha Configurations</h2><p><code>Node.js</code>가 설치되었다면 <code>Mocha</code> runner 또는 compiler를 추가하자. <code>run/debug configurations</code> 창에서 <code>+</code>버튼을 눌러 <code>Mocha</code>를 선택한다. 이후 출력되는 설정 창에서 수정해야 할 부분은 아래를 참고하자.</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>Node interpreter</td><td>node.exe 경로</td></tr><tr><td>Working directory</td><td>mocha 프로젝트 경로</td></tr><tr><td>Mocha package</td><td>mocha 패키지 경로(ex. npm\node_modules\mocha</td></tr><tr><td>User Interface</td><td>사용자 인터페이스 설정</td></tr><tr><td>Test directory</td><td>테스트 파일 경로(ex. test.js)</td></tr></tbody></table><p><img src="/2017/06/19/Mocha-step-08/image01.png" alt="image01"></p><p>설정이 완료되면 실행해 보도록 하자. 실행을 해보면 테스트 스위트와 테스트 케이스별로 성공, 실패 여부를 확인할 수 있다. 여기서 <strong><code>IntelliJ</code>에서 실행하면 좋은 점 두 가지</strong>가 있다.</p><div class="alert info no-icon"><ol><li>Break Point를 통한 Debugging</li><li>HTML 출력</li></ol></div><p><img src="/2017/06/19/Mocha-step-08/image02.png" alt="image02"></p><p>이전 Tutorial <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-06/">Step 06: 브라우저에서의 Mocha 지원</a>에서 Mocha를 브라우저에서 구동하는 방법을 배웠었는데 <code>IntelliJ</code>를 사용하면 별도의 HTML파일을 출력할 수가 있다. 그리고 불편하기만하던 Mocha의 <code>--debug</code> 옵션을 <code>IntelliJ</code>에서는 Break Point를 통해서 쉽게 Debugging이 가능하다.</p><hr><p>IDE Tool을 사용하면 어떤 개발 프레임워크이든 쉽게 이용할 수가 있다. 그만큼 개발 속도 역시 빠르다 할 수 있다. 이번 Tutorial을 통해 우리는 이제 Mocha를 사용하여 단위 테스트를 할 수 있는 최적화된 환경을 만들 수 있다.<br>이제 마지막으로 <code>Mocha를 활용하여 실제 TDD</code>를 어떻게 하는지 알아볼 차례이다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/21/Mocha-step-09/">Step 09: Mocha로 실제 TDD 해보기</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> intelliJ </tag>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 07. Mocha Options</title>
      <link href="/2017/06/19/Mocha-step-07/"/>
      <url>/2017/06/19/Mocha-step-07/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/19/Mocha-step-07/cover.png" alt="cover"></p><p>이제 Mocha의 기본적인 사용법을 모두 터득하였다. 지금까지 배운 것만으로도 어느 정도의 Test가 가능하다. 하지만 우리가 항상 개발할 떄에 Framework를 찾는 이유는 무엇인가 개발을 할 때 손쉽게 개발하기 위해서이다. Mocha 역시 옵션을 조정하여 좀 더 편리하게 사용할 수 있는데 이번 Tutorial에서는 이 옵션에 대해서 알아보겠다.</p><hr><h2 id="기본-옵션"><a href="#기본-옵션" class="headerlink" title="기본 옵션"></a>기본 옵션</h2><p>Mocha의 기본 옵션 먼저 확인해 보도록 하자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mocha -h<br></code></pre></td></tr></table></figure><p>꽤 많은 옵션이 출력된다. 하나하나 설명하기는 양이 많기에 일부 가장 자주 쓰이는 것으로 알아보자.</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-reporters</td><td>테스트 결과를 출력할 수 있는 레포트 형식 목록을 출력</td></tr><tr><td>-R, –reporter <code>&lt;name&gt;</code></td><td>테스트 결과를 출력할 레포트 형식을 지정</td></tr><tr><td>-d, –debug</td><td>Node늬 Debug 모드 활성화</td></tr><tr><td>-g, –grep <code>&lt;pettern&gt;</code></td><td>정규식 패턴에 일치하는 특정 테스트 실행</td></tr><tr><td>-f, –fgrep <code>&lt;string&gt;</code></td><td>특정 문자열이 포함된 테스트 실행</td></tr><tr><td>-r, –require <code>&lt;name&gt;</code></td><td>require 할 모듈 명을 미리 지정하여 미리 특정 모듈을 포함</td></tr><tr><td>-t, –timeout <code>&lt;ms&gt;</code></td><td>timeout을 지정(default : 2000ms)</td></tr><tr><td>-u, –ui <code>&lt;name&gt;</code></td><td>사용자 인터페이스 지정(tdd, bdd, qunit, exports)</td></tr><tr><td>-w, –watch</td><td>테스트 파일 수정 시 자동 반영</td></tr></tbody></table><p>이 외에 다른 옵션은 <code>mocha -h</code>를 통해 확인할 수 있다.</p><h2 id="mocha-opts"><a href="#mocha-opts" class="headerlink" title="mocha.opts"></a>mocha.opts</h2><p>위처럼 기본 옵션을 <code>Command</code>를 통해 지정할 수 있겠지만 다른 방법으로 더욱 편리하게 사용할 수 있다. 그 방법으로는 <code>mocha.opts</code>파일에 필요한 옵션들을 지정해 놓는 것이다. 대부분의 <code>test</code> 파일들은 <code>test</code> 또는 <code>tests</code> 폴더에 모아두는 것이 관례이다. 이 <code>test</code> 또는 <code>tests</code> 폴더 안에 미리 옵션들을 정의 해둔 <code>mocha.opts</code>를 넣어두면 테스트 시에 자동으로 파일에 정의된 옵션들을 사용하여 테스트하게 된다.</p><p>먼저 프로젝트 안에 <code>tests</code>라는 폴더를 만들고 그 안에 <code>mocha.opts</code>파일을 만들자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> tests<br><span class="hljs-built_in">cd</span> tests<br><span class="hljs-built_in">touch</span> mocha.opts<br></code></pre></td></tr></table></figure><p>이제 <code>mocha.opts</code>에 원하는 옵션을 지정해주면 된다.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">--require should<br>--reporter dot<br>--ui bdd<br></code></pre></td></tr></table></figure><p>위 옵션은 <code>should</code> 라이브러리를 포함하고 <code>reporter</code>는 <code>dot</code>로 사용하며, <code>사용자 인터페이스</code>는 <code>bdd</code>를 사용한다는 옵션이다.</p><h2 id="package-json에-Options-지정"><a href="#package-json에-Options-지정" class="headerlink" title="package.json에 Options 지정"></a>package.json에 Options 지정</h2><p><code>mocha.opts</code>로 사용하면 편리하지만 이 밖에도 <code>package.json</code>에도 옵션을 명시할 수 있다. <code>package.json</code>에서 <code>script</code>항목에 위와 동일하게 옵션을 추가하여 수정한다.</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha test --reporter spec --ui bdd&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><p>Mocha는 옵션뿐만 아니라 IDE Tools에서도 편리하게 사용할 수 있다. 다음 편에서는 <code>JETBRAINS</code>제품 군(<code>IntelliJ</code>,<code>WebStorm</code> 등)에서 Mocha를 쉽게 사용하는 방법을 알아보겠다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/19/Mocha-step-08/">Step 08: IDE Edit Plug-in (IntelliJ)</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 06. Mocha 브라우저 구동</title>
      <link href="/2017/06/16/Mocha-step-06/"/>
      <url>/2017/06/16/Mocha-step-06/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/16/Mocha-step-06/cover.png" alt="cover"></p><p><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>부터 시작으로 지금까지 우리는 <code>$ mocha</code> 명령을 통해 터미널에서 실행하였다. Mocha는 터미널 뿐만 아니라 <code>gulp</code>의 <code>task</code>를 통해 실행도 가능하지만, 이 밖에도 <code>브라우저에서 구동</code>되도록 지원하고 있다.</p><p>우리는 이번 Tutorial에서는 <code>Mocha를 브라우저에서 구동</code>하는 방법을 알아보겠다.</p><hr><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><p>먼저 <code>html</code> 파일을 생성하도록 하겠다. 추후에 이 페이지를 실행시켜 Mocha를 구동할 것입니다.</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ko&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Mocha Tests<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../node_modules/mocha/mocha.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mocha&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../node_modules/mocha/mocha.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../node_modules/chai/chai.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    mocha.<span class="hljs-title function_">setup</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">ui</span>: <span class="hljs-string">&#x27;bdd&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">reporter</span>: <span class="hljs-string">&#x27;html&#x27;</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 테스트 코드 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;test.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    mocha.checkLeaks();<br>    mocha.run();<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>이 코드는 다 알 것이라고 생각된다.<br>코드를 보게 되면 Mocha에 필요한 <code>mocha.css</code>와 <code>mocha.js</code> 그리고 <code>chai.js</code>파일을 불러왔다. 해당 Tutorial에서는 <code>node_modules</code>에 포함된 파일을 불러왔지만 <code>CDN</code>으로 불러올 수 있다.</p><p><code>CDN</code>은 아래를 참고하자.</p><div class="alert info no-icon"><p><a href="https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.css">https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.css</a><br><a href="https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.js">https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.js</a><br><a href="https://cdnjs.cloudflare.com/ajax/libs/chai/4.0.2/chai.min.js">https://cdnjs.cloudflare.com/ajax/libs/chai/4.0.2/chai.min.js</a></p></div><p>이렇게 필요한 소스를 불러온 후 Mocha 설정에 관련된 <code>setup</code>을 진행한다. 그런 다음 테스트 스위트와 테스트 케이스가 포함된 <code>.js</code>파일을 로드한다. 마지막으로 <code>onload</code> 인터페이스와 함께 <code>run()</code>을 통해 Mocha를 실핼하게 되어있다. 우리는 아직 <code>test.js</code>를 정의하지 않았기 때문에 실행을 한다고 하더라고 결과가 나오지는 않는다.</p><h2 id="test-js"><a href="#test-js" class="headerlink" title="test.js"></a>test.js</h2><p>이제 <code>index.html</code>파일이 준비되어 있으니 <code>test.js</code>를 정의하도록 하겠다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Array&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> arr;<br><br>    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>    &#125;);<br><br>    <span class="hljs-title function_">afterEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        arr = [];<br>    &#125;);<br><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;array test&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">an</span>.<span class="hljs-title function_">instanceOf</span>(<span class="hljs-title class_">Array</span>);<br>        <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">an</span>(<span class="hljs-string">&#x27;array&#x27;</span>).<span class="hljs-property">that</span>.<span class="hljs-property">is</span>.<span class="hljs-property">not</span>.<span class="hljs-property">empty</span>;<br>        <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">that</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">4</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>터미널에서 실행할 때와 다른 점은 <code>chai.expect</code> 부분이다. <code>브라우저 구동</code>할 때는 이미 <code>index.html</code>에 우리가 Chai를 불러왔기 때문에 별도로 <code>require</code>하지 않아도 된다.<br>테스트의 내용을 잠깐 살펴보면 Array의 타입과 데이터가 존재하는지에 대한 몇 가지 테스트이다. 이제 브라우저를 실행하면 결과가 출력된다.</p><p><img src="/2017/06/16/Mocha-step-06/result_thumbnail_01.png" alt="result01"></p><p>터미널보다 훨씬 더 보기 편리하다. 해당 테스트 케이스를 클릭하게 되면 테스트를 진행한 코드를 볼 수가 있다. 그리고 상단에는 <code>passes</code>, <code>failures</code>, <code>duration</code>을 확인할 수 있다.<br>테스트가 너무 짧은가? 테스트 케이스를 더 추가하여 다시 확인해 보자.</p><p>아래 코드를 <code>test.js</code>에 이어서 작성하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;array compare&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-title function_">eql</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br>&#125;);<br><br><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;array member&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">done</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">members</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);<br>        <span class="hljs-title function_">done</span>();<br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>먼저 결과를 보자.</p><p><img src="/2017/06/16/Mocha-step-06/result_thumbnail_02.png" alt="result02"></p><p><code>array member</code>테스트의 경우 브라우저에도 <code>3000ms</code>뒤에 실행하는 것을 볼 수 있다. 그리고 <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-04/">Step 04: 비동기 처리</a>에서 배운 비동기로 처리하였으며, <code>3000ms</code>후에 실행하기에 오류가 발생한다. 발생한 오류에 대한 내용도 출력이 되는 것을 확인할 수 있다.</p><h2 id="외부-모듈-불러오기"><a href="#외부-모듈-불러오기" class="headerlink" title="외부 모듈 불러오기"></a>외부 모듈 불러오기</h2><p>우리는 <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-05/">Step 05: 외부 모듈 테스트</a>을 통해 외부 모듈을 불러와서 테스트를 작성하였다. 그리고 <code>브라우저 구동</code>에서 외부 모듈을 어떻게 불러오는지 대략적인 설명이 있었다. 그 내용을 자세하게 알아보겠다.<br><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-05/">Step 05: 외부 모듈 테스트</a>에서 사용한 <code>ModuleSum.js</code>를 사용하겠다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br></code></pre></td></tr></table></figure><p>동일하게 합계를 구하는 함수이다. 하지만 다른 점은 <code>export</code>를 하지 않았다는 것이다. 단순한 <code>function</code>이다. 이제 이 <code>ModuleSum.js</code>는 <code>index.html</code>에서 불러오도록 하겠다.</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- //... --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mocha&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../node_modules/mocha/mocha.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../node_modules/chai/chai.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;ModuleSum.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- //... --&gt;</span><br></code></pre></td></tr></table></figure><p>불러온 <code>ModuleSum.js</code>를 가지고 테스트 케이스를 작성하겠다. <code>test.js</code>에 테스트 스위트를 추가해야겠다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#ModuleSum&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;sum()&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">eql</span>(<span class="hljs-number">3</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step06-Running%20Mocha%20in%20the%20Browser">예제 코드</a></p><hr><p>Mocha의 <code>브라우저 구동</code>은 매우 다루기 쉽고 작성하기도 쉽다. <code>index.html</code>에 설정만 적당하게 잘 만들어 놓는다면 이보다 편한 것도 없다.<br>그럼 이제 설정을 적당하게 만드는 방법과 Mocha의 설정은 어떻게 하고 어떤 것들이 있는지 확인해보겠다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/19/Mocha-step-07/">Step 07: Options</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 05. 외부 모듈 테스트</title>
      <link href="/2017/06/16/Mocha-step-05/"/>
      <url>/2017/06/16/Mocha-step-05/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/16/Mocha-step-05/cover.png" alt="cover"></p><p>어느 프로그램 언어나 마찮가지겠지만 JavaScript 역시 하나의 <code>.js</code>파일에 코딩하진 않는다. Mocha 역시 하나의 <code>test.js</code> 파일에 모두 테스트 케이스를 적진 않는다.<br>이번 Tutorial에서는 외부 모듈을 불러와서 테스트하는 방법을 알아보겠다. 생각보다 분량이 적지만 매우 효율적인 방법이 될 것이다.</p><hr><h2 id="외부-모듈-생성하기"><a href="#외부-모듈-생성하기" class="headerlink" title="외부 모듈 생성하기"></a>외부 모듈 생성하기</h2><p>앞으로 있을 Tutorial에서는 Mocha를 <code>브라우저에서 구동 방법</code>을 배울 것이다. 이에 앞서 일단 우리는 터미널에서 돌려보도록 하겠다. 일단 간단하게 <code>sum()</code>함수를 만들어 보도록 하자. 명칭 그대로 합계를 내는 함수이다. </p><p>파일명은 <code>ModuleSum</code>이라고 정의해 보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">sum</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) &#123;<br>        <span class="hljs-keyword">return</span> num1 + num2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>매우 간단한 함수이다. 위에서 <code>브라우저에서 구동</code>하는 방법을 배운다는 건 이 부분이 약간 다르기 때문이다. 우리는 <code>ModuleSum</code>을 <code>export</code>하였지만 <code>브라우저 구동</code> 방식에서는 그저 <code>Function</code>만 생성하면 된다. 이미 <code>index.html</code>에서 <code>script</code>를 Import하기 때문이다.</p><h2 id="외부-모듈-불러오기"><a href="#외부-모듈-불러오기" class="headerlink" title="외부 모듈 불러오기"></a>외부 모듈 불러오기</h2><p>이제 외부 모듈인 <code>ModuleSum</code>이 생성되었다. 이 모듈을 불러와서 테스트만 진행하면 끝이다.</p><p><code>test.js</code>파일을 생성하고 코드를 작성하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>),<br>    moduleSum = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./ModuleSum&#x27;</span>),<br>    expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#ModuleSum&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;sum()&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">expect</span>(moduleSum.<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-title function_">expect</span>(moduleSum.<span class="hljs-title function_">sum</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-title function_">expect</span>(moduleSum.<span class="hljs-title function_">sum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-number">5</span>);<br>    &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p>실행하여 결과를 확인해 보자.</p><p><img src="/2017/06/16/Mocha-step-05/result_thumbnail_01.png" alt="result01"></p><p>설명이 별로 필요하지 않는 코드이다. <code>require</code>로 이미 생성한 <code>ModuleSum</code>을 불러오고 적절한 테스트 케이스를 통해 테스트를 진행한다. </p><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step05-Import%20Modules">예제 코드</a></p><hr><p>사실 이 Tutorial을 쓸까말까 고민했었는데 누군가에게 도움이 되길 바라며 짤막하게 포스팅 해보았다. 다음 Tutorial에서는 아까 언급한 <code>브라우저에서 구동 방법</code>을 진행하도록 하겠다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-06/">Step 06: 브라우저에서의 Mocha 지원</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 04. 동기/비동기 처리</title>
      <link href="/2017/06/16/Mocha-step-04/"/>
      <url>/2017/06/16/Mocha-step-04/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/16/Mocha-step-04/cover.png" alt="cover"></p><p>Mocha에서의 비동기 처리는 매우 간단 명료하다. 어떻게 보면 <code>동기 처리</code>보다 더욱 간단하다.</p><hr><h2 id="동기-처리"><a href="#동기-처리" class="headerlink" title="동기 처리"></a>동기 처리</h2><p><code>비동기 처리</code>에서 시작하기 앞서 <code>동기 처리</code>를 먼저 보겠다. 일반적으로 우리가 Mocha를 사용하는 것은 <code>동기 방식</code>이다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>),<br>    expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#indexOf()&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;값이 일치하지 않는 경우 -1을 return 한다.&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">5</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-title function_">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-title function_">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">0</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(-<span class="hljs-number">1</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>동기 처리</code>에는 콜백이 없으며, 이 콜백을 생략하면 Mocha는 자동으로 다음 테스틀 계속 진행하도록 되어있다.</p><h2 id="비동기-처리"><a href="#비동기-처리" class="headerlink" title="비동기 처리"></a>비동기 처리</h2><p><code>비동기 처리</code>는 그저 콜백을 호출하기만 하면 된다. 콜백(일반적으로 <code>done()</code>이라 함.)을 추가함으로써 테스트(<code>it()</code> 또는 <code>test()</code>)가 완료하기 위해 이 함수가 호출될 때까지 기다리게 된다.</p><p>코드를 보도록 하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>),<br>    expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#indexOf()&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//비동기</span><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">done</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">5</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(-<span class="hljs-number">1</span>);<br>            <span class="hljs-title function_">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-number">2</span>);<br>            <span class="hljs-title function_">expect</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">0</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(-<span class="hljs-number">1</span>);<br><br>            <span class="hljs-title function_">done</span>();<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="/2017/06/16/Mocha-step-04/result_thumbnail_01.png" alt="result01"></p><p><code>setTimeout</code> 함수로 인해 1초 뒤에 실행되도록 되어있다. 여기서 <code>done()</code>을 호출을 하였기에 테스트가 종료되었다는 것을 알 수 있다. 만약 <code>done()</code> 호출이 없다면 오류를 발생하게 되어있다. 또한 기본 <code>timeout</code>인 <code>2000ms</code>가 지나가도 실패하게 되어있다.</p><p><img src="/2017/06/16/Mocha-step-04/result_thumbnail_02.png" alt="result02"></p><h2 id="Hooks에서의-비동기-처리"><a href="#Hooks에서의-비동기-처리" class="headerlink" title="Hooks에서의 비동기 처리"></a>Hooks에서의 비동기 처리</h2><p>우리는 이전 Tutorial인 <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-03/">Step 03: Hooks</a>에서 전&#x2F;후 처리에 대한 <code>Hooks</code>를 알아보았다. 이 <code>Hooks</code>에도 동일하게 <code>done()</code>을 콜백하여 <code>비동기 처리</code>를 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>),<br>    expect = chai.<span class="hljs-property">expect</span>;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#indexOf()&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> arr = [];<br><br>    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">done</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>            <span class="hljs-title function_">done</span>();<br>        &#125;, <span class="hljs-number">1500</span>)<br>    &#125;);<br><br>    <span class="hljs-title function_">afterEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        arr = [];<br>    &#125;);<br><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;Asynchronous Hooks&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">expect</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">5</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-title function_">expect</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-title function_">expect</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">0</span>)).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(-<span class="hljs-number">1</span>);<br>    &#125;);<br><br>&#125;);<br></code></pre></td></tr></table></figure><p>위 코드를 보면 <code>beforeEach()</code>에서 1500ms 이후에 <code>arr</code>를 초기화하는 것을 볼 수 있다. 이처럼 <code>비동기 처리</code>는 테스트와 Hooks에 적용이 가능하며, 사용법 마저 매우 쉽다.</p><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step04-Asynchronous">예제 코드</a></p><hr><p><code>비동기 처리</code>는 반드시 써야 할 경우가 온다. 이와 관련된 내용이 많지는 않지만 프로젝트 상황에 따른 많은 연습이 필요하다고 생각된다.<br>다음 Tutorial에는 외부 모듈을 불러와 사용하는 방법을 배워보도록 하겠다. 어느 개발자든 어느 프로젝트이든 하나의 <code>.js</code>에 모든 코드를 적진 않는다. 그만큼 중요한 내용은 아니지만, 혹시 모를 개발자를 위해~ </p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-05/">Step 05: 외부 모듈 테스트</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> 동기 </tag>
            
            <tag> 비동기 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 03. Hooks</title>
      <link href="/2017/06/16/Mocha-step-03/"/>
      <url>/2017/06/16/Mocha-step-03/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/16/Mocha-step-03/cover.png" alt="cover"></p><p>이번 Tutorial에서는 Mocha의 <code>Hooks</code>를 알아보겠다. <strong>Mocha에서는 테스트들의 전제 조건과 후 조건을 미리 설정할 수 있는 <code>Hooks</code>를 지원</strong>한다. Mocha에서는 기본적으로 <code>BDD</code> 스타일을 지원하지만 <code>TDD</code> 스타일도 역시 지원하기 때문에 이 두 스타일에 대한 <code>Hooks</code>도 정의할 수 있다.</p><hr><p>먼저 <code>Hooks</code>를 살펴보겠다.</p><h2 id="기본-Hooks"><a href="#기본-Hooks" class="headerlink" title="기본 Hooks"></a>기본 Hooks</h2><p>Mocha의 기본 <code>BDD</code> 스타일의 <code>Hooks</code>는 다음과 같이 정의할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Hooks&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-title function_">before</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// runs before all tests in this block            </span><br>   &#125;);<br>   <br>   <span class="hljs-title function_">after</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// runs after all tests in this block</span><br>   &#125;);<br>   <br>   <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// runs before each test in this block</span><br>   &#125;);<br>   <br>   <span class="hljs-title function_">afterEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// runs after each test in this block</span><br>   &#125;);<br>   <br>   <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// test case </span><br>   &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>간단하다!!.<br>주석을 보면 알겠지만 Mocha에서는 <code>before()</code>, <code>after()</code>, <code>beforeEach()</code>, <code>afterEach()</code> 4가지의 <code>Hooks</code>를 지원한다. 여기서 <code>before()</code>, <code>after()</code>는 테스트 스위트 단위(<code>describe</code>)로 실행된다. <code>before()</code>는 각 테스트 스위트가 실행되기 전에 실행하고 <code>after()</code>는 각 테스트 스위트가 종료되고 실행된다.<br><code>beforeEach()</code>, <code>afterEach()</code>는 어떨까? 이 두개의 <code>Hooks</code>는 테스트 스위트가 아닌 테스트 케이스 단위(<code>it</code>)로 실행된다. <code>beforeEach()</code>는 각 테스트 케이스가 실행하기 전에 실행되고  <code>afterEach()</code> 반대로 테스트 케이스가 종료 후에 실행된다.</p><h2 id="Hooks-실행-순서"><a href="#Hooks-실행-순서" class="headerlink" title="Hooks 실행 순서"></a>Hooks 실행 순서</h2><p>이 <code>Hooks</code>들은 적절하게 정의 된 순서대로 실행된다.<br>모든 <code>before()</code> Hooks가 한 번 실행한 후 모든 <code>beforeEach()</code> Hooks와 테스트 케이스(<code>it</code>)가 실행된다. 이후 모든 <code>afterEach()</code> Hooks를 실행하고 마지막으로 <code>after()</code> Hooks를 한 번 실행하게 된다.</p><p>아래 코드를 보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Hooks&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">before</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;before&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">after</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;after&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeEach&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">afterEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;afterEach&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;test case #1&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test case #1&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;test case #2&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test case #2&#x27;</span>);<br>    &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p>해당 코드를 실행하게 되면 초기에 <code>before()</code>이 실행이 되고 이후 <code>beforeEach()</code> 그리고 테스트 케이스(<code>it</code>)이 실행된다. 그리고 테스트 케이스(<code>it</code>)이 종료되면 <code>afterEach()</code>가 실행되고 또 다시 테스트 케이스(<code>it</code>)을 위해 반복적으로 <code>beforeEach()</code>와 <code>afterEach()</code>가 실행되며, 마지막으로 <code>after()</code>가 실행되는 것을 볼 수 있다.</p><p><img src="/2017/06/16/Mocha-step-03/result_thumbnail_01.png" alt="result01"></p><h2 id="Hooks-설명"><a href="#Hooks-설명" class="headerlink" title="Hooks 설명"></a>Hooks 설명</h2><p>어떤 <code>Hooks</code>는 특정 설명과 함께 호출 할 수 있으므로 테스트에서 오류를 쉽게 찾아 낼 수 있다. 또한 <code>Hooks</code>에 특정 명칭을 가진 함수가 주어지면 그 명칭을 사용하게 된다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Describing Hooks&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// beforeEach hook</span><br>    &#125;);<br><br>    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">namedFun</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// beforeEach:namedFun</span><br>    &#125;);<br><br>    <span class="hljs-title function_">beforeEach</span>(<span class="hljs-string">&#x27;some description&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// beforeEach:some description</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Hooks로-보는-BDD와-TDD"><a href="#Hooks로-보는-BDD와-TDD" class="headerlink" title="Hooks로 보는 BDD와 TDD"></a>Hooks로 보는 BDD와 TDD</h2><p><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>부터 강조했던 점은 Mocha는 <code>TDD</code>와 <code>BDD</code> 스타일을 각각 지원한다고 하였다. 그 차이가 무엇인지 <code>Hooks</code>를 통해 알아보겠다.</p><p>단순히 <code>TDD</code>와 <code>BDD</code>는 코딩의 스타일이 아닌 하나의 애자일 소프트웨어 개발 방법론에서 가장 널리 쓰이는 테스트 방법론이다. <code>TDD</code>는 테스트 주도 개발(<code>Test-Driven-Devenlopment</code>)이며, <code>BDD</code>는 <code>TDD</code>를 근간으로 파생된 행위 주도 개발(<code>Befavior-Driven-Development</code>)이다. 이런 복잡하고 학습 곡선이 긴 내용은 이 Tutorial에서는 넘어가도록 하겠다.</p><div class="alert warning no-icon"><p>오직 이 Tutorial에서는 다루는 내용은 Mocha에서의 TDD와 BDD스타일 입니다.</p></div><p>우리가 이 Tutorial에서 배운 것은 Mocha는 기본적으로 <code>BDD</code> 스타일을 우선순위로 지원한다고 하였다. 그리고 4가지의 <code>Hooks</code>인 <code>before()</code>, <code>after()</code>, <code>beforeEach()</code>, <code>afterEach()</code> 이다. <code>TDD</code>는 4가지의 <code>Hooks</code>의 명칭이 다릅니다. <code>suiteSetup()</code>, <code>suiteTeardown()</code>, <code>setup()</code>, <code>teardown()</code> 이렇게 된다. 또한 <code>BDD</code>에서의 <code>describe()</code>는 <code>suite()</code>로, <code>it()</code>은 <code>test()</code>로 표현한다.</p><p><code>TDD</code> 스타일을 직접 코드로 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">suite</span>(<span class="hljs-string">&#x27;#Hooks&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-title function_">suiteSetup</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// runs before all tests in this block            </span><br>   &#125;);<br>   <br>   <span class="hljs-title function_">suiteTeardown</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// runs after all tests in this block</span><br>   &#125;);<br>   <br>   <span class="hljs-title function_">setup</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// runs before each test in this block</span><br>   &#125;);<br>   <br>   <span class="hljs-title function_">teardown</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// runs after each test in this block</span><br>   &#125;);<br>   <br>   <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// test case </span><br>   &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>우리가 처음 <code>Hooks</code>를 시작할 때 작성했던 코드와 비교하면 어떤 부분이 다른지 알 수 있다. 그저 관점의 차이라고 볼 수 있겠다. 여기서 중요한 건 코딩의 스타일도 있겠지만 <code>TDD</code> 스타일을 사용하기 위해서는 Mocha의 옵션을 지정을 해줘야 한다.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">mocha <span class="hljs-built_in">test</span> --ui tdd 또는 -u tdd<br></code></pre></td></tr></table></figure><p><code>--ui</code> 또는 <code>-u</code>의 옵션을 통해 우리가 Mocha의 어떤 스타일을 사용할 것인지 명시를 해줘야 한다.</p><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step03-Hooks">예제 코드</a></p><hr><p><code>Hooks</code>는 용이하게 사용할 수 있다. 예를 들어 테스트 케이스 필요한 <code>Book</code>이라는 객체를 생성한다고 하였을 때 우리는 <code>var book = new Book()</code>을 테스트 케이스마다 만들 것이다. 하지만 우리는 지금까지 배운 <code>Hooks</code>를 통해 한 번에 객체를 만들고 <code>destroy</code>까지 완벽하게 끝낼 수 있다.<br>이제 <code>Hooks</code>를 배웠으니 다음 Tutorial에서는 <code>비동기 처리</code>에 대한 방법을 배워보고 <code>Hooks</code>에도 <code>비동기 처리</code>를 적용하는 방법을 배워보겠다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-04/">Step 04: 비동기 처리</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> hooks </tag>
            
            <tag> BDD </tag>
            
            <tag> TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 02. Chai</title>
      <link href="/2017/06/15/Mocha-step-02/"/>
      <url>/2017/06/15/Mocha-step-02/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/15/Mocha-step-02/cover.png" alt="cover"></p><p><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>에서는 기본적인 Mocha 사용법에 대해 알아보았다.<br>이번 Step 02에서는 <a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>에서 언급한 <code>Assertion</code> library에 대해 어떻게 사용하는지와 어떤 것인지를 알아보도록 하자.</p><hr><h2 id="Chai"><a href="#Chai" class="headerlink" title="Chai"></a>Chai</h2><p><img src="/2017/06/15/Mocha-step-02/chai_logo.png" alt="cover"></p><p><a href="https://mochajs.org/">mochjs.org</a>에서 리스팅 된 <code>Assertion</code>에는 <code>Should.js</code>, <code>expect.js</code>, Chai, <code>better-assert</code>, <code>unexpected</code> 가 있다. 이 중 어떤 <code>Assertion</code>를 사용하는지는 사용자의 판단에 있다. 궁극적으로는 같은 목적을 가지기 때문에 어떤 스타일을 선호하냐는 것에 따라 나뉠 수 있다.<br>대게 Mocha는 Chai와 같이 사용되며, <a href="https://npmcompare.com/compare/chai,expect,should">NPM COMAPRE</a>를 참고로 보았을 때도 Chai가 다른 <code>Assertion</code> 보다 선호하는 것을 볼 수 있다.</p><p>먼저 Chai는 Node.js 기반의 <code>Assertion</code> library로 <code>BDD</code>와 <code>TDD</code> 스타일을 지원하고 있으며, 지원하는 아래와 같은 인터페이스를 지원한다.</p><div class="alert info no-icon"><p><strong>Should</strong><br><strong>Expect</strong><br><strong>Assert</strong></p></div><h2 id="Chai-설치하기"><a href="#Chai-설치하기" class="headerlink" title="Chai 설치하기"></a>Chai 설치하기</h2><p>먼저 <code>npm</code>을 통해 Chai를 설치해보자.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm i chai --save-dev<br></code></pre></td></tr></table></figure><p>매우 쉽다. :)<br>너무 간단해서 <code>Chai 설치하기.</code> 란 부제를 지워버리고 싶을 정도지만 그래도 Tutorial이니 삭제하지는 않겠다.</p><h2 id="Chai-사용하기"><a href="#Chai-사용하기" class="headerlink" title="Chai 사용하기."></a>Chai 사용하기.</h2><p>우리는 이제 Chai까지 설치를 하였다. 이렇게 설치한 Chai를 불러와서 사용하기만 하면 된다. <a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>에서 이미 <code>test.js</code>파일을 생성했으니 새롭게 <code>test-chai.js</code>라는 파일을 생성해보자. 아니면 그대로 사용해도 된다. 그리고 아래처럼 코드를 입력해보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>);<br><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><span class="hljs-keyword">var</span> assert = chai.<span class="hljs-property">assert</span>;<br><span class="hljs-keyword">var</span> should = chai.<span class="hljs-title function_">should</span>();<br></code></pre></td></tr></table></figure><p><code>require</code>를 통해 Chai 모듈을 사용하기로 한다. 그런데 그 아래를 보니 <code>expect</code>, <code>assert</code>, <code>should</code>가 체이닝을 통해 불러왔다. 위에서 먼저 설명을 했지만 Chai는 이 스타일들을 지원하기 때문에 사용할 수가 있는 것이다. 굳이 저 3개를 모두 사용할 필요는 없다. 어떤 것을 사용해야 하는지 모르겠다면 각각의 API를 보고 마음에 드는 것을 사용하기로 하자. 왜냐하면 <code>Assertion</code>이기 때문이다. (내 생각..)<br>이제 테스트 스위트를 작성해보자.</p><h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>);<br><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><span class="hljs-keyword">var</span> assert = chai.<span class="hljs-property">assert</span>;<br><span class="hljs-keyword">var</span> should = chai.<span class="hljs-title function_">should</span>();<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Expect Test&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;expect - Array&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>        <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">5</span>);                        <span class="hljs-comment">//array length</span><br>        <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-property">not</span>.<span class="hljs-property">empty</span>;                            <span class="hljs-comment">//empty</span><br>        <span class="hljs-title function_">expect</span>(arr).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-property">ordered</span>.<span class="hljs-title function_">members</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);   <span class="hljs-comment">//arr === members</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>간단하다. 바로 실행해 보자.</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">mocha test-chai.js<br></code></pre></td></tr></table></figure><p><img src="/2017/06/15/Mocha-step-02/result_thumbnail_01.png" alt="result01"></p><p>정상적으로 출력이 되는 것을 확인할 수 있다.</p><p>위 예제는 <code>expect</code>를 사용한 코드이다. <code>expect</code>는 <code>BDD Style</code>의 인터페이스이며, 자연어에 가까운 <code>Assertion</code>이다. 아직 감이 오지 않을 수도 있다. 다른 코드를 보고 감을 잡아보자.<br>위 코드에 이어서 코딩하면 된다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;expect - String&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Awesome!!&#x27;</span>;<br>    <br>    <span class="hljs-title function_">expect</span>(str).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">a</span>(<span class="hljs-string">&#x27;String&#x27;</span>);                  <span class="hljs-comment">//str type</span><br>    <span class="hljs-title function_">expect</span>(str).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-string">&#x27;Awesome!!&#x27;</span>);              <span class="hljs-comment">//str === &#x27;Awesome!!&#x27;</span><br>    <span class="hljs-title function_">expect</span>(str).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Why fail?&#x27;</span>);   <span class="hljs-comment">//Error</span><br>&#125;);<br><br><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;expect - Object&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> obj = &#123;<br>        <span class="hljs-attr">assertion</span>: [<span class="hljs-string">&#x27;assert&#x27;</span>, <span class="hljs-string">&#x27;expect&#x27;</span>, <span class="hljs-string">&#x27;should&#x27;</span>],<br>        <span class="hljs-attr">framework</span>: <span class="hljs-string">&#x27;mocha&#x27;</span><br>    &#125;;<br><br>    <span class="hljs-title function_">expect</span>(obj).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">property</span>(<span class="hljs-string">&#x27;assertion&#x27;</span>).<span class="hljs-property">with</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">3</span>);     <span class="hljs-comment">//assertion value length</span><br>    <span class="hljs-title function_">expect</span>(obj).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-property">all</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-string">&#x27;framework&#x27;</span>, <span class="hljs-string">&#x27;assertion&#x27;</span>);         <span class="hljs-comment">//obj key === keys</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>위 예제에서 주목할 만한 곳은 아래 코드이다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javaScript"><span class="hljs-title function_">expect</span>(str).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Why fail?&#x27;</span>);<br></code></pre></td></tr></table></figure><p><code>expect</code>는 임의의 실패한 <code>assertion</code> 앞에 메시지를 포함할 수 있다. 예제를 실행해 보면 아래와 같이 실패한 결과에 메시지가 출력되는 것을 볼 수 있다.</p><p><img src="/2017/06/15/Mocha-step-02/result_thumbnail_02.png" alt="result02"></p><p>처음 접할 때는 다소 생소할 수 있다. 하지만 걱정하지 않아도 된다. 잘 정리된 <a href="http://chaijs.com/api/bdd/">expect API</a>가 있으니까 말이다.<br><code>expect api</code>에 리스팅 되어 있는 체이닝이다. 이 체이닝은 뒤에 있을 <code>should</code>에서도 같은 방식을 사용하고 있다.</p><blockquote><ul><li>to</li><li>be</li><li>been</li><li>that</li><li>which</li><li>and</li><li>has</li><li>have</li><li>with</li><li>at</li><li>of</li><li>same</li><li>but</li><li>does</li></ul></blockquote><p>코드에 대한 설명은 주석을 참고하자!.</p><h3 id="should"><a href="#should" class="headerlink" title="should"></a>should</h3><p>위에서 언급했지만 <code>should</code>는 <code>expect</code>와 같은 체이닝 방식을 사용한다. <code>should</code>는 <code>IE</code>와 사용할 때 몇 가지의 문제가 있으므로 브라우저 호환성을 알고 있어야 한다.<br>자, 그럼 이제 예제를 통해 <code>should</code>와 <code>expect</code>가 어떻게 같은 체이닝 방식을 사용하는지 확인해 보겠다. 새로운 테스트 스위트 <code>#Should Test</code>를 추가하겠다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Should Test&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;should - Array&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>        arr.<span class="hljs-property">should</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">5</span>);                        <span class="hljs-comment">//array length</span><br>        arr.<span class="hljs-property">should</span>.<span class="hljs-property">be</span>.<span class="hljs-property">not</span>.<span class="hljs-property">empty</span>;                            <span class="hljs-comment">//empty</span><br>        arr.<span class="hljs-property">should</span>.<span class="hljs-property">have</span>.<span class="hljs-property">ordered</span>.<span class="hljs-title function_">members</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);   <span class="hljs-comment">//arr === members</span><br>    &#125;);<br><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;should - String&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Awesome!!&#x27;</span>;<br><br>        str.<span class="hljs-property">should</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">a</span>(<span class="hljs-string">&#x27;String&#x27;</span>);                  <span class="hljs-comment">//str type</span><br>        str.<span class="hljs-property">should</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-string">&#x27;Awesome!!&#x27;</span>);              <span class="hljs-comment">//str === &#x27;Awesome!!&#x27;</span><br>        str.<span class="hljs-property">should</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Why fail?&#x27;</span>);   <span class="hljs-comment">//Error</span><br>    &#125;);<br><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;should - Object&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> obj = &#123;<br>            <span class="hljs-attr">assertion</span>: [<span class="hljs-string">&#x27;assert&#x27;</span>, <span class="hljs-string">&#x27;expect&#x27;</span>, <span class="hljs-string">&#x27;should&#x27;</span>],<br>            <span class="hljs-attr">framework</span>: <span class="hljs-string">&#x27;mocha&#x27;</span><br>        &#125;;<br><br>        obj.<span class="hljs-property">should</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">property</span>(<span class="hljs-string">&#x27;assertion&#x27;</span>).<span class="hljs-property">with</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">3</span>);     <span class="hljs-comment">//assertion value length</span><br>        obj.<span class="hljs-property">should</span>.<span class="hljs-property">have</span>.<span class="hljs-property">all</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-string">&#x27;framework&#x27;</span>, <span class="hljs-string">&#x27;assertion&#x27;</span>);         <span class="hljs-comment">//obj key === keys</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>결과는 <code>expect</code>와 같음을 알 수 있다. 두 코드를 비교해 보면 어느 부분이 다른지 명확하게 보인다. 거의 다른 부분이 없다. 그럼 <code>expect</code>와 <code>should</code>가 다른 점이 무엇일까?</p><h4 id="expect와-should의-차이"><a href="#expect와-should의-차이" class="headerlink" title="expect와 should의 차이"></a>expect와 should의 차이</h4><p>우리가 처음 Chai를 설치하고 <code>test-chai.js</code>만들고 이렇게 코딩하였다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chai = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chai&#x27;</span>);<br><span class="hljs-keyword">var</span> expect = chai.<span class="hljs-property">expect</span>;<br><span class="hljs-keyword">var</span> assert = chai.<span class="hljs-property">assert</span>;<br><span class="hljs-keyword">var</span> should = chai.<span class="hljs-title function_">should</span>();<br></code></pre></td></tr></table></figure><p><code>()</code>가 있고 없고의 차이이다… 굳이 풀이하자면 이렇다.</p><div class="alert info no-icon"><p><em><strong>expect</strong>는 함수에 대한 참조일 뿐이고 <strong>should</strong>는 함수가 실행되고 있음</em></p></div><h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p><code>assert</code>는 <code>Node.js</code>에서 제공하는 <code>assert</code>의 표기법을 제공한다. 하지만 이 Chai의 <code>assert</code>가 좀 더 풍부한 표현을 제공하고 있다.<br><code>assert</code>는 간단한 예제만으로 넘어가도록 하겠다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Assert Test&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;assert - Array&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Awesome!!&#x27;</span>;<br>        <span class="hljs-keyword">var</span> obj = &#123;<br>            <span class="hljs-attr">assertion</span>: [<span class="hljs-string">&#x27;assert&#x27;</span>, <span class="hljs-string">&#x27;expect&#x27;</span>, <span class="hljs-string">&#x27;should&#x27;</span>],<br>            <span class="hljs-attr">framework</span>: <span class="hljs-string">&#x27;mocha&#x27;</span><br>        &#125;;<br><br>        assert.<span class="hljs-title function_">equal</span>(str, <span class="hljs-string">&#x27;Awesome!!&#x27;</span>);         <span class="hljs-comment">//str === &#x27;Awesome!!&#x27;</span><br>        assert.<span class="hljs-title function_">typeOf</span>(str, <span class="hljs-string">&#x27;String&#x27;</span>);           <span class="hljs-comment">//str type</span><br>        assert.<span class="hljs-title function_">lengthOf</span>(obj.<span class="hljs-property">assertion</span>, <span class="hljs-number">3</span>);      <span class="hljs-comment">//assertion value length</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step02-chai">예제 코드</a></p><hr><p>Mocha를 사용하다 보면 처음에 이 <code>Assertion</code>에 대해 다소 낯선 기분이 들 수도 있다. 하지만 걱정 할 필요가 없다. <a href="http://chaijs.com/api/bdd/">API</a>에서 모든 것을 확인하고 테스트해 볼 수 있기 때문이다.<br>이제 Chai 사용법에 대해 알아 보았다. 기본적인 Mocha를 모두 터득한 것이다. 지금까지 배운 것만으로도 쉽지는 않겠지만 그럴싸한 단위 테스트를 진행할 수 있다.<br>다음 Tutorial에서는 <code>Hooks</code>와 Mocha에서 <code>BDD</code>, <code>TDD</code>의 다른점을 알아보겠다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-03/">Step 03: Hooks</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> Assertion </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> chai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 01. Hello World!</title>
      <link href="/2017/06/15/Mocha-step-01/"/>
      <url>/2017/06/15/Mocha-step-01/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/15/Mocha-step-01/cover.png" alt="cover"></p><p>새로운 기술. 프로그램 언어를 입력할 때에는 항상 나타나는 <em>Hello World</em>. Mocha의 가장 기초 코드와는 거리가 멀지만 그래도 <em>Hello World</em>를 고집해 보겠다. <a href="https://kdydesign.github.io/2017/06/08/Mocha.html">JavaScript 단위 테스트 프레임워크 - Mocha</a>에서 Mocha를 설치하였다.</p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>이제 프로젝트에 필요한 기본 폴더를 구성하자. 먼저 <code>Mocha_test</code>라는 폴더를 만들자.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C:\Mocha_test<br></code></pre></td></tr></table></figure><p>해당 폴더에 <code>test.js</code>를 생성하여 아래와 같이 작성하자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Hello World!&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;입력 값은 Hello World!&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> input = <span class="hljs-string">&#x27;Hello World!&#x27;</span>; <span class="hljs-comment">// 입력 값이라고 가정</span><br><br>        assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>, input);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>위 코드는 Mocha의 가장 기본 코드이다. Mocha는 <code>describe()</code>와 <code>it()</code>으로 테스트 스위트와 유닛 테스트를 정의하고 실행한다. Mocha는 <code>BDD</code> 스타일을 기본으로 하고 있지만 <code>TDD</code> 스타일도 지원하고 있다. 해당 강좌에서는 위와 같이 <code>BDD</code> 스타일로 작성하도록 하겠다.</p><h2 id="Assertion"><a href="#Assertion" class="headerlink" title="Assertion"></a>Assertion</h2><p>위 코드에서는 Node.js에 내장된 <code>Assetion</code> library를 사용하였지만 Mocha의 장점 중인 하나가 <code>Assertion</code> library와 독립적으로 사용할 수 있다는 것이다. 즉, <strong>mocha는 외부 Assertion library와 같이 사용</strong>할 수 있다. 아래에는 <a href="https://mochajs.org/">mochajs.org</a>에 리스팅 되어 있는 <code>Assertion</code> library이다.</p><div class="alert info no-icon"><p><strong>should.js</strong> - BDD 스타일의 Assertions<br><strong>expect.js</strong> - expect() 스타일의 Assertions<br><strong>chai</strong> - expect(), assert(), should-style의 Assertions<br><strong>better-assert</strong> - C-style 자체 문서화 된 assert()<br><strong>unexpected</strong> - 확장 가능한 BDD Assertion Toolkit</p></div><p>이제 위에서 생성한 <code>test.js</code>를 실행해 보도록 하겠다. 해당 경로에서 Mocha를 실행한다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mocha<br></code></pre></td></tr></table></figure><p>기본적으로 Mocha 실행 시 <code>test.js</code> 파일을 실행한다. 하지만 특정 파일도 실행할 수 있다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mocha test.js<br></code></pre></td></tr></table></figure><p><code>1 passing</code>으로 통과되었다는 뜻이다.</p><p><img src="/2017/06/15/Mocha-step-01/step01_result_thumbnail_01.png" alt="result01"></p><h2 id="describe"><a href="#describe" class="headerlink" title="describe()"></a>describe()</h2><p>하나의 <code>describe()</code> 안에는 여러 개의 <code>describe()</code>를 가질 수가 있고, <code>it()</code> 역시 여러 개를 가질 수도 있다.<br>예제를 보자.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#Hello World!&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;입력 값은 Hello World!&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> input = <span class="hljs-string">&#x27;Hello World!&#x27;</span>; <span class="hljs-comment">// 입력 값이라고 가정</span><br><br>        assert.<span class="hljs-title function_">equal</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>, input);<br>    &#125;);<br>    <br>    <span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;#String Test&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;Hello의 문자 개수는 5&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>           <br>           <span class="hljs-keyword">if</span> (str.<span class="hljs-property">length</span> == <span class="hljs-number">5</span>) &#123;<br>               assert.<span class="hljs-title function_">ok</span>(<span class="hljs-literal">true</span>);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               assert.<span class="hljs-title function_">ok</span>(<span class="hljs-literal">false</span>);<br>           &#125;<br>        &#125;);<br>        <br>        <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;World는 W 대문자&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;World&#x27;</span>;<br>           <br>           <span class="hljs-keyword">if</span> (str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;w&#x27;</span>) &gt; -<span class="hljs-number">1</span>) &#123;     <span class="hljs-comment">//오류 발생</span><br>               assert.<span class="hljs-title function_">ok</span>(<span class="hljs-literal">true</span>);<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               assert.<span class="hljs-title function_">ok</span>(<span class="hljs-literal">false</span>);<br>           &#125;<br>        &#125;);<br>    &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>#Hello World!</code>의 테스트 스위트는 <code>#String Test</code>라는 테스트 스위트를 가지고 있다. 그리고 <code>#String Test</code>는 두 개의 <code>it()</code>을 가질 수 있는 것을 볼 수 있다.<br>위 예제에서는 오류가 발생하도록 되어있다. 결과를 보도록 하자.</p><p><img src="/2017/06/15/Mocha-step-01/step01_result_thumbnail_02.png" alt="result02"></p><p><code>2 passing</code>에 <code>1 failing</code></p><h2 id="NPM으로-실행하기"><a href="#NPM으로-실행하기" class="headerlink" title="NPM으로 실행하기."></a>NPM으로 실행하기.</h2><p>지금까지 우리는 <code>test.js</code>를 <code>mocha test.js</code> 또는 <code>mocha</code>를 통해 실행했다. 하지만 Mocha 역시 <code>Node.js</code>의 하나의 모듈이기 때문에 <code>npm</code>으로 실행을 할 수 있다.</p><p>처음 <a href="https://kdydesign.github.io/2017/06/08/Mocha.html">JavaScript 단위 테스트 프레임워크 - Mocha</a>에서 우리는 Mocha를 설치하기 전에 <code>npm init</code>을 통해 <code>package.json</code>을 생성하였다. 생성된 <code>package.json</code> 파일을 보면 <code>scripts</code>라는 항목이 있는데 우리는 이것을 npm으로 실행하면 끝!.</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha test&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <br>  <span class="hljs-comment">//...</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>결과는 같으며 실행 방식의 차이이다.</p><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step01-Hello%20World!">예제 코드</a></p><hr><p>이것으로 가장 간단한 Mocha의 사용법을 익혔다. 이제 Mocha를 사용하면서 필요한 <code>Assertion</code> library를 사용해 볼 차례이다.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-02/">Step 02: Assertion-chai</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> Assertion </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> assert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 단위 테스트 프레임워크 - Mocha</title>
      <link href="/2017/06/08/Mocha/"/>
      <url>/2017/06/08/Mocha/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="/2017/06/08/Mocha/cover.png" alt="cover"></p><p>기술이 나날히 발전함에 따라 Web Front-End에도 테스트 방법론들을 적용하여 보다 효율적이고 효과적으로 프로젝트를 진행할 수 있다. JavaScript기반의 테스트 프레임워크는 무수히 많다. 그 중 대표적으로 <code>Mocha</code>와 <code>jasmine</code>을 말 할수 있다. 이 두 프레임워크 중 어떤 프레임워크가 더욱 뛰어난지 비교할 수 없다. 그저 어떤 프레임워크를 사용하느냐는 진행하고자하는 프로젝트와 주변 환경의 요소에 따라 다르다. 이번 포스팅에서는 <code>Mocha</code>를 먼저 말하고 싶다.</p><hr><h2 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h2><p><code>Mocha</code>는 Node.js 기반의 Javascript 테스트 프레임워크이다. <code>Mocha</code> 공식 페이지에서는 <code>Mocha</code>를 세 단어로 설명하도 있다.</p><blockquote><p><em><strong>Simple(간단하고), Flexible(유연하며), Fun(재미있는)</strong></em></p></blockquote><p>정말 그런지 확인해보자.</p><h2 id="Mocha-설치하기"><a href="#Mocha-설치하기" class="headerlink" title="Mocha 설치하기"></a>Mocha 설치하기</h2><p><strong>Mocha</strong>를 설치하기 위해서는 먼저 Node.js와 npm이 설치되어 있어야 한다. Node.js와 npm 설치 방법과 개념은 npm과 node.js에 대해서는 <a href="https://kdydesign.github.io/posts/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a>포스트를 참고하자.<br>Node.js와 npm을 설치하였다면 적당한 프로젝트 폴더를 생성한다. 여기서는 <code>Mocha_test</code>라고 하겠다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ C:\Mocha_test<br></code></pre></td></tr></table></figure><p>생성된 경로에 npm 명령어를 통해 <code>package.json</code>을 생성한다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ npm init<br></code></pre></td></tr></table></figure><p>이제 <code>package.json</code>이 생성되었으니 본격적으로 <code>mocha</code>를 설치해 보자. <code>mocha</code>를 설치 할 때에는 <code>-g</code> 옵션을 붙혀서 global하게 설치해도 무방하다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ npm install mocha --save-dev 또는 npm i -g mocha<br></code></pre></td></tr></table></figure><p><code>--save-dev</code> 옵션을 주었기에 <code>package.json</code>에 <code>devDependencies</code>에서 <code>mocha</code>가 추가된 것을 볼 수 있다.<br><code>mocha</code>가 정상적으로 설치가 되어 있는지 확인하기 위해 다음과 같이 실행해 보자.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$ mocha --version 또는 mocha -V<br></code></pre></td></tr></table></figure><p><code>mocha</code>와 관련된 옵션은 <code>mocha -h</code>를 통해 확인 할 수 있다. 이제 <code>mocha</code> 설치까지 끝났으니 본격적으로 <code>mocha</code>를 사용할 때이다. 비교적 Learning Curve가 적어 Tutorial이 적지만 단계별로 진행해 보자.</p><hr><div class="alert more no-icon"><p><strong>더 알아보기</strong><br><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
