<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Electron 완전정복!! - 개념부터 데스트탑 앱 만들기</title>
      <link href="/2019/04/15/electron-tutorial/"/>
      <url>/2019/04/15/electron-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>처음 Electron을 알게 된 경로는 웹 신기술 관련하여 검색하다가 우연히 알게 되었다. 그때는 그저 글로만 보고 <code>뭐? JavaScript로 데스크 탑 앱을 만든다고? 가능한가 이게?</code> 라는 생각만 하고 좀 찾아보았고 <code>오오~</code> 하다가 말았던 기억이 있다. 그로부터 꽤 시간이 지났고 불과 몇 년 전에 Front-End 컨퍼런스에 참여하였고 Electron 섹션을 듣고 나서 꼭 한번 해보고 싶다고 생각했다. 그걸 인제야 포스팅하고 있다.</p><h1 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h1><p>Electron은 <strong> <a href="https://ko.wikipedia.org/wiki/%ED%81%AC%EB%A1%9C%EB%AF%B8%EC%97%84_(%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80" target="_blank" rel="noopener">Chromium</a>과 Node.js를 사용하여 JavaScript, HTML, CSS를 이용하여 윈도우 또는 Mac, 리눅스에서 직접 설치하여 사용할 수 있는 애플리케이션을 개발 </strong>할 수 있다. 크로스 플랫폼 지원으로 이 세 개의 운영체제에서 빌드되고 동작한다. 웹 개발자라면 습득한 기술 그대로 Electron만 익혀서 어느 운영체제에서든 동작하는 설치형 애플리케이션을 프로그래밍할 수 있다는 소리이다.</p><p><a href="https://electronjs.org/" target="_blank" rel="noopener">Electron 공식 사이트</a>에 가보면 이런 문구가 있다.</p><blockquote><p><strong> It’s easier than you think </strong> - <strong> Electron은 여러분이 생각한 것보다 쉽습니다 </strong></p></blockquote><p>Electron을 직접 해보면 알겠지만, 문구 그대로인 듯하다. 처음에 생각만 해본다면 웹 기술을 이용하여 데스크 탑 애플리케이션을 만든다고 하면 이것저것 설치하고 설정하고 무지막지하게 복잡할 것 같다. 하지만 그런 복잡한 작업은 Electron이 처리해 준다. 그저 웹 개발자는 그냥 웹으로 생각하고 코딩만 하면 된다. 물론 Electron에 대해서 배워야 하지만 말이다.</p><p>사실 처음 Electron으로 해보면서 너무 신기하였지만 다른 한편으로는 Electron을 이해하는데 힘들었다. 웹 개발자로서 항상 브라우저의 리소스만 사용하다가 웹 기술을 통해서 시스템 지원을 막 가져다 쓴다… 너무 신기했지만, 웹에 항상 국한돼서 개발한 나에게 이 신기한 기술이 내가 기존에 가지고 있던 웹 개념들을 마구 흔들어 놓았다.</p><h1 id="Electron의-추이"><a href="#Electron의-추이" class="headerlink" title="Electron의 추이"></a>Electron의 추이</h1><p>현재 Electron의 버전은 4.x이다. 처음 1.x를 출시한 게 2016년도이고 최초로 0.x를 출시한 것은 2013년도 있다. <a href="https://electronjs.org/releases/stable?" target="_blank" rel="noopener">Electron Version</a>에서 모든 버전을 볼 수 있다.<br>0.x 버전을 제외하고 1.x부터 본다면 출시한 지 약 3년이 되었다. 그동안 Electron이 얼마나 인지도가 높아졌는지 확인해 보자.</p><p><br></p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1754_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"electron js","geo":"","time":"2013-01-01 2019-04-10"}],"category":0,"property":""}, {"exploreQuery":"date=2013-01-01%202019-04-10&q=electron%20js","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script> <p><br></p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1754_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("GEO_MAP", {"comparisonItem":[{"keyword":"electron js","geo":"","time":"2013-01-01 2019-04-10"}],"category":0,"property":""}, {"exploreQuery":"date=2013-01-01%202019-04-10&q=electron%20js","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script> <p>상승 중이기는 하나.. 급격한 변화는 없어 보인다.<br>서로 다른 프레임워크이지만 상승 추세를 보기 위해 <code>Vue.js와 비교</code>를 해보자.</p><p><br></p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1754_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"electron js","geo":"","time":"2013-01-01 2019-04-10"},{"keyword":"vue.js","geo":"","time":"2013-01-01 2019-04-10"}],"category":0,"property":""}, {"exploreQuery":"date=2013-01-01%202019-04-10&q=electron%20js,vue.js","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script> <p>이렇게 보니 확연히 차이 나 보이긴 한다. 그렇다고 Electron이 흐지부지 그저 그런 프레임워크는 아니다. 단순히 Google Trend로 확인해 보았을 경우이다.</p><p><a href="https://2018.stateofjs.com/mobile-and-desktop/overview/" target="_blank" rel="noopener">2018 The State of JavaScript - Mobile &amp; Desktop 부분</a>을 보자.</p><p><img src="overall-result.png" alt="cover"></p><p>Electron이 한자리한 것을 볼 수 있다. 배우고 싶은 개발자들의 퍼센테이지와 이미 프로젝트 반영한 개발자들도 상당수 있다. 중요한 건 배우고 싶은 개발자들의 비율이 꽤 있다는 것이다. 개발자들은 배우고 싶은 것은 배우고 프로젝트 도입하기 때문에… 뇌피셜이다.</p><h1 id="Electron의-사용성"><a href="#Electron의-사용성" class="headerlink" title="Electron의 사용성"></a>Electron의 사용성</h1><p>추이는 그저 Electron의 인지도를 감을 잡기 위해서 본 것이고 실제로 이 Electron을 가지고 프로젝트에 도입하고 실제로 서비스를 했다면 이야기는 달라진다. 이런 프로젝트가 무수히 많고 우리가 들으면 모두 알 법한 애플리케이션들이 많다.</p><p>먼저 <a href="https://electronjs.org/apps" target="_blank" rel="noopener">Electron 앱 Store</a>에 등록된 애플리케이션을 보자. 수 천은 아니라도 다양한 애플리케이션이 등록되어 있다. 우리가 애플리케이션을 만든다면 이곳에 등록을 할 수가 있다. 찾아보면 Mac에서도 많이 사용되는 <code>Simple-Note</code>도 Electron Application이 있는 것도 볼 수 있다. 이 외에도 <a href="https://github.com/sindresorhus/awesome-electron" target="_blank" rel="noopener">Awesome-Electeon</a>에 올라온 오픈 소스 애플리케이션이 많으니 참고하면 된다.</p><p>공식 페이지에 바로 나와 있지만, 우리가 많이 사용하고 유명한 애플리케이션들이 많다. vscode, Discord, Slack, Atom.. 훌륭하다!</p><p><img src="electron-app.png" alt="cover"></p><p>이렇게 본다면 현재 시점에서도 Electron을 도입해도 무방하다고 볼 수 있다.</p><h1 id="Electron과-Web-Application-Framework"><a href="#Electron과-Web-Application-Framework" class="headerlink" title="Electron과 Web Application Framework"></a>Electron과 Web Application Framework</h1><p>Electron은 웹 기반 기술을 사용하기 때문에 우리가 흔히 사용하고 Front-End Framework 3대장인 <strong> AngularJS, React.js, Vue.js Framework도 Electron과 같이 사용 </strong>할 수 있다. 물론 능력 있는 개발자들은 Electron에 직접 Web Framework를 얹어 사용할 수도 있지만 이미 능력자들이 만들어 놓은 <code>Boilerplate</code>와 <code>start Template</code>이 많이 있다.</p><p>이 Boilerplate와 Template 몇 가지를 살펴보자.</p><div class="alert danger no-icon"><ul><li>Vue.js - <a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a></li><li>React.js - <a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate" target="_blank" rel="noopener">electon-react-boilerplate</a></li><li>AngularJS - <a href="https://github.com/maximegris/angular-electron" target="_blank" rel="noopener">angular-electron</a></li></ul></div><p>위 템플릿 사용한다면 문제없이 훌륭한 Electron Application을 만들 수 있다.</p><h1 id="Electron-설치"><a href="#Electron-설치" class="headerlink" title="Electron 설치"></a>Electron 설치</h1><p>이제 Electron에 대해 어느 정도 파악이 되었을 것이다. 이제 실제로 Electron을 설치해서 실행 보자. Node.js가 설치되었다고 가정하고 진행한다. 만약 Node.js가 무엇인지 모른다면 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념 잡기</a> 포스트를 참고하자.</p><p>다행스럽게도 Electron 자체만으로도 빠르게 진행할 수 있는 <a href="https://github.com/electron/electron-quick-start" target="_blank" rel="noopener">electron-quick-start</a>를 제공하고 있다.</p><p>우리는 이 Template를 받아서 실행해 보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start </span><br><span class="line">$ <span class="built_in">cd</span> electron-quick-start</span><br><span class="line">$ npm i &amp;&amp; npm start</span><br></pre></td></tr></table></figure><p>지체 없이 node modules를 설치하고 실행하게 되면 <code>Hello World!</code>가 적힌 Electron Application이 실행된다. 해당 Application에서는 설치되어있는 Node.js, Chromium, Electron 버전이 출력되고 있다.</p><h1 id="Electron-Debug"><a href="#Electron-Debug" class="headerlink" title="Electron Debug"></a>Electron Debug</h1><p>실행까지는 매우 간단하게 진행되었다. 물론 Debugging 하는 것도 쉽다. 이미 Electron은 Chromium을 사용하였기 때문에 우리는 Chrome에서 개발 시 사용하던 <code>devTools</code>를 Electron에서도 사용할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Menu &gt; View &gt; Toggle Developer Tools</span><br><span class="line">또는 Ctrl + Shift + I</span><br></pre></td></tr></table></figure><p>흔히 보던 DevTools가 실행이 된다. 여기서 <code>Console 탭</code>으로 가자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; process</span><br></pre></td></tr></table></figure><p><img src="process.png" alt="cover"></p><p>간단하지만 현재의 시스템 정보 등 몇 가지 정보를 볼 수 있다.</p><h1 id="Electron-Build"><a href="#Electron-Build" class="headerlink" title="Electron Build"></a>Electron Build</h1><p>이제 이 아주 간단한 Application을 실제로 빌드를 하여 실행 파일로 생성해보자.</p><p>Application을 수동으로 빌드 시스템을 갖출 수도 있겠지만 역시나 <strong> Third-Party Package Tool </strong>이 존재한다.</p><blockquote><ul><li><a href="https://github.com/electron-userland/electron-forge" target="_blank" rel="noopener">electron-forge</a></li><li><a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a></li><li><a href="https://github.com/electron-userland/electron-packager" target="_blank" rel="noopener">electron-packager</a></li></ul></blockquote><p>무엇을 사용할 것인가는 본인들이 판단하기 바라며, 이 포스트에서는 <a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a>를 사용해 보기로 하자.</p><p>npm을 통해 설치를 진행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D electron-builder</span><br></pre></td></tr></table></figure><p>설치가 되었으면 패키지에 필요한 정보를 <code>package.json</code> 가장 하단에 명시하자. </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ..</span><br><span class="line">  "build": &#123;</span><br><span class="line">    "productName": "Electron-Application",</span><br><span class="line">    "appId": "myApp"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 <code>package.json</code>의 npm command를 수정하여 실행해 보자.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ..</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "start": "electron .",</span><br><span class="line">    "pack": "electron-builder"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run pack</span><br></pre></td></tr></table></figure><p>별도의 빌드옵션을 주지 않았기 때문에 가장 기본적으로 빌드가 될 것이다. 그래도 만족하지 않은가?</p><p>빌드 결과를 확인해 보자.</p><p><img src="build.png" alt="cover"></p><p><code>build</code> 디렉토리가 생성되었을 것이고, 그 안에는 <code>win-unpacked</code> 디렉토리와, 생성된 <code>exe</code> 파일이 존재할 것이다. <code>win-unpacked</code> 안에는 빌드 결과물이 있으며, 이 안에도 <code>exe</code> 파일이 있을 것이다. 이 파일을 실행해 보자.</p><p>우리가 만든 Electron Application이 실행되는 걸 볼 수 있다. 그러면 이제 상위 디렉토리로 올라가 다른 <code>exe</code> 파일을 실행해 보자.</p><p>우리가 만든 Electron Application이 설치되는 것을 볼 수 있다. 바탕화면으로 가면 <code>Electron 기본 아이콘</code>으로 바로 가기가 생성된 것도 확인해 볼 수 있으며, <code>제어판 &gt; 프로그램 및 기능으로 가면 설치된 항목</code>을 볼 수 있다.</p><hr><p>여기까지 해서 Electron이 무엇인지 그리고 Electron의 추이가 어떤지 확인도 해보고 간단하지만, Electron Application을 생성하고 실제로 배포까지 해 보았다. 간단하지만 우리는 지금 Electron의 한 과정을 경험 해 본 것이다. 이제 좀 더 퀄리티있는 Application을 만들기 위해 우리는 <code>Web Framework를 추가해서 실제 그럴싸한 Application</code>을 만들어 보자. 다음 포스팅엔 <strong> Vue.js와 Electron을 사용하는 방법 </strong>에 대해서 알아보도록 하자. 그전에 Vue.js가 무엇인지 <a href="https://kdydesign.github.io/2017/11/15/vuejs-concept/">자바스크립트 프레임워크 - Vue.js</a>에서 확인해보도록 하자.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> npm </category>
          
          <category> electron </category>
          
          <category> electron.js </category>
          
          <category> electron 설치 </category>
          
          <category> electron 튜토리얼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> npm </tag>
            
            <tag> nodejs </tag>
            
            <tag> electron </tag>
            
            <tag> electron.js </tag>
            
            <tag> electron 배우기 </tag>
            
            <tag> electron 튜토리얼 </tag>
            
            <tag> elertron tutorial </tag>
            
            <tag> electron framework </tag>
            
            <tag> electron 설치 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuxt.js 개념부터 설치까지 빠르게 배우기</title>
      <link href="/2019/04/10/nuxtjs-tutorial/"/>
      <url>/2019/04/10/nuxtjs-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>이번 포스팅에서는 Vue.js Application을 쉽게 생성하고 만들 수 있는 프레임 워크인 Nuxt.js에 대해서 알아볼까 한다.<br>Nuxt.js는 React의 Next.js에서 영감을 받아 진행된 프로젝트로 온전히 겉으로만 본다면 프레임워크이기 때문에 leaning curve가 있을 것 같지만 사실상 그렇지는 않다. Nuxt.js를 설치하고 사용해 본다면 그저 Nuxt.js는 Vue.js를 사용할 때 하나하나 작업해줘야 할 요소들을 생성해주고 처리해주는 것임을 알 수 있다.</p><p>본 포스팅으로 써 Nuxt.js 도입에 고민하는 개발자에게 도움이 되었으면 한다. 장담하건데 Nuxt.js를 1년간 사용한 개발자로써 적극 추천하며 프로젝트에 도입해도 문제가 되지 않음을 알려주고 싶다.</p><p>본격적으로 Nuxt.js에 대해서 알아보자.</p><h1 id="Nuxt-js-소개"><a href="#Nuxt-js-소개" class="headerlink" title="Nuxt.js 소개"></a>Nuxt.js 소개</h1><p>먼저 <a href="https://nuxtjs.org/guide" target="_blank" rel="noopener">Nuxt.js의 공식 사이트</a> 이다. Vue.js와 마찬가지로 한국어 문서가 존재하지만 Nuxt.js의 발빠른 업데이트에 한국어 문서가 따라가지 못하는 것 같다. Vue.js 역시 동일하지만.. 그렇다고 번역하시는 분을 욕하는 게 아니라 그만큼 Nuxt.js의 활동이 활발하다는 이야기이다. 아무튼 이러한 이유로 영문본으로 보기를 바란다.</p><p>Nuxt.js의 소개를 본다면 이렇게 명시하고 있다.</p><div class="alert info no-icon"><ul><li>주요 범위는 UI Rendering이며, 클라이언트/서버 배포를 추상화한다.</li><li>Nuxt.js의 목표는 기본 프로젝트 베이스로 사용할 수 있으며 Node.js 기반의 프로젝트를 유연하게 사용할 수 있는 프레임 워크를 만드는 것이다.</li><li>Nuxt.js는 서버 사이드 렌더링 된 Vue.js 응용 프로그램의 개발을 위해 이에 필요한 모든 구성을 사전 설정한다.</li><li>Nuxt.js는 nuxt generate 라는 배포 옵션을 제공한다. nuxt gererate를 통해 vue.js를 정적인 응용 프로그램으로 빌드한다. 우리는 이 옵션이 마이크로 서비스가 있는 웹 응용 프로그램 개발의 다음 단계일 수 있다고 생각한다.</li><li>Nuxt.js는 단일 응용 페이지(SPA)를 신속하게 만들 수 있다.</li><li>Nuxt.js는 비동기 데이터, 미들웨어, 레이아웃 등과 같이 클라이언트 측과 서버 측 사이에서 개발하는 데 도움이 되는 많은 기능을 제공한다.</li></ul></div><p>어려운 말들이 많을 수 있겠지만 아직도 Nuxt.js를 사용을 해야 할지 말아야 할지 고민하는 당신을 위해 쉽게 설명을 해본다면 이렇다.</p><div class="alert success no-icon"><ul><li>Nuxt.js 설치만으로 이미 scaffolding(프로젝트 구조화)을 해주므로 딱히 프로젝트 구조에 대해서 고민할 필요가 없다.</li><li>Vue.js 하나하나 잡아줘야 할 라우팅을 Nuxt.js에서 파일을 생성하는 것만으로 라우팅을 자동으로 생성해 준다.</li><li>layout, store, middleware와 같은 요소들을 이미 구분을 지어주고 필요한 항목들을 처리해주기 때문에 순전히 개발에만 집중하면 된다.</li><li>Server-Side-Rendering에 필요한 요소가 이미 준비가 되어있다.</li><li>webpack을 통한 빌드 시스템이 이미 구현되어 있다. 그저 npm run만 해주면 된다.</li></ul></div><h1 id="Nuxt-js의-활동성"><a href="#Nuxt-js의-활동성" class="headerlink" title="Nuxt.js의 활동성"></a>Nuxt.js의 활동성</h1><p>Nuxt.js의 활용성과 기능이 아무리 좋다고 하더라고 결국 MIT 라이센스를 가진 오픈 소스이다. 오픈 소스의 단점은 버그 픽스를 하지 않고 버전 업데이트가 거의 없다면 사용할 수 없다는 것이다. 하지만 nuxt.js의 업데이트 주기는 매우 빠르다. (요즘 들어 더 빨라진 듯….). 해당 포스트 작성자는 Nuxt.js를 1.0.0-rc 버전부터 프로젝트에 도입하였고 현재 버전은 2.4.3을 사용하지만, 이제는 업데이트된 버전으로 마이그레이션하기가 힘들 정도로 업데이트 주기가 빠르다. 포스트 작성 날짜 기준으로 현재 Nuxt.js의 버전은 2.5.0이다.</p><p>아래 표를 통해 현재 nuxt.js가 얼마나 업데이트가 활발한지 확인해 보자. Nuxt.js의 버전 계획은 <a href="https://github.com/nuxt/nuxt.js/blob/dev/RELEASE_PLAN.md" target="_blank" rel="noopener">Nuxt.js Realease Plan</a>에서 확인이 가능하다.</p><table><thead><tr><th>버전</th><th>업데이트 날짜</th></tr></thead><tbody><tr><td>v1.0.0-rc6</td><td>2017-08-22</td></tr><tr><td>v1.0.0-rc7</td><td>2017-08-29</td></tr><tr><td>v1.0.0-rc8</td><td>2017-08-31</td></tr><tr><td>v1.0.0-rc9</td><td>2017-09-06</td></tr><tr><td>v1.0.0-rc10</td><td>2017-09-07</td></tr><tr><td>v1.0.0-rc11</td><td>2017-09-07</td></tr><tr><td>v1.0.0</td><td>2018-01-09</td></tr><tr><td>v1.1.0</td><td>2018-01-13</td></tr><tr><td>v1.0.1</td><td>2018-01-13</td></tr><tr><td>v1.2.0</td><td>2018-01-26</td></tr><tr><td>v1.2.1</td><td>2018-01-26</td></tr><tr><td>v1.3.0</td><td>2018-02-01</td></tr><tr><td>v1.4.0</td><td>2018-03-02</td></tr><tr><td>v1.4.1</td><td>2018-08-02</td></tr><tr><td>v1.4.2</td><td>2018-08-02</td></tr><tr><td>v1.4.1</td><td>2018-08-02</td></tr><tr><td>v1.4.4</td><td>2018-10-19</td></tr><tr><td>v1.4.5</td><td>2018-11-28</td></tr><tr><td>v2.0.0</td><td>2018-09-21</td></tr><tr><td>v2.1.0</td><td>2018-10-01</td></tr><tr><td>v2.2.0</td><td>2018-10-14</td></tr><tr><td>v2.3.1</td><td>2018-11-17</td></tr><tr><td>v2.3.2</td><td>2018-11-21</td></tr><tr><td>v2.3.4</td><td>2018-11-27</td></tr><tr><td>v2.4.0</td><td>2019-01-09</td></tr><tr><td>v2.4.2</td><td>2019-01-30</td></tr><tr><td>v2.4.3</td><td>2019-02-07</td></tr><tr><td>v2.4.5</td><td>2019-02-26</td></tr><tr><td>v2.5.0</td><td>2019-03-21</td></tr></tbody></table><h1 id="Nuxt-js-설치"><a href="#Nuxt-js-설치" class="headerlink" title="Nuxt.js 설치"></a>Nuxt.js 설치</h1><p>Nuxt.js 팀이 스캐폴딩 해둔 템플릿을 사용하려면 create-nuxt-app을 npx를 통해서 설치하면된다. <code>npx</code>는 NPM 5.2.0 버전 이후 기본적으로 제공되기 때문에 별도로 설치할 필요는 없다.<br>Node.js에 대해서 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a>를 참고하자.</p><h2 id="npx를-통한-Nuxt-js-설치"><a href="#npx를-통한-Nuxt-js-설치" class="headerlink" title="npx를 통한 Nuxt.js 설치"></a>npx를 통한 Nuxt.js 설치</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-nuxt-app &lt;project-name&gt;</span><br></pre></td></tr></table></figure><p>위와 같이 실행을 하게 되면 몇 가지 질문들이 나오는데 진행하는 프로젝트에 맞게 선택하여 설치하면 된다.</p><h2 id="vue-cli를-통한-Nuxt-js-설치"><a href="#vue-cli를-통한-Nuxt-js-설치" class="headerlink" title="vue-cli를 통한 Nuxt.js 설치"></a>vue-cli를 통한 Nuxt.js 설치</h2><p>Nuxt.js 버전이 올라가기 전에는 nuxt starter-template을 vue-cli를 통해서 설치하였다. CLI가 아닌 <a href="https://github.com/nuxt-community/starter-template/archive/master.zip" target="_blank" rel="noopener">ZIP</a> 파일로 받아 압축을 풀어도 된다.</p><p>먼저 vue-cli를 설치하자. vue-cli에 대해서는 <a href="https://cli.vuejs.org/guide/" target="_blank" rel="noopener">Vue CLI 공식 사이트</a>를 참고하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g @vue/cli</span><br><span class="line">$ npm i -g @vue/cli-init</span><br></pre></td></tr></table></figure><p>그다음으로 template를 설치하고 npm module을 설치하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vue init nuxt-community/starter-template &lt;project-name&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">$ npm i</span><br></pre></td></tr></table></figure><h3 id="offline-설치-방법"><a href="#offline-설치-방법" class="headerlink" title="offline 설치 방법"></a>offline 설치 방법</h3><p>간혹 당신이 속한 소속에서 보안상 문제로 해당 사이트나 커맨드를 차단하여 nuxt-community에 속한 tempate을 vue-cli로 설치가 되지 안는 경우가 있다.<br>이런 경우에는 <code>offline</code>으로 설치가 가능하다.</p><p>우선 사용자 경로에 <strong>.vue-templates</strong> 폴더를 하나 생성하자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\사용자이름\.vue-templates</span><br></pre></td></tr></table></figure></p><p>그다음 <a href="https://github.com/nuxt-community/starter-template" target="_blank" rel="noopener">Starter-Template</a>의 Github에서 해당 소스를 clone을 받고 위에서 생성한 폴더로 옮겨놓자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/nuxt-community/starter-template</span><br></pre></td></tr></table></figure><p>이 상태로 우리는 vue-cli를 통해서 github가 아닌 로컬에 저장된 템플릿을 사용할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vue init starter-template &lt;project-name&gt; --offline</span><br></pre></td></tr></table></figure><h2 id="Nuxt-js-단일-설치"><a href="#Nuxt-js-단일-설치" class="headerlink" title="Nuxt.js 단일 설치"></a>Nuxt.js 단일 설치</h2><p>Nuxt.js 단독으로 설치할 경우엔 아래와 같이 명령어를 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i nuxt</span><br></pre></td></tr></table></figure><h1 id="Nuxt-js-디렉토리-구조"><a href="#Nuxt-js-디렉토리-구조" class="headerlink" title="Nuxt.js 디렉토리 구조"></a>Nuxt.js 디렉토리 구조</h1><p>Nuxt.js의 기본 템플릿을 사용하였다면 이미 스캐폴딩이 되어 있을 것이다. 만약 단일로 Nuxt.js를 설치하였다 하더라도 해당 섹션을 보아야 하는 이유는 Nuxt.js 자체 내에서 필수로 있어야 하는 폴더들이 있기 때문이다.</p><p>디렉토리 구조를 파악해 보자.</p><h2 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h2><p>css, image, font와 같은 리소스들을 포함한다.</p><h2 id="components"><a href="#components" class="headerlink" title="components"></a>components</h2><p>애플리케이션에서 사용될 컴포넌트들을 포함하며 해당 경로에 위치된 컴포넌트들은 Nuxt.js의 비동기 데이터 함수인 <code>asyncData</code>또는 <code>fetch</code>를 사용할 수 없다.</p><h2 id="layouts"><a href="#layouts" class="headerlink" title="layouts"></a>layouts</h2><p>애플리케이션 전체에 대한 레이아웃을 포함한다. 기본으로 default.vue가 생성되어 있을 것이고 상황에 맞게 layout을 생성할 수 있다. <code>해당 디렉토리는 이름을 변경할 수 없다.</code></p><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>애플리케이션에서 사용될 middleware를 포함한다. middleware는 페이지 또는 레이아웃이 렌더링 되기 전에 실행이 되며, middleware를 페이지나 레이아웃에 바인딩하였다면 해당 페이지나 레이아웃이 실행되기 전에 매번 실행된다.</p><h2 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h2><p>실제 애플리케이션의 페이지 구성을 포함하며 해당 디렉토리의 구조에 따라 router가 자동으로 생성된다. <code>해당 디렉토리는 이름을 변경할 수 없다.</code></p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>애플리케이션에 바인딩 될 외부 혹은 내부 plugins를 포함한다.plugins는 애플리케이션이 인스턴스 화 되기 전에 실행하며 전역적으로 구성 요소를 등록하고 함수 또는 상수를 삽입할 수 있다.</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>해당 디렉토리는 정적인 파일들을 포함한다. 구성에 따라서 html, Javascript 파일도 포함 시킬 수 있다. <code>해당 디렉토리는 이름을 변경할 수 없다.</code></p><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>애플리케이션에서 사용될 vuex store 파일들을 포함한다. 기본적으로 비활성화 상태이고 store 디렉토리에 index.js 파일을 작성하면 store가 활성화된다. 구성에 따라서 모듈 형태의 store를 형성할 수 있다.  <code>해당 디렉토리는 이름을 변경할 수 없다.</code></p><h1 id="Nuxt-js-실행"><a href="#Nuxt-js-실행" class="headerlink" title="Nuxt.js 실행"></a>Nuxt.js 실행</h1><p>최초 템플릿을 설치하면 커맨드는 4가지가 존재한다.</p><table><thead><tr><th>COMMAND</th><th>설명</th></tr></thead><tbody><tr><td>dev</td><td>개발 서버를 Hot-reloading 상태로 localhost:3000으로 실행된다.</td></tr><tr><td>build</td><td>Webpack을 통해 애플리케이션을 빌드한다.</td></tr><tr><td>start</td><td>프로덕션(배포)모드로 서버를 시작한다.(build 실행 후 진행된다.)</td></tr><tr><td>generate</td><td>애플리케이션을 빌드하고 모든 라우트를 HTML 파일로 생성한다.(정적 호스팅)  </td></tr></tbody></table><p>지금까지 설치를 진행했으니 실행을 해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>설명대로 <code>localhost:3000</code>으로 접속하여 실행된 페이지를 확인해보자.</p><h1 id="Nuxt-js-개발-서버-Host-Port-변경"><a href="#Nuxt-js-개발-서버-Host-Port-변경" class="headerlink" title="Nuxt.js 개발 서버 Host/Port 변경"></a>Nuxt.js 개발 서버 Host/Port 변경</h1><p>개발 서버는 기본 localhost와 Port는 3000로 잡혀져 있지만, 해당 값을 변경하는 방법에는 몇 가지가 있지만 가장 기본적이고 보편적으로 사용되는 방법은 npm script를 수정하는 방법이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nuxt --hostname &lt;host&gt; --port &lt;port&gt;</span><br></pre></td></tr></table></figure><p>하지만 이런 경우는 드물고 우리는 이미 <code>package.json</code>에 명시되어 있기 때문에 <code>package.json</code>을 수정하자.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"nuxt --hostname &lt;host&gt; --port &lt;port&gt;"</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nuxt-js-Module"><a href="#Nuxt-js-Module" class="headerlink" title="Nuxt.js Module"></a>Nuxt.js Module</h1><p>여기까지 Nuxt.js를 설치하고 초기 상태까지 왔지만 앞으로 더 해야 할 일이 많을 것이다. 그중 가장 많이 처리되는 게 API 통신을 위한 <code>Axios</code>의 설치와 로컬 환경에서 CORS문제를 해결하여 개발을 하기 위한 <code>proxy</code>의 설치이다.</p><p>이 둘 다 <code>plugins</code>를 통해 설치하고 삽입할 수 있지만, 해당 포스트는 Nuxt.js 사용을 위한 포스트이기 때문에 <code>plugins</code>가 아닌 Nuxt.js의 <code>Module</code> 시스템을 설명하려 한다.</p><p>Nuxt.js <code>Module</code>은 핵심 기능은 <strong>확장하고 통합할 수 있는 Nuxt.js의 확장</strong>이다. 직접 Custom 하게 모듈을 만들 수 있으며, 이미 만들어진 모듈을 가져다 쓸 수 있다.</p><h2 id="Axios-Proxy-Module-사용"><a href="#Axios-Proxy-Module-사용" class="headerlink" title="Axios/Proxy Module 사용"></a>Axios/Proxy Module 사용</h2><p>Axios는 http 통신을 위해 사용되는 훌륭한 오픈 소스이다. 물론 Nuxt.js를 사용할 때 직접이 Axios를 사용해도 무방하다. 하지만 이 Axios를 가지고 Nuxt.js의 모듈화로 만들어진 것 있다. 우리는 그 <a href="https://axios.nuxtjs.org/setup" target="_blank" rel="noopener">Axios module</a>을 사용해보자. Axios를 기반으로 생성된 모듈이라 Axios API를 참고해도 무방하며, Axios의 경량화로 볼 수 있다. Axios 모듈은 <a href="https://github.com/nuxt-community/proxy-module" target="_blank" rel="noopener">Proxy</a> 모듈과 통합이 가능하기 때문에 Proxy 모듈도 같이 설치를 하자.</p><p>설치는 NPM으로 진행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i @nuxtjs/axios</span><br><span class="line">$ npm i @nuxtjs/proxy</span><br></pre></td></tr></table></figure><p>nuxt.config.js를 열어 설치된 모듈을 import 하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    modules: [</span><br><span class="line">        <span class="string">'@nuxtjs/axios'</span></span><br><span class="line">    ],</span><br><span class="line">    axios: &#123;</span><br><span class="line">        proxy: <span class="literal">true</span>     <span class="comment">// proxy 사용</span></span><br><span class="line">    &#125;,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        <span class="string">'/prefix-url'</span>: <span class="string">'proxy-url'</span>    <span class="comment">// proxy url</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 처럼 <code>proxy</code> 옵션에 url-prefix를 지정하게 되면 <code>/prefix-url</code>로 시작되는 API는 모두 <code>proxy-url</code>로 Proxy 된다.</p><p>이제부턴 Axios의 사용이 가능하며 심지어 proxy까지 연동이 되어 있다.</p><h2 id="Module-생성하기"><a href="#Module-생성하기" class="headerlink" title="Module 생성하기"></a>Module 생성하기</h2><p>이번에는 간단하게 <code>console.log</code>를 nuxt의 module로 직접 만들어보자.<br>먼저 프로젝트 Root 경로에 <code>modules</code> 폴더를 만들어 보자. 명칭은 상관없다. 그다음 <code>logs.js</code>와 <code>logs.template.js</code> 파일을 생성하자.</p><p>module을 생성하는데 필요한 파일은 두 가지이다.</p><div class="alert info no-icon"><ol><li>logs.js: 실제 nuxt.config.js의 modules에 사용될 index 파일</li><li>logs.template.js: nuxt module에 삽입될 템플릿 파일</li></ol></div><h3 id="logs-js"><a href="#logs-js" class="headerlink" title="logs.js"></a>logs.js</h3><p>logs.js에서는 module의 사용될 템플릿 역할을 하는 소스를 실제 nuxt 인스턴스에 삽입하는 과정을 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">_moduleOpts</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> moduleOptions = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.options.log, _moduleOptions)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.addPlugin(&#123;</span><br><span class="line">        src: path.resolve(__dirname, <span class="string">'logs.template.js'</span>),</span><br><span class="line">        moduleOptions</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.meta = <span class="built_in">require</span>(<span class="string">'../../../package.json'</span>)</span><br></pre></td></tr></table></figure><h3 id="logs-template-js"><a href="#logs-template-js" class="headerlink" title="logs.template.js"></a>logs.template.js</h3><p>logs.template.js는 실제 비즈니스 로직이 코딩되며 프로토타입의 명칭을 정한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (ctx, inject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> logs = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(...args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inject(<span class="string">'log'</span>, logs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h3><p>우리는 logs.template.js에서 inject에 <code>log</code>라고 정의를 하였고 nuxt 프로토타입에 삽입하였기 때문에 사용 시에는 <code>log</code> 앞에 <code>$</code>를 붙여서 사용하면 된다. 실제로 <code>this</code>를 확인해 보면 <code>$log</code>가 생긴 것을 확인해 볼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$log(<span class="string">'test log'</span>)</span><br></pre></td></tr></table></figure><h1 id="Root-Source-디렉토리-변경하기"><a href="#Root-Source-디렉토리-변경하기" class="headerlink" title="Root Source 디렉토리 변경하기"></a>Root Source 디렉토리 변경하기</h1><p>현재의 디렉토리 구조를 보면 layout, pages, components 등 모든 폴더가 root 경로로 지정되어있다. 하지만 결국 우리는 어떤 프로젝트에 Nuxt.js를 도입을 하게 되면 현재의 디렉토리 구조대로 쓰지 못할 경우가 발생된다. 예를 들어 root의 경로를 App으로 지정해보자.</p><p>디렉토리 구조는 다음과 같다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- App</span><br><span class="line">    - assets/</span><br><span class="line">    - components/</span><br><span class="line">    - layouts/</span><br><span class="line">    - middleware/</span><br><span class="line">    - pages/</span><br><span class="line">    - plugins/</span><br><span class="line">    - static/</span><br><span class="line">    - store/</span><br><span class="line">- node_modules/</span><br><span class="line">- package.json</span><br></pre></td></tr></table></figure></p><p>위 구조를 보면 모든 리소스는 <code>App</code> 경로 하위에 존재한다. 이럴 경우 우리는 <code>source directory</code>를 수정해줄 필요가 있다.</p><p>nuxt.config.js 파일을 열어 수정해주자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    srcDir: <span class="string">'App/'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Nuxt.js 는 스캐폴딩부터 Vue.js를 사용하면서 귀찮은 작업을 대신해 주기에 많이 사용하고 있다. 다만 좀 어려운 점은 처음에 제공되는 템플릿에서 좀 더 확장성을 가진 구조를 만들기 위해서는 nuxt.config.js의 옵션들을 자세히 알아야 하고 수정해야 한다는 점이다. nuxt.js에서 옵션이 워낙 많다 보니 프로젝트 구조를 잡을 때는 API 문서를 항상 열어 두는 것이 좋다.</p><p>해당 포스트는 Nuxt.js의 기초를 다루려고 하였지만 Nuxt.js의 API가 워낙 잘 되어있나 보니 불필요한 내용이 끼워지게 되었다. 다음 포스트에서는 Nuxt.js에서 middleware 처리를 어떻게 하는지, 또 pages 구조를 어떻게 잡아야 vue-route의 기능을 사용할 수 있는지 등에 대한 좀 더 깊이 있게 다루는 포스트를 올리도록 하겠다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> nuxt.js </category>
          
          <category> vue.js tutorial </category>
          
          <category> nuxt.js tutorial </category>
          
          <category> nuxt.js 설치 </category>
          
          <category> nuxt.js 기초 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> nuxt.js </tag>
            
            <tag> nuxt.js tutorial </tag>
            
            <tag> nuxt.js 설치 </tag>
            
            <tag> nuxt.js 기초 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 대용량 데이터의 처리 방법과 성능 최적화 방법 (Vue.js Performance)</title>
      <link href="/2019/04/10/vuejs-performance/"/>
      <url>/2019/04/10/vuejs-performance/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>1년간 대규모 프로젝트를 진행하면서 어려운 점이 한 두 가지가 아니다. 그 중 멘탈이 나갈뻔한 <code>Top 1</code>을 뽑자면 역시 <strong>Vue 성능</strong>이었다. 절대적으로 <strong>Vue의 성능이 느리다는 것은 아니다.</strong> Vue는 제 할 일을 다하고도 감탄하게 만드는 프레임워크라는 것에 변함은 없지만, 프로젝트를 진행하면서 수많은 변수가 존재하고 이 변수로 인해서 Vue 성능을 개선해야 되는 경우가 생겼었다. <code>Vue의 성능 최적화는 Vue의 core를 수정하는 것이 아니며, Vue의 반응형에 대해서 깊이 있게 알고 확인해본다면 충분히 해결할 수 있다.</code></p><p>이 포스트에서는 애플리케이션의 하나의 페이지에서 많은 양의 데이터를 표현을 해야 하는 경우 성능이 저하되기 때문에 성능을 높이고자 하는 개발자에게 도움이 되기를 바라며 작성한다.</p><h1 id="진행된-프로젝트-환경"><a href="#진행된-프로젝트-환경" class="headerlink" title="진행된 프로젝트 환경"></a>진행된 프로젝트 환경</h1><p>먼저 위에서 자꾸 프로젝트.. 프로젝트.. 하는데 어느 형태의 프로젝트 또는 어느 상황 속에서 Vue의 성능을 최적 화해야 하는가를 알아야 하므로 조건을 몇 가지 나열한다.</p><div class="alert info no-icon"><ol><li>SPA(Single Page Application)</li><li>빅데이터 처리(10만건의 데이터 출력)</li><li>Server-Side에서 Paging 처리가 아닌 Client 측면서의 Paging 처리</li><li>jQuery 컴포넌트의 사용(데이터 테이블)</li></ol></div><p>1번이야 당연하니 넘어가자…</p><h3 id="빅-데이터-처리"><a href="#빅-데이터-처리" class="headerlink" title="빅 데이터 처리"></a>빅 데이터 처리</h3><p>이 부분부터가 문제가 되기 시작한다. 근무하는 회사의 분야와 진행되는 프로젝트의 특징으로 인해서 한 페이지에서 출력하여 보여줘야 하는 row 데이터는 10만건 정도 된다. 표현은 데이터 테이블 형태로 표현을 해야 한다. 쉽게 보자면… <code>TR 태그의 Element 개수가 최소 10만개</code>를 넘어간다. 당연히 웹에서 표현하기 어렵다. 브라우저가 뻗어버리거나 사용이 불가능할 정도의 성능이 나오기 때문이다.</p><h3 id="Client-페이징-처리"><a href="#Client-페이징-처리" class="headerlink" title="Client 페이징 처리"></a>Client 페이징 처리</h3><p>물론 10만건의 데이터를 한 번에 표현할 수는 있다. <code>Virtual scroll 기법</code>을 사용하여 현재 화면에서 실질적으로 보여지는 row 만 DOM을 생성하고 이후 scrolling 시에 이어서 DOM을 업데이트 (화면에서 사라지는 부분을 삭제하든. 아니면 업데이트를 해주든.) 해 주면 10만 건이든 100만 건이든 생성되는 DOM의 개수는 제한적이다. 최초 기능의 컨셉을 이렇게 잡고 진행을 하였지만, <code>Virtual Scroll을 구현하기 위한 조건에 충족하지 못하기 때문에</code> (모든 TR 태그의 높이는 동일해야 한다.) 페이징 처리를 하는데 특성상 Client 측면에서 페이징 처리를 해야 한다.<br>이 말인즉슨 페이지를 넘길 때마다 API를 통해서 데이터를 조회하는 것이 아닌 최초 모든 데이터를 조회 후 Front-End 측면에서 페이징을 해야 한다는 의미이다.</p><h3 id="jQuery-컴포넌트의-사용"><a href="#jQuery-컴포넌트의-사용" class="headerlink" title="jQuery 컴포넌트의 사용"></a>jQuery 컴포넌트의 사용</h3><p>데이터는 데이터 테이블 형태로 출력하고 데이터 테이블은 Vue가 아닌 jQuery로 구현되어있고 이 jQuery 플러그인을 Vue로 Wrapping 하여 Vue Component로 재생성하였다. 그렇기 때문에 Vue Component로 생성한 데이터 테이블은 Vue의 반응형 대상에 들어가지만, 내부에 있는 jQuery는 Vue의 반응형 대상이 되지 않는다. 즉 데이터가 변경되면 jQuery 내부에서 DOM을 수동적으로 업데이트를 해줘야 한다.</p><hr><p>조건은 위와 같다. Front-End 개발자 입장에서는 뭔 이런 구조가 있나… 싶을 것이지만. 모든 게 내 마음대로 되면 얼마나 좋을까?</p><p>그럼 본론으로 들어가 이러한 환경 속에서 어떻게 성능을 최적화하는지 알아보자.</p><h1 id="JS-Heap-Memory의-최소화"><a href="#JS-Heap-Memory의-최소화" class="headerlink" title="JS Heap Memory의 최소화"></a>JS Heap Memory의 최소화</h1><p>Vue의 성능 최적화를 시키는 방법 결론부터 말하자면 <strong>js heap memory를 최소화</strong>하는 것이다.</p><p>대용량 데이터에 대해 서버 페이징 처리 없이 Front-End 측면에서 처리하기 위해서는 최대한 <code>js heap memory</code>를 낮춰야 한다. js heap memory가 증가하면 할수록 UI 상의 모든 컴포넌트가 느려지고 렌더링 역시 느려진다.</p><p>메모리가 증가하는 이유는 무언가가 읽고 쓰고 하는 행위를 할 때 증가한다고 볼 수 있다. 변수를 선언할 때에도, <strong>객체의 속성을 읽거나 수정</strong>할 때도 증가한다. 이렇게 증가한 메모리는 Garbage Collect에 의해 주기적으로 불필요하게 잡힌 메모리를 해제하여 메모리를 확보하는데 그렇지 않고 계속 쌓이는 경우가 있다. 이럴 경우 일반적으로는 메모리 누수로 판단한고 적절한 조치를 진행한다. 메모리 누수에 대한 몇 가지 조치방법이다.</p><blockquote><ul><li>전역 변수의 사용</li><li>타이머와 콜백</li><li>외부에서의 참조</li><li>Closures의 사용</li></ul></blockquote><p>자세한 내용은 검색을 통해 확인해 보기 바란다.</p><p>Vue에서는 이 내용도 중요하지만 가장 중요한 것은 위에서 언급한 <strong>객체의 속성을 읽거나 수정</strong> 항목이다.</p><p>Vue는 data, state, computed, getters와 같은 모델이 선언되면 <code>defineReactive</code>를 통해 해당 객체는 반응형 관리 대상으로 등록되어 반응적으로 변경이 되는데 이 과정에서 각 개체마다 <code>Observe</code> 생성되고 내부적으로 getter/setter가 생성된다. 실제로 모델의 데이터를 열어보면 <code>__Ob__</code>이 붙은 것을 확인할 수 있다.</p><p>생각해보자 10만건에 대해서 객체가 반응형이라면 개체 1개마다 getter/setter가 생성될 것이다. 10만개의 데이터가 단순 배열이 아닌 객체구조라면?? 10만건에 대해 이러한 과정을 거치는 것이(memory write) js heap memory의 증가 이유가 된다.</p><p>-p.s 이 부분이 항상 문제가 되는 것은 아니다. 하지만 데이터가 많을 때는 고려하는 것이 좋을 것으로 보인다.-</p><p><strong>그래서 가장 중요한 것은 대용량의 데이를 가지고 있는 모델은 Vue의 반응형 관리대상에서 제외를 시키는 것이다.</strong></p><h2 id="모델에-대한-가공은-최소화"><a href="#모델에-대한-가공은-최소화" class="headerlink" title="모델에 대한 가공은 최소화"></a>모델에 대한 가공은 최소화</h2><p>API를 통해서 데이터를 조회하고 Model 또는 State에 담아 놓는 게 일반적이다. 하지만 API를 통해 조회된 데이터가 실제로 화면에서는 다른 형태의 데이터로 표현해야 하는 경우가 있을 것이다.</p><p>예를 들면 use라는 속성값이 0/1 또는 true/false로 올 경우 Front-End 개발자들은 사용/미사용과 같은 형태로 출력해야 하는데 이러한 데이터 가공은 computed나 watch 또는 Store의 getters를 이용한다.</p><p>하지만 대용량 데이터를 가져야 하는 모델에 대해서는 최대한 데이터를 가공하지 말아야 한다. 이는 computed를 최소화하고 getters를 최대한 사용하지 말아야 한다는 말과 같다. 위에서 반응형에서 언급했듯이 모델이 반응 적이라면 그만큼 js heap memory를 차지하기 때문이다.</p><h2 id="모델에-대한-반응형-제거"><a href="#모델에-대한-반응형-제거" class="headerlink" title="모델에 대한 반응형 제거"></a>모델에 대한 반응형 제거</h2><p>해결방법은 단순하다. 대용량 데이터를 가진 모델에 대해 Vue의 감지 대상에서 제거하면 된다. 즉 <code>Observe가 생성되지 않게 처리하면 되는데 이는 vue의 관점에 처리해야 한다.</code></p><h3 id="Object-freeze-사용"><a href="#Object-freeze-사용" class="headerlink" title="Object.freeze() - 사용"></a>Object.freeze() - 사용</h3><p>이를 해결하기 위해서는 대용량 데이터를 가지고 있는 model 또는 state에 대해서 <code>Object.freeze()</code>를 사용하여 처리한다. <code>Object.freeze()</code>는 해당 객체를 <strong>read only로 처리를 하기 때문에 이 객체에 대해서는 속성을 추가할 수도 없고 제거할 수도 없으며, 수정할 수도 없다.</strong> 또한 해당 객체에 대한 프로토타입 역시 변경할 수 없다. 이렇게 순수하게 read only 객체로 되기 때문에 vue에서도 감지의 대상이 되지 않는다.</p><p><code>Object.freeze()</code>를 사용해야 하는 시점은 API를 통해 데이터를 조회 후 state에 매핑할 때 진행하면 된다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = &#123;</span><br><span class="line">    bookList: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    setBookList (state, payload) &#123;</span><br><span class="line">        state.bookList = <span class="built_in">Object</span>.freeze(payload)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actions = &#123;</span><br><span class="line">    getBookList (&#123;commit&#125;) &#123;</span><br><span class="line">        <span class="comment">// API call</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        commit(<span class="string">'setBookList'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-freeze-수정"><a href="#Object-freeze-수정" class="headerlink" title="Object.freeze() - 수정"></a>Object.freeze() - 수정</h3><p>하지만 위에서 언급한 바와 같이 <code>Object.freeze()</code>를 사용하게 되면 해당 객체는 변경이 불가능하기 때문에 기능상 CRUD의 행위들은 모두 불가능하게 된다. 이 부분은 객체를 복사하는 방향으로 진행할 수 있으며, 객체를 복사한다 하더라고 기존에 증가되는 메모리 양보다는 비용이 적게든다. 중요한 것은 복제된 객체는 전혀 다른 객체가 되므로 <code>Object.freeze()</code>의 대상이 되지 않으며 (map의 경우 동일) 변경이 가능하게 되지만 최종적으로는 다시 <code>Object.freeze()</code>로 vue의 감지 대상에서 제거해야한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = &#123;</span><br><span class="line">    bookList: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    addBookList (state, boolList) &#123;</span><br><span class="line">        <span class="comment">// lodash clone</span></span><br><span class="line">        <span class="keyword">let</span> cloneBookList = _.cloneDeep(bookList)</span><br><span class="line"></span><br><span class="line">        cloneBookList.splice(<span class="number">1</span>, <span class="number">0</span>, &#123;<span class="attr">name</span>: <span class="string">'add book'</span>, <span class="attr">date</span>: <span class="string">'2019-04-08'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        state.bookList = <span class="built_in">Object</span>.freeze(cloneBookList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-freeze-Array-prototype-map"><a href="#Object-freeze-Array-prototype-map" class="headerlink" title="Object.freeze - Array.prototype.map"></a>Object.freeze - Array.prototype.map</h3><p>배열 또는 Collection의 경우 map을 통해 객체를 확장, 수정을 진행하게 되는데 map의 경우 clone과 같이 유사한 패턴을 가질 수 있기 때문에(배열을 새로운 배열 요소로 변경) clone을 사용하지 않는 범위에서 위와 같은 절차대로 진행하며, map의 return 자체를 <code>Object.freeze()</code>로 처리한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = &#123;</span><br><span class="line">    bookList: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    addBookList (state, boolList) &#123;</span><br><span class="line">        <span class="comment">// lodash map</span></span><br><span class="line">        <span class="keyword">let</span> cloneBookList = bookList.map(<span class="function"><span class="params">book</span> =&gt;</span> book.name = <span class="string">'kdydesign'</span>)</span><br><span class="line"></span><br><span class="line">        state.bookList = <span class="built_in">Object</span>.freeze(cloneBookList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>그 간 웹 Front-End 개발을 하면서 항상 부닥치는 문제는 성능이었다. 대부분이 메모리 누수로 인한 문제였지만 이번만은 좀 다른 형태였던 것 같다. Vue의 겉핥기식으로 배워 프로젝트에 도입하고 1년간 진행하면서 크게 배운 것 하나가 또 이 내용이다. <code>Object.freeze()</code> 사용이 어떻게 보면 비효율적일 수 있을 것이다. 객체를 read only로 변환을 하지만 CRUD의 루틴을 위해 다시 Vue의 감지대상으로 바꾼 후 또다시 <code>Object.freeze()</code>를 통해 read only로 변환한다는 것이.. 좀 더 파고들고 노하우가 더 쌓이면 더욱더 좋은 루틴으로 성능을 최적화하는 방법이 떠오른다면 그때 가서 이 포스트는 수정할 것이다. 그때까지는 이 방법으로 해결하는 것이 좋을 듯하다.</p><p>다음 포스트에는 성능 측정 방법에 대해 올려 볼 예정이다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> nuxt.js </category>
          
          <category> vue.js tutorial </category>
          
          <category> nuxt.js tutorial </category>
          
          <category> vue.js performance </category>
          
          <category> vue.js big data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> vue.js performance </tag>
            
            <tag> vue.js big data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js의 Vuex Store를 바인딩하는 4가지 방법!!</title>
      <link href="/2019/04/06/vuejs-vuex-helper/"/>
      <url>/2019/04/06/vuejs-vuex-helper/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>해당 포스트에서는 Vuex의 설명과 사용법에 대해서는 언급하지 않았으며, 오로지 Vuex Store를 컴포넌트에 바인딩하는 방법을 설명한다.</p><p>프로젝트의 규모가 크거나 작든 <code>Vuex를 사용할 때는 Store를 Module 별로 분리</code>하는 것이 바람직하다. 그렇지 않으면 각 컴포넌트마다 바인딩 된 Store의 state들이 다른 컴포넌트의 루틴에 의해 오염될 가능성과 코드의 복잡성이 높아지게 되어 있다. </p><p>이번 포스트에서는 모듈별로 분리된 Store를 각 컴포넌트에서 효율적으로 바인딩시키는 여러 가지 방법들과 코드 스타일을 알아보자.</p><h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><p>Vue 공식 API에서는 명시된 기본 Store 바인딩 방법이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    computed: mapState(&#123;</span><br><span class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line">        countAlias: <span class="string">'count'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>위 내용은 <code>mapState</code>라는 Helper를 이용하여 객체의 형태로 <code>count</code>를 바인딩 한 형태이고 아래처럼 state의 이름을 그대로 상속받아 정의할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    computed: mapState([</span><br><span class="line">        <span class="string">'count'</span></span><br><span class="line">    ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>기본적인 바인딩 방법은 가장 단순한 구조를 가진 Store를 바인딩하였을 때이다. 하지만 Store가 여러 모듈별로 분리되어 있고 하나의 컴포넌트에서는 여러 Store 모듈을 바인딩해야 한다면 매우 복잡해질 것이다.</p><p>아래 가정을 가지고 각 바인딩 Style을 살펴보자.</p><div class="alert danger no-icon"><p>각각 <strong>User</strong>, <strong>Book</strong> 이라는 Store 모듈이 존재하고, <strong>User</strong>는 <code>A/B</code> 경로에 있으며, <strong>Book</strong>은 <code>A/B/C</code> 경로에 위치한다.</p></div><p>프로젝트 구조는 다음과 같다.</p><div class="alert info no-icon"><p>A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- B<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- user<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- C<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- Book</p></div><h1 id="Style-1-Vuex-Helper"><a href="#Style-1-Vuex-Helper" class="headerlink" title="Style 1 - Vuex Helper"></a>Style 1 - Vuex Helper</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState, mapActions&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ... mapState(&#123;</span><br><span class="line">            bookList: <span class="function"><span class="params">state</span> =&gt;</span> state.A.B.C.Book.list</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...mapActions([</span><br><span class="line">            <span class="string">'A/B/C/Book/setList'</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>또는</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ... mapState(<span class="string">'A/B/C/Book'</span>, &#123;</span><br><span class="line">            bookList: <span class="function"><span class="params">state</span> =&gt;</span> state.list</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">     methods: &#123;</span><br><span class="line">        ...mapActions(<span class="string">'A/B/C/Book'</span>, [</span><br><span class="line">            <span class="string">'setList'</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>특정 경로에 포함된 Store 모듈을 사용하기 위해서는 해당 경로를 모두 명시해줘야 한다. 이렇게 사용을 한다면 어느 경로에 있든 서로 다른 Store 모듈을 하나의 컴포넌트 또는 여러 컴포넌트에서 바인딩하여 사용이 가능하다. 하지만 위 예제에서 A/B/C의 단순하고 짧은 명칭이지만 폴더나 Store 모듈의 명칭이 꽤나 길다면 역시나 가독성이 좀 떨어질 것이다. 그래서 우리는 Vuex에서 제공하는 Namespace Helper를 생성할 수 있는 <code>createNamespacedHelpers</code> 이용하여 바인딩하는 것을 가장 인상적으로 볼 수 있다.</p><h1 id="Style-2-createNamespacedHelpers-1"><a href="#Style-2-createNamespacedHelpers-1" class="headerlink" title="Style 2 - createNamespacedHelpers 1"></a>Style 2 - createNamespacedHelpers 1</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;mapState&#125; = createNamespacedHelpers(<span class="string">'A/B/C/Book'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ... mapState(&#123;</span><br><span class="line">            bookList: <span class="function"><span class="params">state</span> =&gt;</span> state.list</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>또는</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;mapState&#125; = createNamespacedHelpers(<span class="string">'A/B/C/Book'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ... mapState([</span><br><span class="line">            <span class="string">'list'</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>모듈의 이름이 길고 구조가 복잡하다면 <code>createNamespacedHelpers</code>를 사용하여 바인딩한다면 computed 또는 methods가 간결하고 뛰어난 가독성을 보이는 것을 알 수 있다.</p><p>Store 모듈들의 경로를 computed와 methods에 정의를 안 했을 뿐이지 무엇이 다르겠냐고 한다면 생각해보자. 우리는 개발을 하면서 코드를 살펴볼 때나 구현을 할 때 가장 상단에 삽입하거나 명시해 놓은 구현체는 자주 보지 않는다. 오히려 data, computed, methods를 가장 많이 볼 것이다. 이러한 상황에서 수많은 모듈의 경로가 명시되어 있다면 state나 mutation, action의 개체들을 찾기 어려울 것이다.</p><h1 id="Style-3-createNamespacedHelpers-2"><a href="#Style-3-createNamespacedHelpers-2" class="headerlink" title="Style 3 - createNamespacedHelpers 2"></a>Style 3 - createNamespacedHelpers 2</h1><p>그러면 여기서 좀 더 깊이 한번 보자.</p><p>만약 <code>createNamespacedHelpers를</code> 사용을 한다고 하지만 만약 하나의 컴포넌트에 서로 다른 경로에 있는 Store 모듈을 여러 개 바인딩할 경우에는 어떻게 해야 할까?<br>지금까지 <code>Book</code>이라는 모듈만을 가지고 예제를 보았지만, 여기에서 <code>User</code> 모듈을 추가해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span></span><br><span class="line">    &#123;<span class="attr">mapState</span>: userMapState, <span class="attr">mapActions</span>: userMapActions&#125; = createNamespacedHelpers(<span class="string">'A/B/User'</span>),</span><br><span class="line">    &#123;<span class="attr">mapState</span>: bookMapState, <span class="attr">mapActions</span>: bookMapActions&#125; = createNamespacedHelpers(<span class="string">'A/B/C/Book'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ... userMapState(&#123;</span><br><span class="line">            userList: <span class="function"><span class="params">state</span> =&gt;</span> state.user.userList</span><br><span class="line">        &#125;),</span><br><span class="line">        ... bookMapState([</span><br><span class="line">            <span class="string">'list'</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...userMapActions(&#123;</span><br><span class="line">            setUserList: <span class="string">'setUserList'</span></span><br><span class="line">        &#125;),</span><br><span class="line">        ...bookMapActions([</span><br><span class="line">            <span class="string">'setBookList'</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>아래처럼 정의도 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span></span><br><span class="line">    userListHelper = createNamespacedHelpers(<span class="string">'A/B/User'</span>),</span><br><span class="line">    bookListHelper = createNamespacedHelpers(<span class="string">'A/B/C/Book'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ... userListHelper.mapState(&#123;</span><br><span class="line">            userList: <span class="function"><span class="params">state</span> =&gt;</span> state.user.userList</span><br><span class="line">        &#125;),</span><br><span class="line">        ... bookListHelper.mapState([</span><br><span class="line">            <span class="string">'list'</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        ...userListHelper.mapActions(&#123;</span><br><span class="line">            setUserList: <span class="string">'setUserList'</span></span><br><span class="line">        &#125;),</span><br><span class="line">        ...bookListHelper.mapActions([</span><br><span class="line">            <span class="string">'setBookList'</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이렇게 한다면 하나의 컴포넌트에서도 많은 모듈을 바인딩하기가 쉬우며, 코드의 가독성 역시 좋아진다.</p><hr><p>각 개발자마다 코드 스타일은 모두 다르고 해당 포스트에 언급한 내용 이외에 더 좋은 방법이 있을 수 있다. 다만 중요한 것은 개발하기 전 또는 하면서 어느 방법이 가장 좋은지 몸소 느끼며 차근차근 수정해 나아가는 것이 중요하다고 본다. 어느 스타일이든 결과는 같겠지만 업무/개발의 속도는 확연히 차이가 날 것이다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> vue.js tutorial </category>
          
          <category> vuex tutorial </category>
          
          <category> vuex helper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
            <tag> vuex </tag>
            
            <tag> vuex component binding </tag>
            
            <tag> store </tag>
            
            <tag> vue.js tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>빠르게 배우는 Vue.js</title>
      <link href="/2017/11/15/vuejs-tutorial/"/>
      <url>/2017/11/15/vuejs-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>포스팅을 시작하기전에 이번 포스팅에는 개인적인 느낌과 방향성을 매우 많이 포함시켰다. 이점 참고하기 바란다.</p><p>한창 상승 중인 Front-End를 위한 JavaScript Framework인 Vue.js를 시작하기 앞서 먼저 Vue.js에 대해 알아보고 개념을 잡고 시작하자.</p><p>이번 프로젝트를 위해 2시간의 세미나를 걸쳐 Vue.js 약(?)을 팔았다. 다행히 결과가 좋아 기존에 Survey 된 프레임워크인 <code>Backbone.js</code>를 <code>Vue.js</code>로 변경하기로 하였다. 물론 Backbone.js가 Vue.js보다 못하다는 말이 아니다. 앞으로 진행되어야 할 프로젝트에서 컴포넌트 방식의 개발 요소가 매우 필요하였고, 이러한 구성을 Backbone.js로 프로토타입을 구현하니 막상 복잡함 감이 없지 않았다. 이에 따라 다른 기술을 survey하다 Vue.js를 채택하게 되었다. 한창 상승 중인 프레임워크인지라 물론 여러 번 지나가다 보기만 하였지만 이번에 제대로 접근해 보니 매우 진보적이고 훌륭한 프레임워크라고 생각이 들어 포스팅하게 되었다.</p><p>그럼 먼저 <code>Vue.js</code>에 대해 기본적인 개념부터 알아보고 다음 포스팅부터 실제로 만져 보면서 학습해보자.</p><h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p><a href="https://kr.vuejs.org/" target="_blank" rel="noopener">Vue.js 공식 사이트</a>에 접속해 보면 첫 페이지에 딱 3글자로 요약을 해 놓았다.</p><div class="alert info no-icon"><ul><li>Approachable(접근성)</li><li>Versatile(유연성)</li><li>Performant(고성능)</li></ul></div><p>단어만 보아도 대강 유추는 가능하다. JavaScript 프레임워크로 HTML, CSS, JavaScript를 알고 있다면 가이드를 통해 충분히 빠른 시간내에 습득이 가능하며, 작은 용량으로 빠른 <code>Virtual DOM</code>을 제공한다. 다른 의미로 Vue.js를 본다면 다음과 같을 것이다.</p><div class="alert info no-icon"><ul><li>View를 위한 JavaScript 프레임워크</li><li>사용자 인터페이스를 만들기 위한 진보적인 프레임워크</li><li>MVVM 디자인 패턴에서 영감을 얻은 프레임워크</li></ul></div><h1 id="추이"><a href="#추이" class="headerlink" title="추이"></a>추이</h1><p>JavaScript Web Front-End Framework는 무수히 많다. 그중 가장 활성화되어 있고 많이 사용하는 대표적인 프레임워크에는 <code>Angular.js</code>와 <code>React.js</code>가 있다. 이 두 프레임워크에 비한다면 Vue.js는 아직 갈길이 멀다. 하지만 전체적으로 본다면 그렇지만 최근의 기록을 본다면 Vue.js가 곧 Angular.js와 React.js 앞지를 가능성이 보인다는 것을 알 수 있다.</p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1173_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"Vue.js","geo":"","time":"today 5-y"}],"category":0,"property":""}, {"exploreQuery":"date=today 5-y&q=Vue.js","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script> <p>또한, <a href="https://risingstars2016.js.org/?ref=freecodecamp-loves-you#all" target="_blank" rel="noopener">Most Popular Projects in 2016</a>에서 확인해 보면 2016년도에 Github에서 star를 받은 수가 월등히 Vue.js가 높다는 것을 알 수 있을만큼 상승 중에 있다.(해당 내용은 <a href="https://velopert.com/3007" target="_blank" rel="noopener">VELOPERT.LOG</a>의 포스트를 참조하였습니다.)</p><h1 id="사용성"><a href="#사용성" class="headerlink" title="사용성"></a>사용성</h1><p>어느 프로젝트이든 또는 어떤 제품이든 그 결과적인 솔루션이 어떤 프레임워크를 사용하였는지는 알기 어렵다. 물론 해당 담당자나 개발자가 공표하지 않는다는 조건에서 말이다. 그래서 우리는 현재 널리 분포되어있는 웹 중 얼마나 Vue.js가 적용되었는지는 수치상 알 수 없지만 다른 방법으로 유추가 가능하다. 이에 대한 답을 먼저 보고 가자.</p><div class="alert danger no-icon"><ul><li>stackoverflow 질문 수 - <strong>약 20,890</strong></li><li>npm 다운로드 수 - <strong>약 1,219,567</strong></li><li>github 이슈 - <strong>약 82</strong></li></ul></div><p>우리는 <code>StackOverflow</code> 에 등록된 질문 수와 <code>NPM의 다운로드 수</code> 그리고 <code>Vue.js의 github에 올라와 있는 이슈의 수</code>를 통해 얼마나 활성화가 되어 있는지 감을 잡을 수 있다. 이런 내용을 포스팅에 추가한 이유는 아무래도 Vue.js의 도입을 망설이는 개발자 또는 담당자 또는 기획자가 있을 수 있기 때문이다. 아무리 상승 중인 프레임워크라고는 하나 이에 대한 정보가 부족하다면 우리는 개발을 하면서 큰 난관에 자주 봉착 될 것이다. 그렇기에 이렇게 대강이나마 도움이 되었으면 하는 바램으로 수치상의 데이터를 남겨본다. </p><p>또한 눈치가 빠른 사람이라면 알 수 있을 것이다. github에 등록된 이슈의 수에 대해 말이다. <a href="https://npmcompare.com/compare/angular,react,vue" target="_blank" rel="noopener">NPMCompare</a>에서 Angular와 React를 본다면 각각 등록된 이슈의 수는 약 700건과 400건이다. 이에 비해 Vue.js는 약 80건 밖에 되지 않는다. 직관적으로 본다면 그만큼 Vue.js의 사용자가 Angular.js나 React.js보다 매우 적다라는 것으로 볼 수 있지만 또 다른 관점으로 본다면 등록된 이슈의 건수가 낮은 Vue.js는 그만큼 안정적이란 말이 될 수 있다.</p><p>개인적으로 생각해보건데 프레임워크의 개발 규모 관점에 보았을 때 Angular.js나 React의 경우 각각 Google과 Facebook이라는 매우 규모가 큰 타이틀이 붙는 반면 Vue.js는 Evan You라는 단일 개발자가 개발이 되었다. 규모의 차이가 매우 크지만 전혀 Vue.js가 밀리지 않는다고 생각된다.</p><h1 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h1><p>Vue.js의 특징을 몇가지 꼽아 보자면 다음과 같을 수 있다.</p><div class="alert info no-icon"><ul><li>MVVM 패턴에서 영감을 받아 개발</li><li>Virtual DOM의 사용</li><li>Learning curve가 낮음</li><li>Angular.React에 비해 매우 작고 가벼우며 복잡도가 낮음</li><li>Template과 Componenet를 사용하여 재사용이 가능한 사용자 인터페이스를 묶고 View Layer를 정리</li><li>Model을 통한 양방향 데이터 바인딩을 동하게 제공하지만 Component간 통신의 기본틀은 단방향(부모-&gt;자식)</li><li>Server side Rendering 지원</li></ul></div><p>Vue.js를 대강 아는 사람들이고 들어본 사람들은 이렇게도 들어보았을 것이다. <code>angular + react = vue</code>. 맞는 말이기는 하다. angular의 지시자(Directive)가 있을 뿐더라 react와 같이 <code>Virtual DOM</code>을 제공한다. </p><p>그렇다면 이렇게 장점만 합쳐 놓았다면 다른 프레임워크와 다른점이 무엇인가?<br>그것은 해당 공식 사이트에서 확인 할 수 있다. Vue.js 개발 팀은 편견을 버리고 객관적으로 Vue.js와 Angular.js, React.js 그리고 Ember.js와 같은 여러 프레임워크를 비교해 놓았다. 해당 내용은 <a href="https://kr.vuejs.org/v2/guide/comparison.html" target="_blank" rel="noopener">다른 프레임워크와의 비교</a>에서 확인 할 수 있다.</p><hr><p>무엇인가 Vue.js에 대해 설명 포스팅을 하자고 생각했을 때는 거창하게 글을 써보려하였지만 막상 그렇게 하려니 마음대로 되지 않는다. 글을 아무리 설명을 해도 실제로 피부로는 와 닿지 않기 때문이다. 그래서 해당 Vue.js의 소개 포스팅은 짧게 가보고 이어지는 Tutorial을 길게 가볼 생각이다.</p><p>현재 Vue.js를 사내에 도입하여 앞으로 진행된 차기 제품(프로젝트라고 하기 보다 Vendor사이기에..)의 UI는 Vue.js로 가기로 하였고 기존에 jQuery와 Backbone으로 만들어 놓은 여러 Component를 Vue.js로 Converting 하고 있는데 훌륭하다. 훌륭하다. 매우 훌륭하다라고 자꾸 느껴지는 Vue.js이다. 오래만에 개발을 하면서 설레이고 흥분되는 느낌을 받는다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue.js </category>
          
          <category> nuxt.js </category>
          
          <category> vue.js tutorial </category>
          
          <category> nuxt.js tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 완전정복하기!!</title>
      <link href="/2017/11/04/webpack-tutorial/"/>
      <url>/2017/11/04/webpack-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>지금까지 우리는 <a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a> 포스트에서 webpack에 대한 기본 개념을 먼저 살펴보았다. 왜 webpack이 많이 사용되는지와 <code>Gulp</code>와의 차이점을 알았다면 이제 실제로 webpack을 설치해보고 사용해 보면서 하나하나 짚어나가 보자. <strong>이 포스트에 올린 예제들은 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack 공식 사이트</a>들의 예제를 포함하고 있다.</strong></p><h1 id="Webpack-설치-및-Build"><a href="#Webpack-설치-및-Build" class="headerlink" title="Webpack 설치 및 Build"></a>Webpack 설치 및 Build</h1><p>webpack은 npm으로 쉽게 설치할 수 있다. 만약 이 포스트를 보는 당신은 npm이 무엇인지 모른다면 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a> 포스트를 참고하자. 자! 이제 설치를 해보자. 먼저 적당한 경로에 <code>Webpack_Project</code>라는 이름의 프로젝트 폴더를 생성하고 해당 폴더에서 명령 프롬프트를 실행하여 <code>webpack</code>을 설치하자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br><span class="line">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure><p>먼저 <code>npm init -y</code>를 통해 package.json을 생성하고 <code>npm install webpack --save-dev</code>명령을 통해 webpack을 설치하면서 동시에 package.json에 적용하였다. 실제로 webpack의 설치는 이것으로 끝이다. 우리는 항상 설치가 정상적으로 됐는지 확인은 버전으로 확인을 한다. 확인해보자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .\node_modules\.bin\webpack -v</span><br></pre></td></tr></table></figure><p>버전이 출력된다면 정상적으로 설치가 완료된 것이다.</p><h2 id="CLI를-사용한-Build"><a href="#CLI를-사용한-Build" class="headerlink" title="CLI를 사용한 Build"></a>CLI를 사용한 Build</h2><p>가장 기초적인 방법으로 <code>webpack cli</code>명령어를 통해 javascript를 build 해 보자. 테스트에 필요한 파일은 <code>index.js</code>와 <code>index.html</code>이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">element.innerHTML = <span class="string">'Hello Webpack!!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(component());</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br></pre></td></tr></table></figure><p>코드는 간단하다. <code>Hello Webpack!!</code>이라는 문구를 출력할 뿐이다. 그런데 html에서는 조금 다르다. 먼저 .js파일을 불러오는 것은 이해가 되지만 우리가 만든 파일은 <code>index.js</code>인데 왠 <code>bundle.js</code>라는 파일을 호출하였을까. 일단 궁금증은 접어두고 webpack을 통해 build를 해보자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .\node_modules\.bin\webpack index.js bundle.js</span><br></pre></td></tr></table></figure><p>여기서 <code>bundle.js</code>가 나왔다. 대강 이해가 가는가? 우리는 위에 있는 cli를 통해 <code>index.js</code>를 <code>bundle.js</code>로 build 한 것이다. 그렇기 때문에 <code>index.html</code>에서는 처음에는 존재하지는 않지만, build 후에 생성 될 <code>bundle.js</code>를 호출한 것이다. 비록 지금은 코드나 그 프로젝트 구조가 복잡하지 않기 때문에 별 느낌이 없을지 모르겠지만 이 포스트를 끝까지 읽는다면 어느 정도 감이 올 것이다.</p><h2 id="config를-사용한-Build"><a href="#config를-사용한-Build" class="headerlink" title="config를 사용한 Build"></a>config를 사용한 Build</h2><p>cli를 통한 build는 단순한 구조의 파일을 build 하기에는 편하지만 실제로 우리가 어떤 프로젝트에 임하면 그 프로젝트는 <code>절.대.로</code> 간단한 구조로 되어 있지 않다. build 시에 더욱 부가적인 요소들을 요구하며 이 요소들을 통하여 build를 하게 된다. 이렇게 복잡한 build의 경우 webpack에서는 어떤 특정한 설정 파일에 build에 필요한 요소들을 나열하고 해당 설정 파일을 통해 build를 진행하게끔 지원한다.</p><p>먼저 <code>Webpack_Project</code> 경로에 <code>webpack.config.js</code>라는 javascript 설정 파일을 만들고 간단한 설정부터 진행하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이렇게 작성된 설정 파일은 webpack 명령어를 통해 실행할 수 있다. (물론 실행 시에는 해당 디렉토리 경로에서 실행하자.)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .\node_modules\.bin\webpack</span><br></pre></td></tr></table></figure><p>결과는 <code>webpack cli</code>명령어를 통하여 build 한 내용과 동일하지만 <code>bundle.js</code>의 생성 위치가 다르다. 하나씩 살펴보자. </p><div class="alert danger no-icon"><ul><li><strong>path</strong> - 파일의 경로를 다루고 변경하는 유틸리티</li><li><strong>output</strong> - build 결과를 저장할 경로</li><li><strong>entry</strong> - build의 대상이 될 파일 </li></ul></div><p>처음 우리가 webpack cli를 통해 build 할 때는 build 될 대상과 build 된 파일을 명시해줬지만 여기서는 그저 webpack 이라는 단순한 명령어를 사용하였다. 그 이유는 우리가 webpack의 설정을 정의한 <code>webpack.config.js</code>를 생성하였고 이 파일은 webpack 명령어의 기본 파일이기 때문이다. 만약 우리가 설정파일이 <code>webpack.config.js</code>가 아닌 <code>webpack.build.js</code>와 같은 다른 파일로 정의를 하였다면 아래와 같은 명령어를 통해 실행 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .\node_modules\.bin\webpack --config webpack.build.js</span><br></pre></td></tr></table></figure><h1 id="Loader-사용하기"><a href="#Loader-사용하기" class="headerlink" title="Loader 사용하기"></a>Loader 사용하기</h1><p>우리는 이전 포스트인 <a href="https://kdydesign.github.io/2017/07/27/webpack/">Webpack 개념잡기</a>에서 <code>webpack은 크게 Entry, Output, Loader, Plug-In 이 4가지로 나눌 수 있다.</code> 라고 하였다. 이미 앞서 webpack을 설치하고 build 해 보면서 <code>entry</code>와 <code>output</code>이 무엇인지 대강 감을 잡았으니 이제 파일을 사전 처리하여 정적인 리소스들을 javascript와 같이 하나의 bundle로 만들 수 있는 <code>Loader</code>를 알아보자.</p><h2 id="style-loader-css-Loader"><a href="#style-loader-css-Loader" class="headerlink" title="style-loader, css-Loader"></a>style-loader, css-Loader</h2><p><code>style-loader</code>와 <code>css-loader</code>는 같이 사용되며 <code>style-loader</code>는 <code>&lt;style&gt;</code>태그를 삽입하여 CSS를 추가해주는 역할을 한다. 모든 설치는 npm을 통해 설치를 진행한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install style-loader css-loader --save-dev</span><br></pre></td></tr></table></figure><p>설치가 완료되었으면 <code>webpack.config.js</code>에 <code>style-loader</code>와 <code>css-loader</code>를 정의하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">     &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">         <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>loader는 <code>module</code>에 추가해주며, 정규식(test)을 통해 loader가 인식될 파일을 잡아준다. 그리고 어떤(use) loader를 사용하는지 정의해 주면 된다. 이제 <code>style.css</code>파일을 추가하고 <code>index.js</code>파일을 수정하자.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* style.css */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hello</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">element.innerHTML = <span class="string">'Hello Webpack!!'</span>;</span><br><span class="line">element.classList.add(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(component());</span><br></pre></td></tr></table></figure><p>우선 추가된 코드는 <code>hello</code>클래스와 이 클래스를 element에 추가하는 코드이다. 코드는 어렵지 않다. 그런데 왜 <code>style.css</code>를 <code>index.html</code>에 <code>&lt;link&gt;</code> 태그나 <code>&lt;style&gt;</code>태그를 통해 삽입하지 않고 <code>index.js</code>에 삽입을 하였을까? 이유는 처음에 설명한 style-loader의 역할 때문이다. 이렇게 <code>index.js</code>에 <code>style.css</code>를 명시하고 이 <code>index.js</code>를 build하게 되면 <code>loader</code>를 통해 <code>style.css</code>의 클래스는 <code>&lt;script&gt;</code>태그로 CSS가 추가되도록 되어 있다.</p><p>위 코드를 build하여 실행하고 결과를 확인해 보도록 하자.</p><h2 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h2><p><code>file-loader</code>를 사용하면 시스템에 존재하는 파일. 즉 이미지나 폰트와 같은 자산들을 하나로 통합할 수 있다. 사용 방식은 위에서 설명한 css-loader와 style-loader와 동일하다. <code>file-loader</code>를 먼저 설치하고 <code>webpkac.config.js</code>를 열어 loader를 추가하자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">     &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpe?g|gif)$/</span>,</span><br><span class="line">        loader:<span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>여기서 loader를 보면 <code>css-loader</code>와 <code>style-loader</code>에서 사용한 <code>user:[]</code>가 사용되지 않고 <code>loader</code>로 사용되었다. 둘 다 적용이 가능한 옵션이며, <code>use:[]</code>경우 여러 <code>loader</code>를 지정할 때 사용되며 <code>loader</code>는 단일로 사용이 된다. 또한 각 <code>loader</code>는 각각의 특성에 따라 옵션을 지정할 있으며 아래와 같이 정의 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example...</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">     &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpe?g|gif)$/</span>,</span><br><span class="line">        loader:<span class="string">'file-loader'</span>,</span><br><span class="line">        option: &#123;</span><br><span class="line">        name: <span class="string">'[hash].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>이어서 가자. file-loader를 정의 하였으니 <code>Webpack_Project</code>안에 <code>asset</code>폴더를 하나 만들고 <code>image.png</code>파일과 같은 이미지 파일을 넣어놓자. 이렇게 넣어 놓은 이미지 파일을 <code>index.js</code>에서 불러 올 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./asset/image.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">element.innerHTML = <span class="string">'Hello Webpack!!'</span>;</span><br><span class="line">element.classList.add(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myIcon = <span class="keyword">new</span> Image();</span><br><span class="line">    myIcon.src = Icon;</span><br><span class="line"></span><br><span class="line">    element.appendChild(myIcon);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(component());</span><br></pre></td></tr></table></figure><p>이제 다시 build 하고 확인해 보자.</p><p>해당 예제는 이미지로 진행하였지만 폰트 역시 동일하다. 다른게 있다면 폰트의 확장자를 통해 걸러내는 정규식이 다를 뿐이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example...</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">     &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">        loader:<span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h2 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h2><p><code>file-loader</code>를 사용해 보았다면 한 번쯤 생각해 볼 것이다. 웹을 표한하는데 있어서 리소스를 가장 많이 잡아먹는 것 중 하나가 이 이미지 파일들인데 이 파일을 더 효율적으로 관리 할 수 없을지 말이다. webpack에서는 이 단계 이후에 진행될 논리적 단계는 <code>이미지를 축소하고 최적화하는 것이다.</code> 라고 말한다. <code>url-loader</code>는 이 이미지 로딩 프로세스를 향상 시킬 수 있는 하나의 방법이며, 특정 파일을 <code>base64</code>로 인코딩된 URL를 로드해주는 역할을 한다.</p><p><code>url-loader</code>를 설치하고 <code>webpack.config.js</code>를 열어 <code>url-loader</code>를 추가해 주자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">     &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpe?g|gif)$/</span>,</span><br><span class="line">        loader:<span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">              limit: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>url-loader</code>는 <code>file-loader</code>와 같이 작동한다. 그렇기에 정규식 역시 동일하지만 다른 점은 <code>limit</code>이라는 옵션을 준 것이다. <code>options</code>에 <code>limit</code>는 파일의 크기를 말하는데 현재 예제에서 10KB 미만은 <code>url-loader</code>로 처리가 되고 그 이상의 파일은 <code>file-loder</code>와 같이 처리가 된다.</p><p>다시 build를 하고 <code>dist</code>폴더를 확인해 보자. 해당 이미지 파일이 존재하지 않는 것을 확인할 수 있다. 만약 파일이 존재한다면 파일의 용량을 확인해 보고 그 용량 이상의 값을 <code>limit</code>에 적용해보다. 그리고 브라우저를 열어 실제로 파일이 <code>base64</code>로 인코딩이 되었는지 확인해 보자.</p><hr><p>지금까지 <code>Loader</code>를 알아 보았는데 여기서 언급한 <code>Loader</code>이외에도 <code>xml-loader</code>, <code>babel-loader</code>, <code>i18n-loader</code> 등과 같이 효율적인 <code>Loader</code>들이 무수히 존재한다. 해당 <code>Loader</code>들은 <a href="https://webpack.js.org/loaders/" target="_blank" rel="noopener">Webpack - Loader</a>에서 확인해 보자.</p><h1 id="Plug-In"><a href="#Plug-In" class="headerlink" title="Plug-In"></a>Plug-In</h1><p>webpack은 풍부한 Plug-In이 있으며 webpack 자체의 대부분의 기능은 이 Plug-In을 사용한다. Plug-In 을 통해 우리가 할 수 있는 일들은 build 된 bundle 파일을 동적으로 특정 html 페이지에 추가 할 수 있으며 build 시에 javscript, css, html 등의 파일을 난독화 및 압축을 진행할 수 있다. 이 외에도 많은 기능을 지원하며 필수 적으로 사용한다 해도 무방하다. 그럼 몇 가지 Plug-In을 살펴보겠다.</p><h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>엔트리 포인트 중 하나의 모듈의 이름을 변경하거나 새로운 것을 추가하는 경우 생성된 번들은 빌드에서 이름이 변경되지만 <code>index.html</code>에 script는 여전히 이전의 이름을 참조한다. 그렇게 때문에 우리는 주기적으로 번들링 된 파일을 <code>index.html</code>에 삽입을 시켜야하는 번거로움이 있다. 이런 불편함을 <code>html-webpack-plugin</code>이 해결해 준다. <code>html-webpack-plugin</code>은 정의되어있는 기본 template을 기준으로 번들링 시에 새로운 html 파일을 생성해 준다. 이때 파일을 생성할 때 번들링된 javascript 파일을 삽입해준다. </p><p><code>html-webpack-plugin</code>을 설치하고 <code>webpack.config.js</code>에 추가해 주자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            favicon: <span class="string">'./static/asset/favicon.ico'</span>,</span><br><span class="line">            template: <span class="string">'./static/index.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'css'</span>, <span class="string">'index'</span>, <span class="string">'app'</span>, <span class="string">'system'</span>, <span class="string">'monitor'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="commonChunk"><a href="#commonChunk" class="headerlink" title="commonChunk"></a>commonChunk</h2><p><code>commonChunk</code> Plug-In은 여러 개의 엔트리 포인트 사이에서 공유되는 공통 모듈로 구성된 파일(Chunk)을 별도의 엔트리로 분리함으로써 종속성을 관리 할 수 있다. 예를 들면 어떤 프로젝트에서 jquery를 사용하고 jquery를 필요로 하는 모든 모듈에 jquery를 참조한다고 했을 때 이후 build를 하게 되면 jquery 모듈이 중복되는데 이렇게 common하게 사용되는 모듈을 여러 모듈이 참조를 한다고 하더라도 <code>commonChunk</code>를 사용하여 build 시에 하나의 별도의 vendor 모듈로 분리 할 수 있다.</p><p><code>commonChunk</code>는 webpack의 내장 모듈이기 때문에 별도의 설치는 필요하지 않다. 대신에 webpack을 참조해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            favicon: <span class="string">'./static/asset/favicon.ico'</span>,</span><br><span class="line">            template: <span class="string">'./static/index.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'css'</span>, <span class="string">'index'</span>, <span class="string">'app'</span>, <span class="string">'system'</span>, <span class="string">'monitor'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">           name: <span class="string">'common'</span> </span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h2><p>우리는 <code>webpack.config.js</code>에 build 시 output을 통해 어디로 가는지 지정을 해줬다. <code>clean-webpack-plugin</code>은 이 output 디렉토리를 build를 할때마다 삭제를 해주는 Plug-In이다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>]),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            favicon: <span class="string">'./static/asset/favicon.ico'</span>,</span><br><span class="line">            template: <span class="string">'./static/index.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'css'</span>, <span class="string">'index'</span>, <span class="string">'app'</span>, <span class="string">'system'</span>, <span class="string">'monitor'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">           name: <span class="string">'common'</span> </span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="uglify"><a href="#uglify" class="headerlink" title="uglify"></a>uglify</h2><p>javascript 소스를 보게 되면 <code>xxx.min.js</code> 라는 파일과 그 안의 코드는 알아볼 수 없는 형태로 되어있는 것을 봤을 것이다. 이는 난독화와 압축을 진행했기 때문인데 javascript를 build 할 때 다른 중요한 부분은 난독화와 압축이다. 이 프로세스를 걸침으로 인해 내부 코드의 내용을 쉽게 파악하지 못하게 함과 파일의 용량을 줄일 수 있다. 압축하는 방법이야 여러 가지가 있지만 <code>uglify</code>는 간단하게 난독화와 압축을 진행할 수 있는 Plug-In이다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            favicon: <span class="string">'./static/asset/favicon.ico'</span>,</span><br><span class="line">            template: <span class="string">'./static/index.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'css'</span>, <span class="string">'index'</span>, <span class="string">'app'</span>, <span class="string">'system'</span>, <span class="string">'monitor'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">           name: <span class="string">'common'</span> </span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> UglifyWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h2><p><code>webpack.ProvidePlugin</code>을 통해 등록된 모듈을 자유 변수로 사용이 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            favicon: <span class="string">'./static/asset/favicon.ico'</span>,</span><br><span class="line">            template: <span class="string">'./static/index.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'css'</span>, <span class="string">'index'</span>, <span class="string">'app'</span>, <span class="string">'system'</span>, <span class="string">'monitor'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">           name: <span class="string">'common'</span> </span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> UglifyWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  $: <span class="string">'jquery'</span>,</span><br><span class="line">  jQuery: <span class="string">'jquery'</span>,</span><br><span class="line">  _:<span class="string">'underscore'</span></span><br><span class="line">&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modual A</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'&lt;div&gt;'</span>);</span><br><span class="line">jQuery(<span class="string">'&lt;div&gt;'</span>);</span><br><span class="line"><span class="keyword">var</span> array = _.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num * <span class="number">3</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><code>Loader</code>에 이어 <code>Plug-in</code>을 알아보았다. 이밖에 <code>Plug-in</code>은 <a href="https://webpack.js.org/plugins/" target="_blank" rel="noopener">WEbpack Plugin-IN</a>을 참고하자.</p><h1 id="DevServer-amp-amp-HMR"><a href="#DevServer-amp-amp-HMR" class="headerlink" title="DevServer &amp;&amp; HMR"></a>DevServer &amp;&amp; HMR</h1><p><code>DevServer</code>는 webpack의 주요 기능 중 하나이다. 실제로 우리는 자산들을 bundling 후에도 테스트가 필요하다. 또한 자산의 추가, 수정, 삭제에 따라 반영 작업이 필요한데 webpack의 DevServer를 이용한다면 매우 편리하게 개발에 임할 수 있다. DevServer는 말 그대로 개발 서버이며 이와 관련된 또 하나의 webpack 주요 기능인 <code>HMR(Hot Module Replacement)</code>가 있다. 이 <code>핫 모듈 교체(한국어 풀이)</code>는 특정 모듈이 변경되더라도 새로고침 할 필요없이 런타임에 모든 종류의 모듈을 업데이트해 주는 기능이다. 이 기능을 사용하기 위해서는 DevServer의 설정을 추가하고 webpack에 내장된 HMR 플러그 인을 사용하는 것 뿐이다. 그렇기에 DevServer와 같이 설명하려 한다. HMR의 자세한 내용은 <a href="https://webpack.js.org/guides/hot-module-replacement/" target="_blank" rel="noopener">webpack hmr</a>을 참고하자.</p><p>살을 덧붙여 요약을 하자면.</p><div class="alert success no-icon"><ul><li>webpack-dev-server는 빠른 실시간 리로드 기능을 갖춘 개발 서버</li><li>webpack-dev-serve는 디스크에 저장되지 않는 메모리 컴파일을 사용하기 때문에 컴파일 속도가 빨라짐</li><li>webpack.config.js에도 devServer 옵션을 통해 옵션을 지정하여 사용이 가능</li></ul></div><p><code>webpack-dev-server</code>의 간략한 프로세스는 이렇다.</p><div class="alert success no-icon"><ol><li>서버 실행 시 소스 파일들을 번들링하여 메모리에 저장</li><li>소스 파일을 감시하고 있다가 소스 파일이 변경되면 변경된 모듈만 새로 번들링</li><li>변경된 모듈 정보를 브라우저에 전송</li><li>브라우저는 변경을 인지하고 새로고침되어 변경사항이 반영된 페이지를 로드</li></ol></div><p>이제 <code>webpack-dev-server</code>를 설치하고 설정을 적용해보자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            favicon: <span class="string">'./static/asset/favicon.ico'</span>,</span><br><span class="line">            template: <span class="string">'./static/index.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'css'</span>, <span class="string">'index'</span>, <span class="string">'app'</span>, <span class="string">'system'</span>, <span class="string">'monitor'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">           name: <span class="string">'common'</span> </span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> UglifyWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  $: <span class="string">'jquery'</span>,</span><br><span class="line">  jQuery: <span class="string">'jquery'</span>,</span><br><span class="line">  _:<span class="string">'underscore'</span></span><br><span class="line">&#125;)</span><br><span class="line">    ],</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      host : <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">  compress: <span class="literal">true</span>,</span><br><span class="line">  hot : <span class="literal">true</span>,</span><br><span class="line">  inline: <span class="literal">true</span>,</span><br><span class="line">  port: <span class="number">9000</span>,</span><br><span class="line">  open : <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>devServer의 설정을 보면 감이 올 것으로 생각된다. 간단한 설명으로 넘어가겠다.</p><table><thead><tr><th>option</th><th>description</th><th>CLI 사용</th></tr></thead><tbody><tr><td>host</td><td>사용될 호스트 지정</td><td>webpack-dev-server –host 127.0.0.1</td></tr><tr><td>contentBase</td><td>콘텐츠를 제공할 경로지정(정적파일을 제공하려는 경우에만 필요)</td><td>webpack-dev-server –content-base /path/to/content/dir</td></tr><tr><td>compress</td><td>모든 항목에 대해 gzip압축 사용</td><td>webpack-dev-server –compress</td></tr><tr><td>hot</td><td>webpack의 HMR 기능 활성화</td><td>-</td></tr><tr><td>inline</td><td>inline 모드 활성화</td><td>webpack-dev-server –inline=true</td></tr><tr><td>port</td><td>접속 포트 설정</td><td>webpack-dev-server –port 9000</td></tr><tr><td>open</td><td>dev server 구동 후 브라우저 열기</td><td>webpack-dev-server –open</td></tr></tbody></table><p><code>webpack-dev-server</code>의 구동은 CLI로 실행을 하고 이 CLI를 npm script에 등록하여 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./node_modules/.bin/webpack-dev-server --config webpack.config.js</span><br></pre></td></tr></table></figure><p>open 옵션으로 인해 서버가 구동 후 브라우저가 열리는 것을 볼 수 있다. 여기서 F12를 통해 개발자 콘솔을 열고 모듈을 변경, 수정하면서 console 창을 확인해 보자. 당신은 지금 <code>HMR</code>이라는 훌륭한 기능을 보고 있는 것이다.</p><hr><p>여기까지 해서 webpack의 핵심적인 사용법을 알아보았다. webpack에 대한 디테일한 가이드는 <a href="https://webpack.js.org/guides/" target="_blank" rel="noopener">webpack guides</a>를 참고하면서 하나씩 따라 해보자. </p><p>webpack은 초기 설정이 까다롭게 느껴질 수 있다. 당연한 것이다. webpack 자체의 configulation과 Loader, plug-in 제각기 옵션이 존재하기 때문이다. 하지만 초기 설정만 끝난다면 webpack이 왜 떠오르고 많이 사용하는지 몸소 느낄 것이다. 현재 내가 진행하고 있는 프로젝트에도 webpack을 도입하기로 하였기에 Test하고 Prototype을 만들고 실제로 프로젝트에 적용해 보면서 매번 정말 훌륭하다고 느껴진다. Web Front-End의 Bundling tool을 고민하는 당신에게 적극적으로 추천한다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> build tool </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> javscript </tag>
            
            <tag> webpack </tag>
            
            <tag> build tool </tag>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 개념잡기</title>
      <link href="/2017/07/27/webpack/"/>
      <url>/2017/07/27/webpack/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p><code>Web front-end build tool</code>에는 여러 가지가 있다. 이러한 <code>build tool</code>은 단순히 소스를 묶고 컴파일하고 압축하는 단순한 형태에서 벗어나 하나의 기술로 자리잡혔다. 이 <code>build tool</code>들을 활용함으로써 우리가 진행하는 프로젝트에 엄청난 시너지를 안겨 줄 수 있다. 수많은 <code>build tool</code> 중 이 포스트에서는 <strong>떠오르는 build tool인 <code>webpack</code></strong>에 대한 소개와 프로젝트를 진행하면서 왜 <code>Build Tool</code>이 필요한지 포스팅하겠다.</p><h2 id="Build-Tools"><a href="#Build-Tools" class="headerlink" title="Build Tools"></a>Build Tools</h2><p><code>Build</code>는 서버 사이드에서만 사용하는 것이 아닌 <code>Web Front-End</code>에서도 필수이다. JavScript와 CSS를 축소하고 단위 테스트도 수행하며 프로젝트에 필요한 자산들(Image, Font)을 효율적으로 관리할 수 있을 뿐만 아니라 패키지화까지 진행할 수 있다. 이러한 사항들로 인해 결국 해당 프로젝트의 성능과 개발의 편의, 그리고 개발 속도가 향상될 수 있다. 물론 build를 실행하지 않고 직접적으로 시스템 파일을 <code>Linking</code>하여 사용할 수도 있겠지만 우리는 언제나 <code>Performance</code> 대립하게 되어있다. 그럼 이 <code>Front-End</code>의 <code>build tool</code>에는 어떤 것이 있을까?</p><blockquote><p>Jake<br>Brunch<br>Grunt<br>Gulp<br>Webpack<br>Brocolli<br>Cha</p></blockquote><p>너무 많다. 그냥 “이런 게 있구나..”라고 기억만 하자. </p><p>그럼 왜 저 많은 <code>build tool</code> 중에서 <code>Webpack</code>을 포스팅하는 것일까? 저 <code>build tool</code> 중 가장 많이 사용하는 tool은 <span class="highlight-text orange">Gulp</span>와 <span class="highlight-text orange">Grunt</span> 그리고 <span class="highlight-text danger">Webpack</span>이다. 이 세 가지를 비교해 볼 수는 없다. 셋 모두 훌륭한 시스템이다. 단지 <a href="https://npmcompare.com/compare/grunt,gulp" target="_blank" rel="noopener">NPMCOMPARE</a>에서 <code>Gulp</code>와 <code>Grunt</code>를 비교해 보았을 때 <code>Gulp</code>가 좀 더 활성화되어 있는 것을 볼 수 있다. 그렇다면 <code>Webpack</code>은??</p><h2 id="Webpack-VS-Gulp"><a href="#Webpack-VS-Gulp" class="headerlink" title="Webpack VS Gulp"></a>Webpack VS Gulp</h2><p>사실 <code>Webpack</code>와 <code>Gulp</code>은 다르게 볼 수 있다. <code>Webpack</code>은 <code>Package Bundler</code>이며, <code>Gulp</code>는 <code>Task Runner</code>이다. 크게 다르다고는 할 수 없지만, 이 이유가 <code>Webpack</code>을 포스팅하는 이유이다. 그럼 <code>Task Runner</code>와 <code>Package Bundler</code>는 무슨 차이일까.</p><div class="alert info no-icon"><p><strong>Package Bundler</strong> - 종속성을 가진 애플리케이션 모듈을 정적인 소스로 재생산<br><strong>Task Runner</strong> - 반복 가능한 특정 작업을 자동화</p></div><p>쉽게 말하면 <code>Task Runner</code>는 그저 미리 정의해 놓은 어떠한 작업을 실행하는 것이고 <code>Package Bundler</code>는 말 그대로 어떤 소스들을 하나의 패키지화 하는 것이다. </p><p>구글 트렌드를 통해 <code>Gulp</code>와 <code>Webpack</code>의 검색 추이를 보게 되면 처음에는 <code>Gulp</code>가 우세한 면을 보이지만 최근 들어 <code>Webpack</code>이 <code>Gulp</code>를 넘어서 더 우세한 것을 볼 수 있다. </p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1101_RC01/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"Webpack","geo":"","time":"today 5-y"},{"keyword":"Gulp","geo":"","time":"today 5-y"}],"category":31,"property":""}, {"exploreQuery":"cat=31&date=today 5-y&q=Webpack,Gulp","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><p>이는 프로젝트 규모와 그리고 <code>Task Runner</code>로는 진행할 수 없는 <code>Webpack</code>만의 중요한 종속성 관리에 따라 변화된 것으로 보인다. 이러한 종속성 관리는 프로젝트 규모가 클수록 더 빛을 발하며 그리고 날이 갈수록 <code>단일 웹 애플리케이션(SPA)</code>의 확산에 따라 중요한 자리를 차지하고 있다. 이 그래프에서 우리가 유추해 볼 수 있는 또 다른 하나는 <code>Webpack</code>과 <code>Gulp</code>의 교차 지점이다. 이 기간에서는 <code>Webpack</code>과 <code>Gulp</code>를 같이 사용했다고 볼 수 있다. 물론 지금도 그렇게 사용하는 개발자도 있다. <code>jsHint</code>나 <code>jsLint</code>등의 코드 검사 도구 또는 <code>mocha</code>나 <code>jasmine</code>과 같은 테스트 도구를 <code>Gulp</code>를 통해 실행하고 이 후 프로젝트의 패키징은 <code>Webpack</code>으로 사용하는 것처럼 말이다. 하지만 <code>Webpack</code>에서도 <code>Gulp</code>와 마찬가지로 전처리 작업을 지원하면서 <code>Webpack</code>이 더욱 상승세를 보인다. </p><p><code>Webpack</code>과 <code>Gulp</code>의 <a href="https://npmcompare.com/compare/gulp,webpack" target="_blank" rel="noopener">NPM COMPARE</a>를 보게 되면 <code>Gulp</code>가 종속된 모듈수가 적고 발생 이슈가 낮지만, 전체적인 면에서 보면 현재로서는 <code>Webpack</code>이 좀 더 활성화가 된 것을 볼 수 있다. 그럼 먼저 간단하게 <code>Webpack</code>와 <code>Gulp</code>의 특징을 알아보도록 하겠다.</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>위에서 말했듯이 <code>Webpack</code>은 JavaScript 애플리케이션을 위한 <code>Package Bundler</code>이고 목적은 종속성을 가진 애플리케이션 모듈을 정적인 소스들로 생산하는 것이다. 애플리케이션을 처리할 때 필요한 모든 모듈을 종속성 그래프로 반복적으로 작성한 다음 모든 모듈을 브라우저에서 로드 할 수 있는 하나의 Bundle로 패키지화한다. 이 외의 특징은 다음과 같다. </p><div class="alert info no-icon"><ul><li>Loader를 통해 Javascript, Image file, Font, CSS, SCSS 등과 같은 자산을 하나의 모듈로 취급</li><li>Entry 별로 Bundle 생성 가능</li><li>Bundle에 대한 압축 및 난독화, 소스 맵에 대한 옵션을 제공</li><li>Plug-In 사용을 통한 사용자 정의 기능 수행</li><li>비동기 I/O와 다중 캐시 레벨을 사용하기 때문에 컴파일 속도가 매우 빠름</li><li>CommonJS(nodejs)와 AMD(requires) 스펙 지원</li></ul></div><p><code>Webpack</code>은 크게 <code>Entry</code>, <code>Output</code>, <code>Loader</code>, <code>Plug-In</code> 이 4가지로 나눌 수 있다. </p><div class="alert danger no-icon"><p><strong>Entry</strong> - Webpack은 모든 애플리케이션에 대한 종속성 그래프를 작성하고 이 그래프의 시작점을 Entry Point라고 한다. 이 Entry Point를 통해 모듈이 어디서부터 시작하는지를 명세하는 애플리케이션을 시작하는 첫 번째 파일로 나타낼 수 있다.<br><strong>Output</strong> - Output은 모든 애플리케이션의 자산(resources 또는 assets)을 하나의 Bundle로 묶었으면 해당 Bundle을 처리하는 방법을 명세한다.<br><strong>Loader</strong> - Loader는 사전에 처리할 작업을 나타내며 css, html, jpg, scss 등의 자산을 하나의 모듈로 취급하며 이러한 파일들을 종속성 그래프에 추가할 때 모듈로 변환한다.<br><strong>Plug-In</strong> - Plug-In은 일반적인 Compile 또는 모듈 처리에 필요한 작업 및 사용자 정의 기능을 수행하는데 사용한다.</p></div><p><code>Webpack</code>의 장점은 이렇게 많지만 단점이라 하면 초기 구축에 대한 시간적인 비용이 많이 투자되며 Learning Curve가 길다는 점이다.</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p><code>Gulp</code>는 <code>Task Runner</code>이며, <code>Work Flow</code>를 자동화 및 향상할 수 있는 도구이다. 개발 <code>Work Flow</code>에서 번거로운 작업들이나 시간적인 소모가 많이 들어가는 작업을 자동화하여 쉽게 처리할 수 있다. <code>Gulp</code>의 특징을 보자.</p><div class="alert info no-icon"><ul><li>반복 가능한 작업을 자동화</li><li>JavaScript 테스트 실행 및 파일 병합</li><li>js, css, html등의 자산 파일을 압축</li><li>Node stream 기반으로 빠른 빌드 속도를 제공</li><li>작업을 정의하고 실행하는 것이 수월</li></ul></div><p><code>Gulp</code>는 <code>Webpack</code>에 비하여 <code>Learning Curve</code>가 낮기 때문에 사용하기 쉬운 편이며, 코드에 대한 가독성이 좋다. 대신 <code>Webpack</code>과 같이 모든 모듈에 대한 종속성 관리가 이루어지지 않기에 규모가 큰 프로젝트에서 패키지화하기가 쉽지 않다. 나도 <code>Gulp</code>를 사용하지만 개인 오픈 소스 프로젝트를 진행하는데에는 이만한 Tool도 없다.</p><hr><p>지금까지 우리는 <code>Webpack</code>과 <code>Gulp</code>를 알아 보았다. 전체적으로 본다면 <code>Build Tools</code>를 알아 본 것이다. 이번 포스팅에서는 <code>Webpack</code>이 기준이기 때문에 <code>Webpack</code>에 대해 좀 더 자세히 알아보았지만, 명심해야 할 것은 무조건 <code>Webpack</code>이 좋다는 것이 아니다. <code>Gulp</code>, <code>Grunt</code> 역시 훌륭한 <code>Build Tool</code>이다. 우리가 진행해야 할 프로젝트에 어떤 것이 더 효과적이고 필요한지를 되새김하고 그에 걸 맞는 <code>Build Tool</code>을 선정해야 할 것이다.</p><p>다음 포스팅에서는 실제로 <code>Webpack</code>을 어떻게 사용하지. <code>Webpack</code> 설치부터 응용까지 해 보기로 하자.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> build tool </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> javscript </tag>
            
            <tag> webpack </tag>
            
            <tag> build tool </tag>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</title>
      <link href="/2017/07/15/nodejs-npm-tutorial/"/>
      <url>/2017/07/15/nodejs-npm-tutorial/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p><code>node.js</code>와 <code>npm</code>은 웹 개발에 종사하고 있는 개발자라면 웬만해서는 알만큼 중요한 기술 중의 하나이다. 많이 들어보기도 했을 것이다. 이와 관련된 포스팅도 많고 정보도 많으니까. 그럼 <code>node.js</code>와 <code>npm</code>이 무엇인지 알아보고 설치를 진행해 보자.</p><h2 id="Node-js와-NPM-개념잡기"><a href="#Node-js와-NPM-개념잡기" class="headerlink" title="Node.js와 NPM 개념잡기"></a>Node.js와 NPM 개념잡기</h2><p><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js 공식 사이트</a>에서는 이렇게 정의하고있다.</p><div class="alert info no-icon"><p><strong>Node.js®는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다. Node.js는 이벤트 기반, Non 블로킹 I/O 모델을 사용해 가볍고 효율적입니다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.</strong></p></div><p><code>node.js</code>와 <code>npm</code>이 무엇인지 대강 알겠다.<br><code>node.js</code>는 JavaScript 기반으로 구성된 서버 사이드 서비스를 JavaScript로 구현할 수 있게 만든 런타임이고, <code>npm</code>은 <code>node.js</code> 기반의 모듈을 모아둔 집합 저장소이다. <code>npm</code>은 <code>Node Package Manager</code> 또는 <code>Node Package Modules</code>라고도 한다.</p><p><code>node.js</code>를 구글 트렌드에서 검색하게 되면 계속되는 상승곡선을 볼 수 있다.</p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1087_RC03/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"/m/0bbxf89","geo":"","time":"2004-01-01 2017-07-14"}],"category":0,"property":""}, {"exploreQuery":"date=2004-01-01 2017-07-14&q=%2Fm%2F0bbxf89","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><p>그리고 전 세계에서 사용 중인 것을 확인할 수 있다. </p><script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/1087_RC03/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("GEO_MAP", {"comparisonItem":[{"keyword":"/m/0bbxf89","geo":"","time":"2004-01-01 2017-07-14"}],"category":0,"property":""}, {"exploreQuery":"date=2004-01-01 2017-07-14&q=%2Fm%2F0bbxf89","guestPath":"https://trends.google.co.kr:443/trends/embed/"}); </script><p>그만큼 오늘날 <code>node.js</code>는 개발에 있어서 중요한 한 부분을 차지하고 있다는 것이다. 그럼 <code>node.js</code>를 사용해서 우린 무엇을 할 수 있을까?</p><p>다음은 <code>node.js</code>로 할 수 있는 것들이다. 꼭 여기에 국한되지는 않지만 <code>node.js</code>가 가장 빛을 발하는 곳은 실시간 웹 애플리케이션이다. 이유는 <a href="https://nodejs.org/en/about/" target="_blank" rel="noopener">About Node.js</a> <code>node.js</code> 정보에 잘 나와 있다. 설명하자면 <code>node.js</code>는 <strong>lock</strong>이 없으므로 프로세스를 <strong>dead-locking</strong> 할 걱정이 없고 I/O를 직접 수행하지 않으므로 프로세스가 절대 차단되지 않기 때문이다. <strong>non Block</strong>이기에 확장 가능한 시스템은 노드에서 개발하는 것이 합리적이다.</p><blockquote><ul><li>정적 파일 서버</li><li>웹 응용프로그램</li><li>메시징 미들웨어</li><li>HTML5 멀티 플레이어 게임용 서버</li></ul></blockquote><p><code>npm</code>은 훌륭한 개발자들이 Node.js 기반의 JavaScript로 개발된 오픈 소스를 모듈로 올려놓은 곳이다. 우리는 웹 개발에 필요한 jQuery, gulp, webpack 등의 모듈들을 <code>npm</code>명령어를 통해 쉽게 다운받고 쓸 수가 있다.</p><h2 id="Node-js와-NPM-설치하기"><a href="#Node-js와-NPM-설치하기" class="headerlink" title="Node.js와 NPM 설치하기"></a>Node.js와 NPM 설치하기</h2><p><code>node.js</code>와 <code>npm</code> 설치는 간단하다. <code>npm</code>의 경우는 <code>Node Package Manager</code>이기 때문에 <code>node.js</code>를 설치하면 같이 설치된다. 먼저 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>에서 안정적인 V6.x.x를 다운받은 후 원클리으로 설치하면 된다.</p><p>설치가 완료되었다면 확인해보자. 명령 프롬프트를 실행하여 아래 명령어를 쳐보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure><p>정상적으로 다운로드 받고 설치한 버전 정보가 출력된다면 설치는 완료된 것이다. 물론 <code>npm</code>도 설치가 되었겠지만 그래도 확인은 해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p>이것으로 설치는 완료되었다. 별도의 Path도 잡을 필요 없고 원클릭으로 <code>node.js</code>와 <code>npm</code>을 설치할 수 있다.</p><h2 id="Node-js-테스트해보기"><a href="#Node-js-테스트해보기" class="headerlink" title="Node.js 테스트해보기"></a>Node.js 테스트해보기</h2><p><code>node.js</code>를 설치하였으니 한번 실행해보자. 명령 프롬프트를 열어 <code>node</code>명령어를 실행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br></pre></td></tr></table></figure><p>이제 우리는 명령 프롬프트에 JavaScript 코드를 입력하여 실행할 수 있다. 아래 코드를 <code>Enter</code>와 함께 입력해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;  <span class="comment">//enter</span></span><br><span class="line">a           <span class="comment">//enter  //print `1`</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;  <span class="comment">//enter</span></span><br><span class="line">b           <span class="comment">//enter  //print `2`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sum = '</span> + a + b);  <span class="comment">//enter  //print 'sum = 3'</span></span><br></pre></td></tr></table></figure><p>명령 프롬프트에서 이렇게 JavaScript 코드를 입력할 수도 있지만 이렇게 개발할 수는 없다. JavaScript 파일을 만들고 해당 파일을 실행해보자. 먼저 정당한 곳에 <code>NodeTest</code>폴더 하나를 만들고 그 폴더 안에 <code>main.js</code>파일을 만들자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mian.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sum = '</span> + sum(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><code>main.js</code>파일을 만들었으면 <code>NodeTest</code>경로로 이동하자. 명령 프롬프트로 이동해도 되고 아니면 <code>NodeTest</code>폴더에서 <code>Shift + 마우스 우클릭</code>을 통해 <code>여기서 명령 창 열기</code>를 통해 명령 프롬프트를 실행할 수 있다.</p><p>어쨌든 명령 창을 실행하였으면 <code>main.js</code>를 실행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br></pre></td></tr></table></figure><p>결과를 확인하였는가? 이처럼 미리 생성된 JavaScript 파일을 우리는 <code>node</code>명령어를 통해 실행할 수가 있다.</p><h2 id="NPM-테스트해보기"><a href="#NPM-테스트해보기" class="headerlink" title="NPM 테스트해보기."></a>NPM 테스트해보기.</h2><p>이제 <code>npm</code>을 테스트해보자. <code>npm</code>을 통해 특정 모듈을 다운받고 그 모듈을 통해 어떤 작업을 수행할 것이다. 먼저 <code>NodeTest</code>폴더로 이동하여 명령 프롬프트를 실행 후 명령어를 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure><p><code>npm init</code>명령어를 입력하면 <code>package.json</code>파일이 생성된 것을 볼 수 있다. 진행하기에 앞서 먼저 <code>package.json</code>을 보고 가자.</p><hr><h3 id="Package-json"><a href="#Package-json" class="headerlink" title="Package.json"></a>Package.json</h3><p>우리가 만든 <code>package.json</code>을 열어보자.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"NodeTest"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>뭔가 보니까 감이 오는가?<br><code>package.json</code>은 프로젝트에 대한 명세라고 할 수 있다. 해당 프로젝트의 이름, 버전, 사용되는 모듈 등의 스펙이 정해져 있으며, 이 <code>package.json</code>을 통해 모듈 의존성 모듈 관리도 진행할 수 있다. 만약 어떤 오픈 소스를 다운 받을 때 이 <code>package.json</code>만 있다면 해당 오픈 소스가 의존하고 있는 모듈이 어떤 것인지. 그리고 그 모듈들을 아래 명령어로 한 번에 설치할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><hr><p>이어서 가자.</p><p>여기까지 해서 <code>package.json</code>이 생성되었으니 <code>npm</code>을 통해 모듈을 설치해보자. 모듈은 <code>mocha</code>라는 Front-End 단위 테스트(TDD) 프레임워크를 설치해보겠다. <code>mocha</code>와 관련된 포스트는 <a href="https://kdydesign.github.io/2017/06/08/Mocha/">JavaScript 단위 테스트 프레임워크 - Mocha</a>를 참고하도록하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mocha --save-dev</span><br></pre></td></tr></table></figure><p>해당 명령어를 통해 mocha를 설치해만 <code>NodeTest</code>폴더 안에는 <code>node_modules</code>폴더가 생성되고 그 안에는 <code>mocha</code>모듈이 설치된 것을 확인할 수 있다. 그리고 다시 <code>package.json</code>을 열어보면 <code>devDependencies</code>에 <code>mocha</code>가 추가된 것을 볼 수 있다. 이는 <code>mocha</code>를 설치할 때 <code>--save-dev</code>옵션을 추었기에 추가가 된 것이다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">"devDependencies": &#123;</span><br><span class="line">    "mocha": "^3.4.2"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>이렇게 설치한 <code>npm</code>모듈은 해당 프로젝트에서 사용할 수 있는 흔히 말하는 지역변수와 같은 개념이 되는 것이다. 그럼 지역변수가 있으니 전역으로 사용할 수 있는 모듈도 있지 않을까?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mocha -g</span><br></pre></td></tr></table></figure><p>전역으로 설치하기 위해서는 <code>-g</code>옵션을 추가해주면 된다. 이렇게 전역으로 설치된 모듈은 <code>C:\Users\사용자명\AppData\Roaming\npm</code>경로에 설치가 된다. (폴더가 없다면 숨김포더를 해제하라.) 이렇게 전역으로 설치한 모듈을 해당 프로젝트에서 <code>심볼릭 링크</code>로도 사용이 가능하다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm link mocha</span><br></pre></td></tr></table></figure><p><code>npm</code>을 통해 설치된 모듈의 목록 역시 확인할 수 있다. 아래 명령어를 하나씩 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm list </span><br><span class="line">$ npm list -g</span><br><span class="line">$ npm ls    </span><br><span class="line">$ npm ls -depth=0</span><br></pre></td></tr></table></figure><p>자세한 <code>npm</code>명령어 또는 옵션은 <a href="https://docs.npmjs.com/" target="_blank" rel="noopener">NPM DOCUMENT</a>를 참고하자.</p><hr><p><code>node.js</code>와 <code>npm</code>으로 인해 개발은 더욱 편리해지고 있다. 또한 나로써는 <code>node.js</code>가 JavaScript 기반이라는 것이 너무나 좋다. JavaScript를 알고 있으니까.. 오래전에 JavaScript로 서버를 구축한다는 생각이나 했었을까.. 페이스북에서는 VR 개발용 JavasScript 프레임워크도 공개하기도 하였다. JavaScript의 범용성은 어디까지 일까.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> nodejs </tag>
            
            <tag> javscript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo와 Github page로 만든 블로그에 Hexo 테마 적용하기</title>
      <link href="/2017/07/07/hexo-theme/"/>
      <url>/2017/07/07/hexo-theme/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p><code>hexo</code>와 <code>github page</code>를 이용하여 만든 블로그에 아름다움을 입혀보자. <code>hexo</code>는 <code>jeykyll</code>과 마찬가지로 블로그에 테마를 입힐 수 있다. <code>hexo</code>와 <code>github page</code>에 테마를 입히는 데 어려움은 없지만 테마가 개발자 개개인이 오픈소스로 만들어 제공하기 때문에 테마마다 사용이나 설정법이 약간 다를 수 있다. </p><p><code>hexo</code>와 <code>github page</code>에 테마를 입히는 것이 <code>hexo</code>와 <code>github page</code>를 사용하여 블로그를 구축하는 것보다 어려울 수 있다. 일단 <strong>Document가 한글이 아니기 때문</strong>인데 먼저 이 포스트에서 하나의 테마를 잡아 적용을 해보고 원하는 테마를 골라서 별도로 적용해보자. </p><hr><h2 id="Hexo-테마-선택하기"><a href="#Hexo-테마-선택하기" class="headerlink" title="Hexo 테마 선택하기"></a>Hexo 테마 선택하기</h2><p>먼저 테마가 어떤 것들이 있는지 살펴보자.<br><a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">Hexo Theme</a>에서 개발자들이 <code>hexo</code>를 사용하여 만든 테마 목록을 확인하고 다운받을 수 있다. 물론 우리도 <code>hexo</code> 테마를 제작할 수 있다. 당연히 <span class="highlight-text orange">시간</span>과 <span class="highlight-text danger">노오오오오오오력</span>이 바탕이 되어야 한다.</p><p>대충 둘러보면 알겠지만 그저 그런 테마들이 아니다. 모두 개인의 <code>Identity</code>가 들어가 있는 디자인뿐만 아니라 더 나아가 <code>반응형 디자인</code>으로 제작되어 있다. 이 <code>반응형 디자인</code>으로 인해 우리는 하나의 페이지를 모바일에서 볼 때와 PC 브라우저에서 볼 때 모두 다른 형태의 UI, UX로 보이는 것이다. 훌륭하다. 우린 그저 가져다 쓰기만 하면 된다.</p><p>이 훌륭한 테마 중 우리는 <a href="http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/" target="_blank" rel="noopener">Clean Blog</a>를 선택하고 적용해 보자. 이 <a href="http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/" target="_blank" rel="noopener">Clean Blog</a>는 매우 깔끔한 디자인을 가지고 있고 <code>jekyll</code>에서도 지원하는 블로그 테마이다.</p><p><img src="https://github.com/kdydesign/kdydesign.github.io/blob/master/2017/07/07/hexo-themes/thumb02.png?raw=true" alt="thumb02"></p><h2 id="Hexo-테마-설치하기"><a href="#Hexo-테마-설치하기" class="headerlink" title="Hexo 테마 설치하기"></a>Hexo 테마 설치하기</h2><p>처음에 말했듯이 테마들은 모두 오픈소스로 되어있다. 그리고 그 오픈소스들은 <code>github</code>에 올려져 있다. 우리는 <a href="https://kdydesign.github.io/2017/06/23/start-hexo-blog/">Hexo와 Github Page로 시작하는 블로그 만들기</a>에서 블로그를 구축하며 대충 배워 본 <code>git</code>과 <code>github</code>사용 방법을 통해 테마 역시 <code>github</code>에서 <code>git</code>을 통해 다운 받을 것이다.</p><p><a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank" rel="noopener">Clean Blog Github</a>에 가보면 <code>Clean Blog</code>를 적용하는데 필요한 프로젝와 적용 방법과 기타 기능들에 대한 설명이 나와있다. 여기만 잘 읽고 따라하면 문제없이 적용된다. 물론 영어지만.</p><p>이전에 <a href="https://kdydesign.github.io/2017/06/23/start-hexo-blog/">Hexo와 Github Page로 시작하는 블로그 만들기</a> 포스팅에서 만들어 놓은 폴더 경로로 이동하자. 해당 폴더에 가면 <code>themes</code>라는 폴더가 존재할 것이다. 이 <code>themes</code> 경로로 가보면 처음에 <code>hexo</code> 블로그를 만들 때 기본으로 적용되는 <code>landscape</code>테마가 있다. <code>themes</code>경로에는 여러 개의 테마 폴더가 존재해도 상관없다 <code>hexo</code>에서 설정된 단 하나의 테마만 적용된다. 그리고 <code>themes</code> 경로에서 <code>마우스 우클릭</code>을 눌러 <code>Git Bash Here</code>메뉴를 클릭하자. 이후에 실행되는 <code>git bash</code>창에 명령어를 입력하여 <code>github</code>에 있는 소스를 다운받자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/klugjo/hexo-theme-clean-blog.git</span><br></pre></td></tr></table></figure><p>또는 <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank" rel="noopener">Clean Blog Github</a>에서 우측 상단에 <code>Clone or download</code>버튼을 통해 zip 압축파일로 다운받을 수 있다.</p><p><img src="thumb01.png" alt="thumb01"></p><p>다운을 받게 되면 <code>themes</code>경로 안에 <code>hexo-theme-clean-blog</code>라는 폴더가 생성되었을 것이다. 이 폴더명을 <code>clean-blog</code>로 변경해 주자.</p><h3 id="테마-소스-구조-살펴보기"><a href="#테마-소스-구조-살펴보기" class="headerlink" title="테마 소스 구조 살펴보기"></a>테마 소스 구조 살펴보기</h3><p>잠깐 테마의 소스들이 어떻게 구성되어있는지 보자. </p><table><thead><tr><th>File</th><th>Description</th></tr></thead><tbody><tr><td>layout</td><td>blog를 구성하는 파일</td></tr><tr><td>source</td><td>blog 구성에 필요한 리소스 파일</td></tr><tr><td>_config.yml</td><td>해당 테마의 설정 파일</td></tr></tbody></table><p>대표적인 파일을 보게 되면 <code>layout</code>, <code>source</code>, <code>_config.yml</code>이다. 이 세 개의 파일들은 대부분의 테마들이 가지고 있으며 <code>_config.yml</code>의 경우는 필수이다. <code>hexo</code>블로그를 구성하는 설정파일 역시 <code>_config.yml</code>파일이다. <strong>두 파일을 혼동해서는 안된다.</strong></p><h2 id="테마-설정하기"><a href="#테마-설정하기" class="headerlink" title="테마 설정하기"></a>테마 설정하기</h2><p>우리는 <code>themes/clean-blog</code>경로에 있는 <code>_config.yml</code>을 수정하여 메뉴, 블로그 타이틀 등 블로그를 구성하는 내용들을 변경할 수 있다. <code>_config.yml</code>을 열어 원하는 내용대로 수정하자. 설정 파일의 내용은 아래 주석을 보자.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Header</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> <span class="string">/</span>                               <span class="comment">#메인 페이지 경로 </span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives</span>                   <span class="comment">#Archives 메뉴 경로</span></span><br><span class="line"><span class="attr">  Tags:</span> <span class="string">/tags</span>                           <span class="comment">#tags 메뉴 경로</span></span><br><span class="line"><span class="attr">  Categories:</span> <span class="string">/categories</span>               <span class="comment">#categories 메뉴 경로</span></span><br><span class="line"><span class="attr">  Github:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">https://github.com/klugjo/hexo-theme-clean-blog</span>             <span class="comment">#사용자 github url                      </span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">github</span>               <span class="comment">#github icon</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Title on top left of menu. Leave empty to use main blog title</span></span><br><span class="line"><span class="attr">menu_title:</span> <span class="string">Configurable</span> <span class="string">Title</span>          <span class="comment">#좌측 상단 메뉴 타이틀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL of the Home page image</span></span><br><span class="line"><span class="attr">index_cover:</span> <span class="attr">http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg</span>       <span class="comment">#커버 이미지 경로</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default post title</span></span><br><span class="line"><span class="attr">default_post_title:</span> <span class="string">Untitled</span>             <span class="comment">#포스트 생성 시 기본 타이틀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Comments. Choose one by filling up the information</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Disqus comments</span></span><br><span class="line"><span class="attr">  disqus_shortname:</span></span><br><span class="line">  <span class="comment"># Facebook comments</span></span><br><span class="line"><span class="attr">  facebook:</span></span><br><span class="line"><span class="attr">    appid:</span>                <span class="comment">#사용자 facebook app id</span></span><br><span class="line"><span class="attr">    comment_count:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">    comment_colorscheme:</span> <span class="string">light</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics Tracking ID</span></span><br><span class="line"><span class="attr">google_analytics:</span>         <span class="comment">#사용자 google analytics id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Addthis ID</span></span><br><span class="line"><span class="attr">addthis:</span>                  <span class="comment">#사용자 addthis id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set your own favicon</span></span><br><span class="line"><span class="attr">favicon:</span>                  <span class="comment">#브라우저 탭에 표시된 favicon 이미지 경로</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Accounts</span></span><br><span class="line"><span class="attr">twitter_url:</span>              <span class="comment">#사용자 twitter url</span></span><br><span class="line"><span class="attr">twitter_handle:</span></span><br><span class="line"><span class="attr">facebook_url:</span>             <span class="comment">#사용자 facebook url</span></span><br><span class="line"><span class="attr">github_url:</span> <span class="attr">https://github.com/klugjo/hexo-theme-clean-blog</span>         <span class="comment">#사용자 github url</span></span><br><span class="line"><span class="attr">gitlab_url:</span>               <span class="comment">#사용자 gitlab url</span></span><br><span class="line"><span class="attr">linkedin_url:</span>             <span class="comment">#사용자 linkin url</span></span><br><span class="line"><span class="attr">mailto:</span>                   <span class="comment">#사용자 메일</span></span><br></pre></td></tr></table></figure><p>여기까지가 <code>hexo clean-blog</code>에 대한 설정이고 이제 <code>hexo</code>블로그 자체의 설정을 변경해 보자.<br>블로그가 존재하는 최상위 폴더로 이동해서 <code>hexo</code>블로그의 설정 파일인 <code>_config.yml</code>을 열어 수정하자.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">title</span>                   <span class="comment">#블로그 메인 타이틀 입력</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">subtitle</span>             <span class="comment">#블로그 서브 타이틀 입력</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">description</span>       <span class="comment">#블로그 설명 </span></span><br><span class="line"><span class="attr">author:</span> <span class="string">author</span>                 <span class="comment">#블로그 관리자 이름</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span>                   <span class="comment">#블로그 언어(한국어 지원은 없으므로 en인 영어로 하자.)</span></span><br><span class="line"><span class="attr">timezone:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://[계정이름].github.io</span></span><br></pre></td></tr></table></figure><p><code>_config.yml</code>이 <code>hexo</code> 기본 구조와 <code>themes</code>에 동일하게 포함되어 있어서 혼동할 수 있다. 정리를 해보면..</p><div class="alert danger no-icon"><ul><li><strong>블로그 폴더 경로의 _config.yml</strong> - hexo 블로그 전반적인 설정</li><li><strong>themes/테마 폴더 경로의 _config.yml</strong> - hexo 블로그에 적용된 테마의 설정</li></ul></div><h2 id="Tags-페이지-만들기"><a href="#Tags-페이지-만들기" class="headerlink" title="Tags 페이지 만들기"></a>Tags 페이지 만들기</h2><p><code>Tags</code>페이지를 만들어 <code>tag</code>들을 관리하자. <code>tags</code>페이지는 <code>post</code>를 작성할 때와 비슷한 명령어를 사용한다. 우리는 페이지를 만들 것이기 때문에 <code>post</code>가 아닌 <code>page</code>를 사용하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"tags"</span></span><br></pre></td></tr></table></figure><p><code>page</code>를 생성하게 되면 <code>source</code>경로에 <code>tags</code>라는 폴더가 생기고 <code>index.md</code>라는 <code>markdown</code>파일이 생성된다. 이 <code>index.md</code>파일을 열어 아래와 같이 수정하고 저장하다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">All</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="Catetories-페이지-만들기"><a href="#Catetories-페이지-만들기" class="headerlink" title="Catetories 페이지 만들기"></a>Catetories 페이지 만들기</h2><p><code>Categories</code>페이지도 <code>Tags</code>페이지와 동일하게 만들면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"categories"</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">All</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"categories"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="Post-쓰기"><a href="#Post-쓰기" class="headerlink" title="Post 쓰기"></a>Post 쓰기</h2><p>이제 어느 정도 테마의 설정이 끝났다. 이제 실제로 포스트를 써보도록 하자.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">hexo</span> <span class="string">new</span> <span class="string">post</span> <span class="string">"post-clean-blog"</span></span><br></pre></td></tr></table></figure><p><code>post</code>파일을 생성하고 수정하자.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">"Clean-blog 테마를 적용하다."</span>           <span class="comment">#post 제목</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-07</span><span class="bullet">-07</span> <span class="number">00</span><span class="string">:23:23</span>                     <span class="comment">#post 생성 날짜</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">["hexo",</span> <span class="string">"clean-blog"</span><span class="string">,</span> <span class="string">"theme"</span><span class="string">]</span>         <span class="comment">#tags</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/assets/contact-bg.jpg</span>                 <span class="comment">#post 커버 이미지</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">"처음으로 테마를 적용해보다."</span>         <span class="comment">#post 부제</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p><code>post</code>를 작성하는 <code>md</code>파일에서 상단에 들어가는 <code>post</code>와 관련된 설정값들이다. 적당하게 입력하도록 한다.</p><h2 id="테마-적용하기"><a href="#테마-적용하기" class="headerlink" title="테마 적용하기"></a>테마 적용하기</h2><p><code>hexo</code>테마인 <code>clean-blog</code>를 다운받았으면 이제 실제로 <code>hexo</code>블로그에서 이 테마를 사용하겠다는 언급을 해줘야 한다. 블로그 최상위 폴더로 이동하여 <code>_config.yml</code>파일을 열어 아래처럼 수정하자.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">clean-blog</span></span><br></pre></td></tr></table></figure><p>그다음 <code>hexo</code> 명령어를 통해 다시 <code>markup</code>으로 변환하고 로컬에서 확인해 보자. <code>hexo server</code>포트는 4000번이므로 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>으로 접속하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><hr><p><code>hexo</code>가 <code>jekyll</code>보다는 많은 테마를 제공하지는 않지만 그래도 나름대로의 깔끔한 테마들이 넘치기에 테마를 적용하는 데는 문제가 없다. 다만 그 테마를 적용하기 위해서는 테마의 설정 파일은 <code>_config.yml</code>을 다룰 줄 알아야 하고 그 테마의 Document를 봐야한다. 물론 영어라 파악하기가 쉽지만은 않겠지만(난 그렇다.ㅠㅠ) 내가 원하는 테마를 처음에 구축해 놓으면 그 이후부터 포스팅은 <code>복붙</code>이기에 어렵지 않게 느낄 것이다.</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> hexo </category>
          
          <category> github </category>
          
          <category> theme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> 블로그 </tag>
            
            <tag> hexo theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo와 Github page로 시작하는 블로그 만들기</title>
      <link href="/2017/06/23/hexo-blog/"/>
      <url>/2017/06/23/hexo-blog/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>블로그를 호스팅해주는 포털 사이트는 많지만 이번 포스팅에서는 <strong>hexo</strong>와 <strong>github page</strong>를 이용하여 블로그를 만드는 방법을 적어보겠다. <code>github page</code>는 <code>Jekyll</code>과 많이 사용되지만 hexo가 <code>Jekyll</code>보다 더욱 쉽고 빠르게 블로그를 만들 수 있다.</p><p>자세한 설명은 건너뛰고  <strong><code>Hexo와 Github io로 시작하는 블로그 만들기</code></strong>  바로 시작하자.</p><h2 id="Git과-Github"><a href="#Git과-Github" class="headerlink" title="Git과 Github"></a>Git과 Github</h2><p>개발자들이라면 <code>github</code>가 무엇인지는 알 것이다. (몰라도 상관없다.) 이 <code>github</code>에 대해 주야장천 떠들기만 하면 이 포스트의 목적을 이룰 수 없다. 그리고 이 포스트는 <strong>일반인이 보고 따라하는 것도 목적이 있기에</strong> 간단하게 설명하고 바로 시작한다.</p><p>먼저 <code>git</code>을 대충 설명하면 <code>버전 관리 도구</code>이다. <code>subversion</code> 같은 거.. (아.. 뭔가 점점 깊게 설명하게 될 것 같은..) 그냥 이 포스트에서는 이렇게 이해하자.</p><div class="alert info"><p><strong>git</strong> - 내 포스트를 웹에 올리기 위해 필요한 도구</p></div><p><code>hexo</code>와 <code>github page</code>를 통해 만드는 블로그는 일반 블로그처럼 웹에서 직접 작성하지 않는다. 내 컴퓨터에서 먼저 글을 쓰고 그걸 웹으로 보내서 브라우저에서 볼 수 있도록 하는 것이다.</p><p>그럼 <code>github</code>와 <code>github page</code>는 무엇인가?</p><div class="alert info"><p><strong>github</strong> - 내 포스트를 웹에 저장하는 저장 공간<br><strong>github page</strong> - 저장된 내 포스트를 브라우저에 출력하는 페이지</p></div><p><code>github</code>는 어떤 저장소라 생각하자. 그리고 <code>github page</code>는 저장소에 올린 글을 브라우저에서 보여주는 페이지라고 생각하면 된다. (실제 정의와 차이가 있다.)</p><h3 id="Git-설치"><a href="#Git-설치" class="headerlink" title="Git 설치"></a>Git 설치</h3><p><strong>내 포스트를 웹에 올리기 위해</strong> <code>git</code>을 설치하자.<br><a href="https://git-scm.com/" target="_blank" rel="noopener">Git 공식 사이트</a>에 접속해서 우측에 Download를 진행한 후 그저 Next를 통해 빠르게 설치한다. <code>git</code>이 설치가 잘 되었다면 바탕화면에서 <code>마우스 우클릭</code>을 눌러보자. <code>Git GUI Here</code>과 <code>Git Bash Here</code>라는 Context가 생겼을 것이다. <code>Git Bash Here</code>을 눌러 Bash를 실행한 후에 아래처럼 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure><p>버전이 출력되는 것이 보이는가? 그럼 설치가 끝난 것이다.</p><h3 id="Github-가입-및-생성"><a href="#Github-가입-및-생성" class="headerlink" title="Github 가입 및 생성"></a>Github 가입 및 생성</h3><p><strong>내 포스트를 웹에 저장하기 위해</strong> <code>github</code>에 가입하고 저장소를 생성하자.<br>설치는 필요 없고 웹에서 가입하고 저장소를 만들 수 있다. <a href="https://github.com/" target="_blank" rel="noopener">Github 공식 사이트</a> 에 접속하여 적당하게 회원가입을 한다. 그리고 로그인을 하게 되면 <code>New Repository</code>가 보일 것이다. 클릭하자.</p><p><img src="thumb01.png" alt="thumb01"></p><p><code>New Repository</code>를 누르면 저장소를 생성하는 화면이 나온다. 여기서 <code>Repository Name</code>와 <code>Description</code>을 적어주는데 <code>Repository Name</code>은 아래와 같은 형식으로 적어준다.</p><div class="alert danger no-icon"><p>Repository Name - <strong>계정이름.github.io</strong></p></div><p>위와 같이 생성하면 블로그를 접속할 도메인은 <strong><code>https://계정이름.github.io</code></strong>이 될 것이다. 왜 이렇게 생성해야하는 이유는 넘어가도록하겠지만 추후에 도메인 이름을 변경하는 방법을 포스팅하겠다.</p><h2 id="Git-설정"><a href="#Git-설정" class="headerlink" title="Git 설정"></a>Git 설정</h2><p><code>git</code>을 설치 후 최초에 한번 기본 설정을 진행하면 된다. 설정은 <code>이름</code>과 <code>email</code>을 등록하는 것이다. <code>github</code>를 가입하고 <code>git</code> 설정을 넣은 이유는 설정 시에 복잡하게 생각할 것 없이 <code>github</code>로 생성한 아이디나 이메일로 등록하자라는 취지에서 순서를 좀 섞었다. <code>git</code>설치 시에 열었던 <code>git bash</code>창을 다시 열어 설정을 진행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name 사용자 명</span><br><span class="line">$ git config --global user.email 사용자 이메일</span><br></pre></td></tr></table></figure><h2 id="Node-js와-NPM-설치"><a href="#Node-js와-NPM-설치" class="headerlink" title="Node.js와 NPM 설치"></a>Node.js와 NPM 설치</h2><p>여기까지 해서 블로그를 저장할 공간과 그 공간에 업로드할 수 있는 도구까지 설치하였다. 이제 우리가 할 일은 저장될 블로그를 만드는 것이다. 블로그는 이 포스트의 타이틀 대로 <code>hexo</code>를 이용하여 블로그를 만들 것이다. <code>hexo</code>를 사용하기 위해서는 먼저 <code>node.js</code>를 설치하여야 한다. <a href="https://nodejs.org/ko/" target="_blank" rel="noopener">Node.js 공식 사이트</a>에서 <code>6.x</code> 버전을 다운받은 후 설치하도록 하자.</p><p>설치가 완료되었으면 Command( <em>window 키 + R 후에 cmd 입력</em>)창에 명령어를 입력해 보자. <code>node.js</code>와 <code>npm</code>에 대해서는 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a>를 참고하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p>위 두 명령어를 입력하여 정상적으로 version이 출력된다면 설치가 완료된 것이다. </p><p><code>node.js</code>는 javascript 런타임으로 생각하고 <code>npm</code>은 <code>node.js</code>의 오픈 소스 모듈들의 집합 저장소라고 생각하자. 우리는 이 <strong>npm을 통해 hexo를 설치</strong>할 것이다.</p><h2 id="Hexo-설치"><a href="#Hexo-설치" class="headerlink" title="Hexo 설치"></a>Hexo 설치</h2><p>이제 hexo를 설치하자. 위에서 <code>npm</code>을 통해 hexo를 설치한다고 하였다. 그대로 실행해 보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>명령어 <code>npm</code>을 통해 <code>hexo-cli</code> 모듈을 <code>global</code>하게 설치한다는 명령어이다. 우리는 이 <code>Hexo</code>를 통해 여러 가지를 진행할 것이다.</p><div class="alert success no-icon"><ol><li>기본 블로그 구조 생성</li><li>새로운 포스트 생성</li><li>github page에 올리기 위해 markdown을 html로 변환</li><li>local(내 컴퓨터)에서 실행 테스트</li><li>github에 업로드</li></ol></div><hr><p>여기까지 해서 필요한 프로그램들을 모두 설치를 완료하였다. 이제 블로그를 만들고 포스팅을 하기만 하면 된다. 블로그를 생성 및 운영하면서 부가적으로 필요한 모듈들은 모두 <code>npm</code>을 통해 설치하면 된다. 필요한 모듈은 그때그때 필요할 때 설치하도록 하겠다.</p><h2 id="Hexo-블로그-생성"><a href="#Hexo-블로그-생성" class="headerlink" title="Hexo 블로그 생성"></a>Hexo 블로그 생성</h2><p>블로그와 관련된 모든 행동은 hexo명령어로 시작된다. 이는 hexo를 설치할 때 <code>-g</code> 옵션을 통해 global로 설치하였기에 가능한 것이다.</p><p>이제 블로그를 생성해 보겠다. 먼저 적당하게 폴더를 하나 만든 후에 그 폴더에 접근 후 <code>Shift + 마우스 우클릭</code>을 통해 <code>여기서 명령 창 열기</code>를 실행하자. 그리고 명령어를 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init myBlog</span><br><span class="line">$ <span class="built_in">cd</span> myBlog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p><code>hexo init</code>명령어를 입력하게 되면 지정된 블로그 명으로 hexo가 알아서 기본적인 블로그를 만들어 준다. 그리고 생성된 블로그 경로로 이동하여 <code>npm install</code>명령어를 통해 필요한 모듈을 설치한다. 모듈은 <code>package.json</code>에 명시되어 있다.  </p><p>만들어진 블로그 폴더를 열어 내용을 확인해보자.</p><div class="alert info no-icon"><ul><li><strong>node_modules</strong> - hexo 블로그 사용에 필요한 기본적인 node.js 모듈</li><li><strong>scaffolds</strong> - hexo 페이지를 구성할 기본적인 markdown파일</li><li><strong>source</strong> - 실제로 포스트를 작성한 파일(markdown)과 이미지 등의 리소스가 저장되는 경로</li><li><strong>theme</strong> -  테마 파일이 저장되는 경로로 처음 hexo를 설치하게 되면 <code>landscape</code> 테마가 설치</li><li><strong>.gitignore</strong> - git을 통해 github에 블로그를 업로드할 때 업로드를 제외할 파일의 목록을 정의하는 파일</li><li><strong>_config.yml</strong> - hexo 블로그의 옵션을 지정하는 설정 파일</li></ul></div><h3 id="Hexo-블로그-Github에-연동하기"><a href="#Hexo-블로그-Github에-연동하기" class="headerlink" title="Hexo 블로그 Github에 연동하기"></a>Hexo 블로그 Github에 연동하기</h3><p>hexo로 생성한 블로그는 <code>github</code>에 업로드해야지만 블로그에 접속하여 확인할 수 있다. 이미 생성한 블로그를 <code>github</code>에 업로드하기 위해서는 <code>git 명령어(add, commit, push)</code>를 통해서 업로드할 수 있겠지만 <strong>hexo를 사용하면 별도의 git 명령어가 없이도 알아서 github에 업로드</strong>를 해준다. 그러기 위해서는 <code>hexo</code>와 <code>github</code>간의 연결고리가 있어야 하는데 이 연결고리는 <code>_config.yml</code>을 통해 지정할 수 있다.</p><p><code>_config.yml</code>을 열어보자.  여러 설정이 있지만 일단 넘어가고 마지막에 있는 <code>#Depolyment</code>를 보자. 여기에 <code>deploy</code>에 처음에 만든 <code>github repository</code>를 적어주면 <code>github</code>와 연동되게 된다. </p><p>아래처럼 수정하자.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/계정이름/계정이름.github.io.git</span></span><br></pre></td></tr></table></figure><p>그리고 hexo에서 <code>github</code>에 업로드하기 위해 필요한 <code>npm</code>모듈을 설치하자. 생성한 블로그 폴더 경로로 이동하여 명령 창을 실행하여 <code>npm</code>명령어를 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>위와 같이 설정하고 <code>hexo deploy</code> 명령어를 실행하게 되면 <code>_config.yml</code>에 작성해둔 주소로 소스를 업로드하게 된다.</p><p><code>_config.yml</code>에서는 블로그의 공통적인 속성을 설정할 수 있다. 예를들면 <code>title</code>은 블로그의 타이틀을 나타낸다. 자세한 내용은 <a href="https://hexo.io/ko/docs/" target="_blank" rel="noopener">HEXO DOCUMENT</a>에서 확인하고 수정하도록 하자.</p><h3 id="포스트-생성하기"><a href="#포스트-생성하기" class="headerlink" title="포스트 생성하기"></a>포스트 생성하기</h3><p>이제 포스트를 작성해보도록 하자. 모든 것은 hexo를 통해 이루어진다. 생성한 블로그 폴더 경로로 이동하여 명령 창을 실행하여 아래처럼 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post first-post</span><br></pre></td></tr></table></figure><p>hexo의 <code>new post [포스트 파일명]</code>명령어를 입력하게 되면 포스팅이 가능한 파일을 만들어 준다. <code>Jekyll</code>과 비교했을 때 <code>hexo</code>가 편리하고 좋은 점이 이 부분이다. <strong>단 하나의 명령어 하나로 포스트 파일을 아주 쉽게 만들 수가 있다.</strong></p><p><code>블로그명/source/_posts</code>경로로 가보면 <code>first-post.md</code>파일이 생성된 것을 볼 수 있다. <code>github page</code>를 사용하기 위해서는 <code>markdown</code>언어를 사용하여 글을 작성해야 한다. <code>markdown</code>언어는 <code>md 확장자</code>를 가지며 <a href="https://ko.wikipedia.org/wiki/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4" target="_blank" rel="noopener">WIKI</a>를 참고하면 그리 어려운 언어가 아니다. 모든 포스트는 <code>markdown</code>언어로 이루어진다.</p><p>생성한 파일을 열어보자. 참고로 <code>markdown</code>을 지원하는 에디터는 다양하다. 웹으로도 지원하는 에디터를 참고하여 작성하자. 나는 <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>를 사용한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">first-post</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-06</span><span class="bullet">-30</span> <span class="number">13</span><span class="string">:53:51</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>기본 옵션에 대한 설명은 아래와 같다.</p><div class="alert info no-icon"><p><strong>title</strong> - 실제 페이지에 출력될 포스트의 제목<br><strong>date</strong> - 포스트를 생성한 날짜(<em>hexo 빌드 시 date 날짜별로 폴더가 생성</em>)<br><strong>tags</strong> - hexo 블로그에서 관리 될 tag 목록</p></div><p>글을 작성해 보자.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: first-post</span><br><span class="line">date: 2017-06-30 13:53:51</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">## 제목</span></span><br><span class="line">나의 첫번째 포스트입니다.</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Hexo-빌드"><a href="#Hexo-빌드" class="headerlink" title="Hexo 빌드"></a>Hexo 빌드</h3><p>우리는 포스트 작성을 <code>markdown</code>으로 작성하였다. hexo로 이 <code>markdown</code>으로 구성된 파일을 빌드하게 되면 <code>github page</code>에 적합한 구조로 재 생성하고 <code>md</code>파일들은 <code>html</code>파일로 변경해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate 또는 hexo g</span><br></pre></td></tr></table></figure><p>빌드 후에 블로그 경로로 들어가보면 <code>public</code> 폴더가 생겼을 것이다. 이 안에는 테마에 맞게 css 파일도 생겼고 <code>first-post.md</code>파일도 <code>index.html</code>로 변경된 것을 볼 수 있다. 포스트는 날짜 별로 폴더가 생성되고 그 안에 생성된다.  <code>hexo</code>를 통해 <code>github</code>에 파일을 업로드하게 되면 실제로 업로드되는 파일은 이 <code>public</code> 폴더가 업로드된다.</p><h3 id="로컬에서-확인하기"><a href="#로컬에서-확인하기" class="headerlink" title="로컬에서 확인하기"></a>로컬에서 확인하기</h3><p>포스트를 작성하고 <code>generate</code>까지 하였다면 로컬에서 먼저 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>hexo의 내장 서버 구동하고 브라우저를 실행하여 <strong><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></strong>으로 접속하자. 그러면 실제로 서비스 될 블로그를 로컬에서 확인할 수 있다.</p><h3 id="Github에-업로드하기"><a href="#Github에-업로드하기" class="headerlink" title="Github에 업로드하기"></a>Github에 업로드하기</h3><p>로컬에서 확인하고 수정할 곳이 없다고 판단되면 블로그 소스들을 <code>github</code>에 업로드하여 실제 블로그 페이지 띄워 서비스해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy 또는 hexo d</span><br></pre></td></tr></table></figure><p>위의 명령어를 통해  <code>github</code>에 업로드를 하며, <code>generate 명령어</code>와 동시에 작성할 수도 있다.</p><pre><code class="bash">$ hexo g --d</code></pre><p><code>deploy</code>가 되었다면 <code>github</code>에 접속하여 <code>계정명.github.io</code>의 <code>Repository</code>를 보자. 파일이 업로드가 되었는가? 그렇다면 브라우저 주소창에 <strong>https://계정명.github.io</strong>를 입력해보자. 우리가 지금까지 해온 결과물이 출력 될 것이다.</p><hr><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><code>git</code>, <code>github page</code>, <code>npm</code>, <code>node.js</code>, <code>hexo</code> 같은 단어들이 많이 나왔다. 그리고 설명도 복잡해졌다. 하지만 우리는 아무것도 몰라도 된다. <strong><em>목적은 포스트를 만들기</em></strong>이기 때문이다. 간단하게 요약하면 이렇게 된다.</p><div class="alert success no-icon"><ol><li>git 설치</li><li>github 가입 및 Repository 생성</li><li>node.js 설치</li><li>npm으로 hexo 설치</li><li>hexo로 블로그 생성</li><li>hexo와 github 연동</li><li>hexo로 새로운 포스트 생성</li><li>hexo로 빌드</li><li>로컬에서 확인</li><li>github에 업로드</li></ol></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> nodejs </category>
          
          <category> hexo </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> 블로그 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 09. Mocha로 실제 TDD 해보기</title>
      <link href="/2017/06/21/Mocha-step-09/"/>
      <url>/2017/06/21/Mocha-step-09/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>지금까지의 Tutorial을 통해 Mocha에 대해서 어느 정도 인지하고 습득하였다. 아직도 Mocha에 대해 애매모호한 기분이 들거나 뭔가 아쉬움이 남는다면 다시 돌아가 <a href="https://kdydesign.github.io/2017/06/08/Mocha/">JavaScript 단위 테스트 프레임워크 - Mocha</a>부터 살펴보도록 하자.</p><p>이제 지금까지 배운 내용을 토대로 실제로 Mocha를 가지고 TDD를 진행해 보자. 이 Tutorial을 추가한 이유는 두 가지로 분류하였다.</p><blockquote><ol><li>TDD를 이해하기 위함이며,</li><li>Mocha를 실전에 사용해 보기 위함이다.</li></ol></blockquote><p>이 두 가지를 생각하며 Tutorial을 시작해보자.</p><hr><h2 id="TDD-Test-Driven-Development-Cycle"><a href="#TDD-Test-Driven-Development-Cycle" class="headerlink" title="TDD(Test-Driven-Development) Cycle"></a>TDD(Test-Driven-Development) Cycle</h2><p>TDD는 <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-03/">Step 03: Hooks</a>에서 살짝 설명한 바가 있다. TDD는 짧은 Cycle을 반복적으로 테스트하는 개발 프로세스로 테스트 코드를 먼저 작성하고 작성된 테스트 코드를 패스할 수 있도록 비즈니스 로직을 개발하는 방법이다. 자세한 TDD가 무엇인지는 구글링을 통해 알아보자. </p><p>시작하기에 앞서 TDD의 프로세스를 생각해두자. 위에서 말했듯이 하나의 짧은 Cycle을 반복적으로 수행하는 것이다. 이 Cycle의 대략적인 순서는 이렇다.</p><div class="alert info"><ol><li>개발 <strong>명세 작성</strong></li><li>개발 명세에 따른 <strong>테스트 코드 작성</strong></li><li>테스트 실행</li><li>테스트가 성공하도록 <strong>최소한의 비스니스 로직 작성</strong></li><li>테스트 실행</li><li><strong>테스트 케이스 추가</strong></li><li>테스트 실행</li><li>테스트 코드 및 테스트 케이스 <strong>Refactoring</strong></li><li>테스트 실행</li></ol></div><p>위의 순서대로 우리는 간략하게 <strong>Validation Check Plug-in</strong>을 만들어 보면서 TDD와 Mocha를 동시에 파악할 것이다.</p><h2 id="1-명세-작성"><a href="#1-명세-작성" class="headerlink" title="1. 명세 작성"></a>1. 명세 작성</h2><p>프로세스 순서에 따라 명세를 작성한다. 명세를 작성하기 위해서는 우리가 무엇을 개발해야 하는지 목표를 정확하게 파악하는 것이 좋다. 우리는 <strong>Validation Check Plug-in</strong> 만드는 것을 목표로 필요한 사항을 명세에 적어볼 수 있겠다. </p><div class="alert info"><ul><li>이메일의 형식을 검증한다.</li><li>전화번호의 형식을 검증한다.</li><li>이름의 형식을 검증한다.</li></ul></div><p>간략하게 3가지의 명세를 적어보았다. Validation Check를 진행하는데 필요한 몇 가지의 기능을 나열한 것이다.</p><h2 id="2-개발-명세에-따른-테스트-코드-작성"><a href="#2-개발-명세에-따른-테스트-코드-작성" class="headerlink" title="2. 개발 명세에 따른 테스트 코드 작성"></a>2. 개발 명세에 따른 테스트 코드 작성</h2><p>개발 명세를 작성하였으니 테스트 코드를 작성해 보자. 첫 번째로 <code>이메일의 형식을 검증한다.</code>는 것에 대해 테스트 코드를 작성해 볼 것이다. <code>Assertions</code>는 <code>Chai</code>를 사용할 것이다. <code>Chai</code>에 대해서는 <a href="https://kdydesign.github.io/2017/06/15/Mocha-step-02/">Step 02: Assertion-chai</a>를 참고하자.</p><p>해당 파일은 <code>test.js</code>와 같은 테스트 파일이 될 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">suite(<span class="string">'#Validation Check'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    test(<span class="string">'이메일의 형식을 검증한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> validate = <span class="keyword">new</span> Validate();</span><br><span class="line">        <span class="keyword">var</span> result = validate.email(<span class="string">'test@naver.com'</span>);</span><br><span class="line"></span><br><span class="line">        expect(result).to.be.true;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>우리는 TDD를 진행할 것이니 테스트 스위트의 스타일을 <code>describe</code>, <code>it</code>이 아닌 <code>suite</code>, <code>test</code>를 사용했다. 물론 Mocha의 옵션 역시 <code>--ui tdd</code>로 주어야 한다. <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-03/">Step 03: Hooks</a>을 참고하자.</p><h2 id="3-테스트-실행"><a href="#3-테스트-실행" class="headerlink" title="3. 테스트 실행"></a>3. 테스트 실행</h2><p>위에 테스트 코드를 실행해보자. 당연히 <strong>비즈니스 코드</strong>가 없기 때문에 오류가 발생 될 것이다. 여기까지만 보아도 왜 TDD가 <code>테스트 주도 개발</code>인지 알 수 있다. 테스트 코드를 먼저 작성 후 이후에 비즈니스 코드를 작성한다.</p><h2 id="4-테스트가-성공하도록-최소한의-비즈니스-로직-작성"><a href="#4-테스트가-성공하도록-최소한의-비즈니스-로직-작성" class="headerlink" title="4. 테스트가 성공하도록 최소한의 비즈니스 로직 작성"></a>4. 테스트가 성공하도록 최소한의 비즈니스 로직 작성</h2><p>이제 작성한 테스트 코드가 통과될 수 있도록 최소한으로써 비즈니스 코드를 작성해보자. 해당 파일은 <code>validate.js</code>와 같은 적당한 파일이 될 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Validate.prototype = &#123;</span><br><span class="line">    email: <span class="function"><span class="keyword">function</span> (<span class="params">email</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> regex = <span class="regexp">/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]&#123;2,3&#125;$/i</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regex.test(email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Validate;</span><br></pre></td></tr></table></figure><p><code>validate.js</code>를 만들었으니 이미 만든 테스트 코드가 있는 <code>test.js</code>에 해당 모듈을 불러오자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> Validate = <span class="built_in">require</span>(<span class="string">'./validate'</span>);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>여기서 언급할 내용은 코드의 설명이 아닌 TDD에 대한 내용이다. 처음 TDD를 접하게 되면 다소 난감한 상황에 부딪힌다. 그 부분은 첫 테스트 코드를 작성할 때이다. 막막하기 그지없다. 무엇을 시작해야 할지 모르기 때문이다. 이때 기억해야 할 것은 이것이다.</p><div class="alert info"><ul><li><strong>given</strong> - 어떤 조건이 필요한가.</li><li><strong>when</strong> - 어떻게 동작이 진행되는가.</li><li><strong>then</strong> - 동작에 대한 결과가 어떠한가.</li></ul></div><p>?????… 무슨 말이지..<br>이 내용을 위에 작성한 코드에 대입해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">suite(<span class="string">'#Validation Check'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    test(<span class="string">'이메일의 형식을 검증한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">var</span> validate = <span class="keyword">new</span> Validate();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">var</span> result = validate.email(<span class="string">'test@naver.com'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        expect(result).to.be.true;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>주석을 적어놓으니 이해가 되는 듯하다. TDD에 익숙하지 않다면 <code>given</code>, <code>when</code>, <code>then</code> 패턴을 기억하고 주석을 먼저 적고 시작하자.</p><h2 id="5-테스트-실행"><a href="#5-테스트-실행" class="headerlink" title="5. 테스트 실행"></a>5. 테스트 실행</h2><p>이제 테스트 코드를 실행해보자. 적당하게 비즈니스 코드를 작성하였다. 테스트 코드가 실패한다면 비즈니스 코드를 수정하자.</p><h2 id="6-테스트-케이스-추가"><a href="#6-테스트-케이스-추가" class="headerlink" title="6. 테스트 케이스 추가"></a>6. 테스트 케이스 추가</h2><p>5번에서 테스트가 성공하였다면 바로 변칙적인 다른 테스트 케이스를 추가하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">var</span> Validate = <span class="built_in">require</span>(<span class="string">'./validate'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">suite(<span class="string">'#Validation Check'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    test(<span class="string">'이메일의 형식을 검증한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">var</span> validate = <span class="keyword">new</span> Validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">var</span> result1 = validate.email(<span class="string">'test@naver.com'</span>);</span><br><span class="line">        <span class="keyword">var</span> result2 = validate.email(<span class="string">'test_1234@naver.com'</span>);</span><br><span class="line">        <span class="keyword">var</span> result3 = validate.email(<span class="string">'!@test@naver.com'</span>);</span><br><span class="line">        <span class="keyword">var</span> result4 = validate.email(<span class="string">'test#naver.com'</span>);</span><br><span class="line">        <span class="keyword">var</span> result5 = validate.email(<span class="string">'test'</span>);</span><br><span class="line">        <span class="keyword">var</span> result6 = validate.email(<span class="string">'naver.com'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        expect(result1).to.be.true;</span><br><span class="line">        expect(result2).to.be.true;</span><br><span class="line">        expect(result3).to.be.false;</span><br><span class="line">        expect(result4).to.be.false;</span><br><span class="line">        expect(result5).to.be.false;</span><br><span class="line">        expect(result6).to.be.false;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="7-테스트-실행"><a href="#7-테스트-실행" class="headerlink" title="7. 테스트 실행"></a>7. 테스트 실행</h2><p>테스트를 실행해보자. 여기서 테스트 실패가 나온다면 비즈니스코드가 잘못된 것이니 테스트가 성공하도록 비즈니스 코드를 수정하면 된다.</p><h2 id="8-테스트-코드-및-테스트-케이스-Refactoring"><a href="#8-테스트-코드-및-테스트-케이스-Refactoring" class="headerlink" title="8. 테스트 코드 및 테스트 케이스 Refactoring"></a>8. 테스트 코드 및 테스트 케이스 Refactoring</h2><p>테스트 케이스를 추가하고도 완료되었다면 테스트 코드 및 비즈니스 코드를 <code>Refactoring</code>을 진행하면 된다. 테스트 코드를 <code>Refactoring</code>하는 이유는 당연히 유지관리를 위해서이다. 테스트 코드는 일회성이 아닌 유지관리 포인트에 포함되는 사항이기 때문이다.<br>6번에서 작성한 코드가 반복적인 부분이 많다. result1, 2, 3, 4….라니… 수정하도록 하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">var</span> Validate = <span class="built_in">require</span>(<span class="string">'./validate'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">suite(<span class="string">'#Validation Check'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    test(<span class="string">'이메일의 형식을 검증한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">var</span> successTestCase = [</span><br><span class="line">            <span class="string">'test@naver.com'</span>, <span class="string">'test_1234@naver.com'</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> failTestCase = [</span><br><span class="line">            <span class="string">'!@test@naver.com'</span>, <span class="string">'test#naver.com'</span>, <span class="string">'test'</span>, <span class="string">'naver.com'</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> validate = <span class="keyword">new</span> Validate();</span><br><span class="line"></span><br><span class="line">        successTestCase.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">testCase</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//when</span></span><br><span class="line">            <span class="keyword">var</span> result = validate.email(testCase);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//then</span></span><br><span class="line">            expect(result).to.be.true;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        failTestCase.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">testCase</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//when</span></span><br><span class="line">            <span class="keyword">var</span> result = validate.email(testCase);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//then</span></span><br><span class="line">            expect(result).to.be.false;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>가독성을 위해 <code>success</code>와 <code>fail</code>로 나눠 보았다. 자세히 보니 명세에 적힌 기능을 구현해본다면 <code>Validate</code> 객체를 테스트 케스트마다 생성할 테니 미리 <code>Refactoring</code>을 하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">var</span> Validate = <span class="built_in">require</span>(<span class="string">'./validate'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">suite(<span class="string">'#Validation Check'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> validate = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> successTestCase = [];</span><br><span class="line">    <span class="keyword">var</span> failTestCase = [];</span><br><span class="line"></span><br><span class="line">    suiteSetup(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        validate = <span class="keyword">new</span> Validate();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    suiteTeardown(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        validate = <span class="literal">null</span>;</span><br><span class="line">        successTestCase = [];</span><br><span class="line">        failTestCase = [];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'이메일의 형식을 검증한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        successTestCase = [</span><br><span class="line">            <span class="string">'test@naver.com'</span>, <span class="string">'test_1234@naver.com'</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        failTestCase = [</span><br><span class="line">            <span class="string">'!@test@naver.com'</span>, <span class="string">'test#naver.com'</span>, <span class="string">'test'</span>, <span class="string">'naver.com'</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        successTestCase.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">testCase</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//when</span></span><br><span class="line">            <span class="keyword">var</span> result = validate.email(testCase);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//then</span></span><br><span class="line">            expect(result).to.be.true;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        failTestCase.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">testCase</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//when</span></span><br><span class="line">            <span class="keyword">var</span> result = validate.email(testCase);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//then</span></span><br><span class="line">            expect(result).to.be.false;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="9-테스트-실행"><a href="#9-테스트-실행" class="headerlink" title="9. 테스트 실행"></a>9. 테스트 실행</h2><p>실행해보자. 테스트가 실패한다면 비즈니스 코드 수정 후 7번으로 돌아가 반복적으로 테스트를 진행하면 된다.</p><hr><p>여기까지가 Mocha의 마지막 지점이다. 물론 명세에 있는 내용을 다 포스팅하진 않았지만, 처음에 말했듯이 <code>하나의 짧은 Cycle을 반복적으로 수행하는 것</code>이다. 물론 테스트함에 있어서 특수한 케이스가 나올 수 있지만, TDD를 사용하는 목적을 다시 생각해 보면 어느 부분부터 다시 시작해야 하는지 알 수 있을 것이다. </p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 08. IDE Edit Plug-in (IntelliJ)</title>
      <link href="/2017/06/19/Mocha-step-08/"/>
      <url>/2017/06/19/Mocha-step-08/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>개발자들은 자기가 사용하는 IDE가 있을 것이다. IDE를 사용하는 이유는 더 편리하기 때문이다. 당연하다. bash, nodepad 보다는 훨씬 편하니까. 나 역시 <code>IntelliJ</code>를 사용하고 있다. 이 <code>IntelliJ</code>에서는 Mocha를 좀 더 다루기 쉽게 Plug-in을 지원하고 있다. <code>IntelliJ</code>뿐만 아니라 <code>Webstorm</code> 등의 <code>JETBRAIN</code> 제품군에서 지원하고있다.<br>이번 Tutorial은 <code>IntelliJ</code>에서 Mocha를 손쉽게 사용하는 방법을 배워보도록 하겠다. <code>JETBRAINS</code> 제품군을 사용하지 않는다면 해당 Tutorial은 건너 뛰도록하자.</p><hr><h2 id="Node-js-및-Plug-in-설치"><a href="#Node-js-및-Plug-in-설치" class="headerlink" title="Node.js 및 Plug-in 설치"></a>Node.js 및 Plug-in 설치</h2><p>Mocha를 사용해보기에 앞서 먼저 <code>Node.js</code> 와 <code>IntelliJ NodeJs Plug-in</code>을 설치하자. 먼저 <a href="https://nodejs.org/ko/" target="_blank" rel="noopener">여기서</a> Node.js를 설치한다. 기본적으로 <code>IntelliJ</code>를 설치할 때 별도의 설치 여부가 나오지만 설치가 되어있지 않다면 설치하도록 하자.<br><code>ctrl + shift + a</code> 또는 <code>IntelliJ</code>설정 창에서 <code>plugins</code>를 검색하여 해당 창을 실행 후 <code>nodejs</code>를 검색하였을 때 설치가 되어있지 않으면 <code>Browser Repositories</code>에서 <code>nodejs</code>를 설치하도록 하자. </p><h2 id="Mocha-Configurations"><a href="#Mocha-Configurations" class="headerlink" title="Mocha Configurations"></a>Mocha Configurations</h2><p><code>Node.js</code>가 설치되었다면 <code>Mocha</code> runner 또는 compiler를 추가하자. <code>run/debug configurations</code> 창에서 <code>+</code>버튼을 눌러 <code>Mocha</code>를 선택한다. 이후 출력되는 설정 창에서 수정해야 할 부분은 아래를 참고하자.</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>Node interpreter</td><td>node.exe 경로</td></tr><tr><td>Working directory</td><td>mocha 프로젝트 경로</td></tr><tr><td>Mocha package</td><td>mocha 패키지 경로(ex. npm\node_modules\mocha</td></tr><tr><td>User Interface</td><td>사용자 인터페이스 설정</td></tr><tr><td>Test directory</td><td>테스트 파일 경로(ex. test.js)</td></tr></tbody></table><p><img src="image01.png" alt="image01"></p><p>설정이 완료되면 실행해 보도록 하자. 실행을 해보면 테스트 스위트와 테스트 케이스별로 성공, 실패 여부를 확인할 수 있다. 여기서 <strong><code>IntelliJ</code>에서 실행하면 좋은 점 두 가지</strong>가 있다.</p><div class="alert info"><ol><li>Break Point를 통한 Debugging</li><li>HTML 출력</li></ol></div><p><img src="image02.png" alt="image02"></p><p>이전 Tutorial <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-06/">Step 06: 브라우저에서의 Mocha 지원</a>에서 Mocha를 브라우저에서 구동하는 방법을 배웠었는데 <code>IntelliJ</code>를 사용하면 별도의 HTML파일을 출력할 수가 있다. 그리고 불편하기만하던 Mocha의 <code>--debug</code> 옵션을 <code>IntelliJ</code>에서는 Break Point를 통해서 쉽게 Debugging이 가능하다.</p><hr><p>IDE Tool을 사용하면 어떤 개발 프레임워크이든 쉽게 이용할 수가 있다. 그만큼 개발 속도 역시 빠르다 할 수 있다. 이번 Tutorial을 통해 우리는 이제 Mocha를 사용하여 단위 테스트를 할 수 있는 최적화된 환경을 만들 수 있다.<br>이제 마지막으로 <code>Mocha를 활용하여 실제 TDD</code>를 어떻게 하는지 알아볼 차례이다.</p><p><a href="https://kdydesign.github.io/2017/06/21/Mocha-step-09/">Step 09: Mocha로 실제 TDD 해보기</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> intelliJ </tag>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 07. Mocha Options</title>
      <link href="/2017/06/19/Mocha-step-07/"/>
      <url>/2017/06/19/Mocha-step-07/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>이제 Mocha의 기본적인 사용법을 모두 터득하였다. 지금까지 배운 것만으로도 어느 정도의 Test가 가능하다. 하지만 우리가 항상 개발할 떄에 Framework를 찾는 이유는 무엇인가 개발을 할 때 손쉽게 개발하기 위해서이다. Mocha 역시 옵션을 조정하여 좀 더 편리하게 사용할 수 있는데 이번 Tutorial에서는 이 옵션에 대해서 알아보겠다.</p><hr><h2 id="기본-옵션"><a href="#기본-옵션" class="headerlink" title="기본 옵션"></a>기본 옵션</h2><p>Mocha의 기본 옵션 먼저 확인해 보도록 하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha -h</span><br></pre></td></tr></table></figure><p>꽤 많은 옵션이 출력된다. 하나하나 설명하기는 양이 많기에 일부 가장 자주 쓰이는 것으로 알아보자.</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-reporters</td><td>테스트 결과를 출력할 수 있는 레포트 형식 목록을 출력</td></tr><tr><td>-R, –reporter <name></name></td><td>테스트 결과를 출력할 레포트 형식을 지정</td></tr><tr><td>-d, –debug</td><td>Node늬 Debug 모드 활성화</td></tr><tr><td>-g, –grep <pettern></pettern></td><td>정규식 패턴에 일치하는 특정 테스트 실행</td></tr><tr><td>-f, –fgrep <string></string></td><td>특정 문자열이 포함된 테스트 실행</td></tr><tr><td>-r, –require <name></name></td><td>require 할 모듈 명을 미리 지정하여 미리 특정 모듈을 포함</td></tr><tr><td>-t, –timeout <ms></ms></td><td>timeout을 지정(default : 2000ms)</td></tr><tr><td>-u, –ui <name></name></td><td>사용자 인터페이스 지정(tdd, bdd, qunit, exports)</td></tr><tr><td>-w, –watch</td><td>테스트 파일 수정 시 자동 반영</td></tr></tbody></table><p>이 외에 다른 옵션은 <code>$ mocha -h</code>를 통해 확인할 수 있다.</p><h2 id="mocha-opts"><a href="#mocha-opts" class="headerlink" title="mocha.opts"></a>mocha.opts</h2><p>위처럼 기본 옵션을 <code>Command</code>를 통해 지정할 수 있겠지만 다른 방법으로 더욱 편리하게 사용할 수 있다. 그 방법으로는 <code>mocha.opts</code>파일에 필요한 옵션들을 지정해 놓는 것이다. 대부분의 <code>test</code> 파일들은 <code>test</code> 또는 <code>tests</code> 폴더에 모아두는 것이 관례이다. 이 <code>test</code> 또는 <code>tests</code> 폴더 안에 미리 옵션들을 정의 해둔 <code>mocha.opts</code>를 넣어두면 테스트 시에 자동으로 파일에 정의된 옵션들을 사용하여 테스트하게 된다.</p><p>먼저 프로젝트 안에 <code>tests</code>라는 폴더를 만들고 그 안에 <code>mocha.opts</code>파일을 만들자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir tests</span><br><span class="line">$ <span class="built_in">cd</span> tests</span><br><span class="line">$ touch mocha.opts</span><br></pre></td></tr></table></figure><p>이제 <code>mocha.opts</code>에 원하는 옵션을 지정해주면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--require should</span><br><span class="line">--reporter dot</span><br><span class="line">--ui bdd</span><br></pre></td></tr></table></figure><p>위 옵션은 <code>should</code> 라이브러리를 포함하고 <code>reporter</code>는 <code>dot</code>로 사용하며, <code>사용자 인터페이스</code>는 <code>bdd</code>를 사용한다는 옵션이다.</p><h2 id="package-json에-Options-지정"><a href="#package-json에-Options-지정" class="headerlink" title="package.json에 Options 지정"></a>package.json에 Options 지정</h2><p><code>mocha.opts</code>로 사용하면 편리하지만 이 밖에도 <code>package.json</code>에도 옵션을 명시할 수 있다. <code>package.json</code>에서 <code>script</code>항목에 위와 동일하게 옵션을 추가하여 수정한다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*...*/</span><br><span class="line"></span><br><span class="line">"scripts" : &#123;</span><br><span class="line">    "test": "mocha test --reporter spec --ui bdd",</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">/*...*/</span><br></pre></td></tr></table></figure><hr><p>Mocha는 옵션뿐만 아니라 IDE Tools에서도 편리하게 사용할 수 있다. 다음 편에서는 <code>JETBRAINS</code>제품 군(<code>IntelliJ</code>,<code>WebStorm</code> 등)에서 Mocha를 쉽게 사용하는 방법을 알아보겠다.</p><p><a href="https://kdydesign.github.io/2017/06/19/Mocha-step-08/">Step 08: IDE Edit Plug-in (IntelliJ)</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 06. Mocha 브라우저 구동</title>
      <link href="/2017/06/16/Mocha-step-06/"/>
      <url>/2017/06/16/Mocha-step-06/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>부터 시작으로 지금까지 우리는 <code>$ mocha</code> 명령을 통해 터미널에서 실행하였다. Mocha는 터미널 뿐만 아니라 <code>gulp</code>의 <code>task</code>를 통해 실행도 가능하지만, 이 밖에도 <code>브라우저에서 구동</code>되도록 지원하고 있다.</p><p>우리는 이번 Tutorial에서는 <code>Mocha를 브라우저에서 구동</code>하는 방법을 알아보겠다.</p><hr><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><p>먼저 <code>html</code> 파일을 생성하도록 하겠다. 추후에 이 페이지를 실행시켜 Mocha를 구동할 것입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"ko"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Mocha Tests<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"../node_modules/mocha/mocha.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mocha"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../node_modules/mocha/mocha.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../node_modules/chai/chai.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    mocha.setup(&#123;</span></span><br><span class="line"><span class="javascript">        ui: <span class="string">'bdd'</span>,</span></span><br><span class="line"><span class="javascript">        reporter: <span class="string">'html'</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 테스트 코드 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    mocha.checkLeaks();</span></span><br><span class="line"><span class="undefined">    mocha.run();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 코드는 다 알 것이라고 생각된다.<br>코드를 보게 되면 Mocha에 필요한 <code>mocha.css</code>와 <code>mocha.js</code> 그리고 <code>chai.js</code>파일을 불러왔다. 해당 Tutorial에서는 <code>node_modules</code>에 포함된 파일을 불러왔지만 <code>CDN</code>으로 불러올 수 있다.</p><p><code>CDN</code>은 아래를 참고하자.</p><div class="alert info"><p><a href="https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.css" target="_blank" rel="noopener">https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.css</a><br><a href="https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.js" target="_blank" rel="noopener">https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.js</a><br><a href="https://cdnjs.cloudflare.com/ajax/libs/chai/4.0.2/chai.min.js" target="_blank" rel="noopener">https://cdnjs.cloudflare.com/ajax/libs/chai/4.0.2/chai.min.js</a></p></div><p>이렇게 필요한 소스를 불러온 후 Mocha 설정에 관련된 <code>setup</code>을 진행한다. 그런 다음 테스트 스위트와 테스트 케이스가 포함된 <code>.js</code>파일을 로드한다. 마지막으로 <code>onload</code> 인터페이스와 함께 <code>run()</code>을 통해 Mocha를 실핼하게 되어있다. 우리는 아직 <code>test.js</code>를 정의하지 않았기 때문에 실행을 한다고 하더라고 결과가 나오지는 않는다.</p><h2 id="test-js"><a href="#test-js" class="headerlink" title="test.js"></a>test.js</h2><p>이제 <code>index.html</code>파일이 준비되어 있으니 <code>test.js</code>를 정의하도록 하겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'#Array'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr;</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arr = [];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">"array test"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(arr).to.be.an.instanceOf(<span class="built_in">Array</span>);</span><br><span class="line">        expect(arr).to.be.an(<span class="string">'array'</span>).that.is.not.empty;</span><br><span class="line">        expect(arr).to.be.that.includes(<span class="number">2</span>);</span><br><span class="line">        expect(arr).to.have.lengthOf(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>터미널에서 실행할 때와 다른 점은 <code>chai.expect</code> 부분이다. <code>브라우저 구동</code>할 때는 이미 <code>index.html</code>에 우리가 Chai를 불러왔기 때문에 별도로 <code>require</code>하지 않아도 된다.<br>테스트의 내용을 잠깐 살펴보면 Array의 타입과 데이터가 존재하는지에 대한 몇 가지 테스트이다. 이제 브라우저를 실행하면 결과가 출력된다.</p><p><img src="./result_thumbnail_01.png" alt="result01"></p><p>터미널보다 훨씬 더 보기 편리하다. 해당 테스트 케이스를 클릭하게 되면 테스트를 진행한 코드를 볼 수가 있다. 그리고 상단에는 <code>passes</code>, <code>failures</code>, <code>duration</code>을 확인할 수 있다.<br>테스트가 너무 짧은가? 테스트 케이스를 더 추가하여 다시 확인해 보자.</p><p>아래 코드를 <code>test.js</code>에 이어서 작성하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'array compare'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(arr).to.eql([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'array member'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(arr).to.have.members([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line">        done();</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>먼저 결과를 보자.</p><p><img src="result_thumbnail_02.png" alt="result02"></p><p><code>array member</code>테스트의 경우 브라우저에도 <code>3000ms</code>뒤에 실행하는 것을 볼 수 있다. 그리고 <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-04/">Step 04: 비동기 처리</a>에서 배운 비동기로 처리하였으며, <code>3000ms</code>후에 실행하기에 오류가 발생한다. 발생한 오류에 대한 내용도 출력이 되는 것을 확인할 수 있다.</p><iframe id="cp_embed_pwNREj" src="//codepen.io/kdydesign/embed/pwNREj?height=300&theme-id=dark&slug-hash=pwNREj&default-tab=result" scrolling="no" frameborder="no" height="300" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe><h2 id="외부-모듈-불러오기"><a href="#외부-모듈-불러오기" class="headerlink" title="외부 모듈 불러오기"></a>외부 모듈 불러오기</h2><p>우리는 <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-05/">Step 05: 외부 모듈 테스트</a>을 통해 외부 모듈을 불러와서 테스트를 작성하였다. 그리고 <code>브라우저 구동</code>에서 외부 모듈을 어떻게 불러오는지 대략적인 설명이 있었다. 그 내용을 자세하게 알아보겠다.<br><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-05/">Step 05: 외부 모듈 테스트</a>에서 사용한 <code>ModuleSum.js</code>를 사용하겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동일하게 합계를 구하는 함수이다. 하지만 다른 점은 <code>export</code>를 하지 않았다는 것이다. 단순한 <code>function</code>이다. 이제 이 <code>ModuleSum.js</code>는 <code>index.html</code>에서 불러오도록 하겠다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- //... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mocha"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../node_modules/mocha/mocha.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../node_modules/chai/chai.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"ModuleSum.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- //... --&gt;</span></span><br></pre></td></tr></table></figure><p>불러온 <code>ModuleSum.js</code>를 가지고 테스트 케이스를 작성하겠다. <code>test.js</code>에 테스트 스위트를 추가해야겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'#ModuleSum'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'sum()'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(sum(<span class="number">1</span>, <span class="number">2</span>)).to.eql(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step06-Running%20Mocha%20in%20the%20Browser" target="_blank" rel="noopener">예제 코드</a></p><hr><p>Mocha의 <code>브라우저 구동</code>은 매우 다루기 쉽고 작성하기도 쉽다. <code>index.html</code>에 설정만 적당하게 잘 만들어 놓는다면 이보다 편한 것도 없다.<br>그럼 이제 설정을 적당하게 만드는 방법과 Mocha의 설정은 어떻게 하고 어떤 것들이 있는지 확인해보겠다.</p><p><a href="https://kdydesign.github.io/2017/06/19/Mocha-step-07/">Step 07: Options</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 05. 외부 모듈 테스트</title>
      <link href="/2017/06/16/Mocha-step-05/"/>
      <url>/2017/06/16/Mocha-step-05/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>어느 프로그램 언어나 마찮가지겠지만 JavaScript 역시 하나의 <code>.js</code>파일에 코딩하진 않는다. Mocha 역시 하나의 <code>test.js</code> 파일에 모두 테스트 케이스를 적진 않는다.<br>이번 Tutorial에서는 외부 모듈을 불러와서 테스트하는 방법을 알아보겠다. 생각보다 분량이 적지만 매우 효율적인 방법이 될 것이다.</p><hr><h2 id="외부-모듈-생성하기"><a href="#외부-모듈-생성하기" class="headerlink" title="외부 모듈 생성하기"></a>외부 모듈 생성하기</h2><p>앞으로 있을 Tutorial에서는 Mocha를 <code>브라우저에서 구동 방법</code>을 배울 것이다. 이에 앞서 일단 우리는 터미널에서 돌려보도록 하겠다. 일단 간단하게 <code>sum()</code>함수를 만들어 보도록 하자. 명칭 그대로 합계를 내는 함수이다. </p><p>파일명은 <code>ModuleSum</code>이라고 정의해 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sum: <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>매우 간단한 함수이다. 위에서 <code>브라우저에서 구동</code>하는 방법을 배운다는 건 이 부분이 약간 다르기 때문이다. 우리는 <code>ModuleSum</code>을 <code>export</code>하였지만 <code>브라우저 구동</code> 방식에서는 그저 <code>Function</code>만 생성하면 된다. 이미 <code>index.html</code>에서 <code>script</code>를 Import하기 때문이다.</p><h2 id="외부-모듈-불러오기"><a href="#외부-모듈-불러오기" class="headerlink" title="외부 모듈 불러오기"></a>외부 모듈 불러오기</h2><p>이제 외부 모듈인 <code>ModuleSum</code>이 생성되었다. 이 모듈을 불러와서 테스트만 진행하면 끝이다.</p><p><code>test.js</code>파일을 생성하고 코드를 작성하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>),</span><br><span class="line">    moduleSum = <span class="built_in">require</span>(<span class="string">'./ModuleSum'</span>),</span><br><span class="line">    expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'#ModuleSum'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">"sum()"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(moduleSum.sum(<span class="number">1</span>, <span class="number">2</span>)).to.equal(<span class="number">3</span>);</span><br><span class="line">        expect(moduleSum.sum(<span class="number">3</span>, <span class="number">2</span>)).to.equal(<span class="number">5</span>);</span><br><span class="line">        expect(moduleSum.sum(<span class="number">5</span>, <span class="number">0</span>)).to.equal(<span class="number">5</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>실행하여 결과를 확인해 보자.</p><p><img src="result_thumbnail_01.png" alt="result01"></p><p>설명이 별로 필요하지 않는 코드이다. <code>require</code>로 이미 생성한 <code>ModuleSum</code>을 불러오고 적절한 테스트 케이스를 통해 테스트를 진행한다. </p><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step05-Import%20Modules" target="_blank" rel="noopener">예제 코드</a></p><hr><p>사실 이 Tutorial을 쓸까말까 고민했었는데 누군가에게 도움이 되길 바라며 짤막하게 포스팅 해보았다. 다음 Tutorial에서는 아까 언급한 <code>브라우저에서 구동 방법</code>을 진행하도록 하겠다.</p><p><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-06/">Step 06: 브라우저에서의 Mocha 지원</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 04. 동기/비동기 처리</title>
      <link href="/2017/06/16/Mocha-step-04/"/>
      <url>/2017/06/16/Mocha-step-04/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>Mocha에서의 비동기 처리는 매우 간단 명료하다. 어떻게 보면 <code>동기 처리</code>보다 더욱 간단하다.</p><hr><h2 id="동기-처리"><a href="#동기-처리" class="headerlink" title="동기 처리"></a>동기 처리</h2><p><code>비동기 처리</code>에서 시작하기 앞서 <code>동기 처리</code>를 먼저 보겠다. 일반적으로 우리가 Mocha를 사용하는 것은 <code>동기 방식</code>이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>),</span><br><span class="line">    expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'값이 일치하지 않는 경우 -1을 return 한다.'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">5</span>)).to.equal(<span class="number">-1</span>);</span><br><span class="line">        expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">3</span>)).to.equal(<span class="number">2</span>);</span><br><span class="line">        expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">0</span>)).to.equal(<span class="number">-1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>동기 처리</code>에는 콜백이 없으며, 이 콜백을 생략하면 Mocha는 자동으로 다음 테스틀 계속 진행하도록 되어있다.</p><h2 id="비동기-처리"><a href="#비동기-처리" class="headerlink" title="비동기 처리"></a>비동기 처리</h2><p><code>비동기 처리</code>는 그저 콜백을 호출하기만 하면 된다. 콜백(일반적으로 <code>done()</code>이라 함.)을 추가함으로써 테스트(<code>it()</code> 또는 <code>test()</code>)가 완료하기 위해 이 함수가 호출될 때까지 기다리게 된다.</p><p>코드를 보도록 하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>),</span><br><span class="line">    expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//비동기</span></span><br><span class="line">    it(<span class="string">'setTimeout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">5</span>)).to.equal(<span class="number">-1</span>);</span><br><span class="line">            expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">3</span>)).to.equal(<span class="number">2</span>);</span><br><span class="line">            expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">0</span>)).to.equal(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            done();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="result_thumbnail_01.png" alt="result01"></p><p><code>setTimeout</code> 함수로 인해 1초 뒤에 실행되도록 되어있다. 여기서 <code>done()</code>을 호출을 하였기에 테스트가 종료되었다는 것을 알 수 있다. 만약 <code>done()</code> 호출이 없다면 오류를 발생하게 되어있다. 또한 기본 <code>timeout</code>인 <code>2000ms</code>가 지나가도 실패하게 되어있다.</p><p><img src="result_thumbnail_02.png" alt="result02"></p><h2 id="Hooks에서의-비동기-처리"><a href="#Hooks에서의-비동기-처리" class="headerlink" title="Hooks에서의 비동기 처리"></a>Hooks에서의 비동기 처리</h2><p>우리는 이전 Tutorial인 <a href="https://kdydesign.github.io/2017/06/16/Mocha-step-03/">Step 03: Hooks</a>에서 전/후 처리에 대한 <code>Hooks</code>를 알아보았다. 이 <code>Hooks</code>에도 동일하게 <code>done()</code>을 콜백하여 <code>비동기 처리</code>를 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>),</span><br><span class="line">    expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">            done();</span><br><span class="line">        &#125;, <span class="number">1500</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        arr = [];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'Asynchronous Hooks'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(arr.indexOf(<span class="number">5</span>)).to.equal(<span class="number">-1</span>);</span><br><span class="line">        expect(arr.indexOf(<span class="number">3</span>)).to.equal(<span class="number">2</span>);</span><br><span class="line">        expect(arr.indexOf(<span class="number">0</span>)).to.equal(<span class="number">-1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 코드를 보면 <code>beforeEach()</code>에서 1500ms 이후에 <code>arr</code>를 초기화하는 것을 볼 수 있다. 이처럼 <code>비동기 처리</code>는 테스트와 Hooks에 적용이 가능하며, 사용법 마저 매우 쉽다.</p><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step04-Asynchronous" target="_blank" rel="noopener">예제 코드</a></p><hr><p><code>비동기 처리</code>는 반드시 써야 할 경우가 온다. 이와 관련된 내용이 많지는 않지만 프로젝트 상황에 따른 많은 연습이 필요하다고 생각된다.<br>다음 Tutorial에는 외부 모듈을 불러와 사용하는 방법을 배워보도록 하겠다. 어느 개발자든 어느 프로젝트이든 하나의 <code>.js</code>에 모든 코드를 적진 않는다. 그만큼 중요한 내용은 아니지만, 혹시 모를 개발자를 위해~ </p><p><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-05/">Step 05: 외부 모듈 테스트</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> 동기 </tag>
            
            <tag> 비동기 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 03. Hooks</title>
      <link href="/2017/06/16/Mocha-step-03/"/>
      <url>/2017/06/16/Mocha-step-03/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p>이번 Tutorial에서는 Mocha의 <code>Hooks</code>를 알아보겠다. <strong>Mocha에서는 테스트들의 전제 조건과 후 조건을 미리 설정할 수 있는 <code>Hooks</code>를 지원</strong>한다. Mocha에서는 기본적으로 <code>BDD</code> 스타일을 지원하지만 <code>TDD</code> 스타일도 역시 지원하기 때문에 이 두 스타일에 대한 <code>Hooks</code>도 정의할 수 있다.</p><p>먼저 <code>Hooks</code>를 살펴보겠다.</p><hr><h2 id="기본-Hooks"><a href="#기본-Hooks" class="headerlink" title="기본 Hooks"></a>기본 Hooks</h2><p>Mocha의 기본 <code>BDD</code> 스타일의 <code>Hooks</code>는 다음과 같이 정의할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'#Hooks'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// runs before all tests in this block            </span></span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// runs after all tests in this block</span></span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// runs before each test in this block</span></span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// runs after each test in this block</span></span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   it(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// test case </span></span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>간단하다!!.<br>주석을 보면 알겠지만 Mocha에서는 <code>before()</code>, <code>after()</code>, <code>beforeEach()</code>, <code>afterEach()</code> 4가지의 <code>Hooks</code>를 지원한다. 여기서 <code>before()</code>, <code>after()</code>는 테스트 스위트 단위(<code>describe</code>)로 실행된다. <code>before()</code>는 각 테스트 스위트가 실행되기 전에 실행하고 <code>after()</code>는 각 테스트 스위트가 종료되고 실행된다.<br><code>beforeEach()</code>, <code>afterEach()</code>는 어떨까? 이 두개의 <code>Hooks</code>는 테스트 스위트가 아닌 테스트 케이스 단위(<code>it</code>)로 실행된다. <code>beforeEach()</code>는 각 테스트 케이스가 실행하기 전에 실행되고  <code>afterEach()</code> 반대로 테스트 케이스가 종료 후에 실행된다.</p><h2 id="Hooks-실행-순서"><a href="#Hooks-실행-순서" class="headerlink" title="Hooks 실행 순서"></a>Hooks 실행 순서</h2><p>이 <code>Hooks</code>들은 적절하게 정의 된 순서대로 실행된다.<br>모든 <code>before()</code> Hooks가 한 번 실행한 후 모든 <code>beforeEach()</code> Hooks와 테스트 케이스(<code>it</code>)가 실행된다. 이후 모든 <code>afterEach()</code> Hooks를 실행하고 마지막으로 <code>after()</code> Hooks를 한 번 실행하게 된다.</p><p>아래 코드를 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'#Hooks'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'beforeEach'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'afterEach'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'test case #1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'test case #1'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'test case #2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'test case #2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>해당 코드를 실행하게 되면 초기에 <code>before()</code>이 실행이 되고 이후 <code>beforeEach()</code> 그리고 테스트 케이스(<code>it</code>)이 실행된다. 그리고 테스트 케이스(<code>it</code>)이 종료되면 <code>afterEach()</code>가 실행되고 또 다시 테스트 케이스(<code>it</code>)을 위해 반복적으로 <code>beforeEach()</code>와 <code>afterEach()</code>가 실행되며, 마지막으로 <code>after()</code>가 실행되는 것을 볼 수 있다.</p><p><img src="result_thumbnail_01.png" alt="result01"></p><h2 id="Hooks-설명"><a href="#Hooks-설명" class="headerlink" title="Hooks 설명"></a>Hooks 설명</h2><p>어떤 <code>Hooks</code>는 특정 설명과 함께 호출 할 수 있으므로 테스트에서 오류를 쉽게 찾아 낼 수 있다. 또한 <code>Hooks</code>에 특정 명칭을 가진 함수가 주어지면 그 명칭을 사용하게 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'#Describing Hooks'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// beforeEach hook</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span> <span class="title">namedFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// beforeEach:namedFun</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="string">'some description'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// beforeEach:some description</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Hooks로-보는-BDD와-TDD"><a href="#Hooks로-보는-BDD와-TDD" class="headerlink" title="Hooks로 보는 BDD와 TDD"></a>Hooks로 보는 BDD와 TDD</h2><p><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>부터 강조했던 점은 Mocha는 <code>TDD</code>와 <code>BDD</code> 스타일을 각각 지원한다고 하였다. 그 차이가 무엇인지 <code>Hooks</code>를 통해 알아보겠다.</p><p>단순히 <code>TDD</code>와 <code>BDD</code>는 코딩의 스타일이 아닌 하나의 애자일 소프트웨어 개발 방법론에서 가장 널리 쓰이는 테스트 방법론이다. <code>TDD</code>는 테스트 주도 개발(<code>Test-Driven-Devenlopment</code>)이며, <code>BDD</code>는 <code>TDD</code>를 근간으로 파생된 행위 주도 개발(<code>Befavior-Driven-Development</code>)이다. 이런 복잡하고 학습 곡선이 긴 내용은 이 Tutorial에서는 넘어가도록 하겠다.</p><div class="alert warning"><p>오직 이 Tutorial에서는 다루는 내용은 Mocha에서의 TDD와 BDD스타일 입니다.</p></div><p>우리가 이 Tutorial에서 배운 것은 Mocha는 기본적으로 <code>BDD</code> 스타일을 우선순위로 지원한다고 하였다. 그리고 4가지의 <code>Hooks</code>인 <code>before()</code>, <code>after()</code>, <code>beforeEach()</code>, <code>afterEach()</code> 이다. <code>TDD</code>는 4가지의 <code>Hooks</code>의 명칭이 다릅니다. <code>suiteSetup()</code>, <code>suiteTeardown()</code>, <code>setup()</code>, <code>teardown()</code> 이렇게 된다. 또한 <code>BDD</code>에서의 <code>describe()</code>는 <code>suite()</code>로, <code>it()</code>은 <code>test()</code>로 표현한다.</p><p><code>TDD</code> 스타일을 직접 코드로 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">suite(<span class="string">'#Hooks'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   suiteSetup(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// runs before all tests in this block            </span></span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   suiteTeardown(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// runs after all tests in this block</span></span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   setup(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// runs before each test in this block</span></span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   teardown(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// runs after each test in this block</span></span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   test(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// test case </span></span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>우리가 처음 <code>Hooks</code>를 시작할 때 작성했던 코드와 비교하면 어떤 부분이 다른지 알 수 있다. 그저 관점의 차이라고 볼 수 있겠다. 여기서 중요한 건 코딩의 스타일도 있겠지만 <code>TDD</code> 스타일을 사용하기 위해서는 Mocha의 옵션을 지정을 해줘야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha test --ui tdd 또는 -u tdd</span><br></pre></td></tr></table></figure><p><code>--ui</code> 또는 <code>-u</code>의 옵션을 통해 우리가 Mocha의 어떤 스타일을 사용할 것인지 명시를 해줘야 한다.</p><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step03-Hooks" target="_blank" rel="noopener">예제 코드</a></p><hr><p><code>Hooks</code>는 용이하게 사용할 수 있다. 예를 들어 테스트 케이스 필요한 <code>Book</code>이라는 객체를 생성한다고 하였을 때 우리는 <code>var book = new Book()</code>을 테스트 케이스마다 만들 것이다. 하지만 우리는 지금까지 배운 <code>Hooks</code>를 통해 한 번에 객체를 만들고 <code>destroy</code>까지 완벽하게 끝낼 수 있다.<br>이제 <code>Hooks</code>를 배웠으니 다음 Tutorial에서는 <code>비동기 처리</code>에 대한 방법을 배워보고 <code>Hooks</code>에도 <code>비동기 처리</code>를 적용하는 방법을 배워보겠다.</p><p><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-04/">Step 04: 비동기 처리</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> hooks </tag>
            
            <tag> BDD </tag>
            
            <tag> TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 02. Chai</title>
      <link href="/2017/06/15/Mocha-step-02/"/>
      <url>/2017/06/15/Mocha-step-02/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><p><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>에서는 기본적인 Mocha 사용법에 대해 알아보았다.<br>이번 Step 02에서는 <a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>에서 언급한 <code>Assertion</code> library에 대해 어떻게 사용하는지와 어떤 것인지를 알아보도록 하자.</p><hr><h2 id="Chai"><a href="#Chai" class="headerlink" title="Chai"></a>Chai</h2><div class="figure center" style="width:;"><a class="fancybox" href="chai_logo.png" title data-fancybox-group="chai"><img class="fig-img" src="chai_logo.png" alt></a></div><div style="clear:both;"></div><p><a href="https://mochajs.org/" target="_blank" rel="noopener">mochjs.org</a>에서 리스팅 된 <code>Assertion</code>에는 <code>Should.js</code>, <code>expect.js</code>, Chai, <code>better-assert</code>, <code>unexpected</code> 가 있다. 이 중 어떤 <code>Assertion</code>를 사용하는지는 사용자의 판단에 있다. 궁극적으로는 같은 목적을 가지기 때문에 어떤 스타일을 선호하냐는 것에 따라 나뉠 수 있다.<br>대게 Mocha는 Chai와 같이 사용되며, <a href="https://npmcompare.com/compare/chai,expect,should" target="_blank" rel="noopener">NPM COMAPRE</a>를 참고로 보았을 때도 Chai가 다른 <code>Assertion</code> 보다 선호하는 것을 볼 수 있다.</p><p>먼저 Chai는 Node.js 기반의 <code>Assertion</code> library로 <code>BDD</code>와 <code>TDD</code> 스타일을 지원하고 있으며, 지원하는 아래와 같은 인터페이스를 지원한다.</p><div class="alert info"><p><strong>Should</strong><br><strong>Expect</strong><br><strong>Assert</strong></p></div><h2 id="Chai-설치하기"><a href="#Chai-설치하기" class="headerlink" title="Chai 설치하기"></a>Chai 설치하기</h2><p>먼저 <code>npm</code>을 통해 Chai를 설치해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i chai --save-dev</span><br></pre></td></tr></table></figure><p>매우 쉽다. :)<br>너무 간단해서 <code>Chai 설치하기.</code> 란 부제를 지워버리고 싶을 정도지만 그래도 Tutorial이니 삭제하지는 않겠다.</p><h2 id="Chai-사용하기"><a href="#Chai-사용하기" class="headerlink" title="Chai 사용하기."></a>Chai 사용하기.</h2><p>우리는 이제 Chai까지 설치를 하였다. 이렇게 설치한 Chai를 불러와서 사용하기만 하면 된다. <a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a>에서 이미 <code>test.js</code>파일을 생성했으니 새롭게 <code>test-chai.js</code>라는 파일을 생성해보자. 아니면 그대로 사용해도 된다. 그리고 아래처럼 코드를 입력해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"><span class="keyword">var</span> assert = chai.assert;</span><br><span class="line"><span class="keyword">var</span> should = chai.should();</span><br></pre></td></tr></table></figure><p><code>require</code>를 통해 Chai 모듈을 사용하기로 한다. 그런데 그 아래를 보니 <code>expect</code>, <code>assert</code>, <code>should</code>가 체이닝을 통해 불러왔다. 위에서 먼저 설명을 했지만 Chai는 이 스타일들을 지원하기 때문에 사용할 수가 있는 것이다. 굳이 저 3개를 모두 사용할 필요는 없다. 어떤 것을 사용해야 하는지 모르겠다면 각각의 API를 보고 마음에 드는 것을 사용하기로 하자. 왜냐하면 <code>Assertion</code>이기 때문이다. (내 생각..)<br>이제 테스트 스위트를 작성해보자.</p><h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"><span class="keyword">var</span> assert = chai.assert;</span><br><span class="line"><span class="keyword">var</span> should = chai.should();</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'#Expect Test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'expect - Array'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        expect(arr).to.have.lengthOf(<span class="number">5</span>);                        <span class="comment">//array length</span></span><br><span class="line">        expect(arr).to.be.not.empty;                            <span class="comment">//empty</span></span><br><span class="line">        expect(arr).to.have.ordered.members([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]);   <span class="comment">//arr === members</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>간단하다. 바로 실행해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha test-chai.js</span><br></pre></td></tr></table></figure><p><img src="result_thumbnail_01.png" alt="result01"></p><p>정상적으로 출력이 되는 것을 확인할 수 있다.</p><p>위 예제는 <code>expect</code>를 사용한 코드이다. <code>expect</code>는 <code>BDD Style</code>의 인터페이스이며, 자연어에 가까운 <code>Assertion</code>이다. 아직 감이 오지 않을 수도 있다. 다른 코드를 보고 감을 잡아보자.<br>위 코드에 이어서 코딩하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'expect - String'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'Awesome!!'</span>;</span><br><span class="line">    </span><br><span class="line">    expect(str).to.be.a(<span class="string">'String'</span>);                  <span class="comment">//str type</span></span><br><span class="line">    expect(str).to.equal(<span class="string">'Awesome!!'</span>);              <span class="comment">//str === 'Awesome!!'</span></span><br><span class="line">    expect(str).to.have.lengthOf(<span class="number">7</span>, <span class="string">'Why fail?'</span>);   <span class="comment">//Error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'expect - Object'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        assertion: [<span class="string">'assert'</span>, <span class="string">'expect'</span>, <span class="string">'should'</span>],</span><br><span class="line">        framework: <span class="string">'mocha'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    expect(obj).to.have.property(<span class="string">'assertion'</span>).with.lengthOf(<span class="number">3</span>);     <span class="comment">//assertion value length</span></span><br><span class="line">    expect(obj).to.have.all.keys(<span class="string">'framework'</span>, <span class="string">'assertion'</span>);         <span class="comment">//obj key === keys</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 예제에서 주목할 만한 곳은 아래 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(str).to.have.lengthOf(<span class="number">7</span>, <span class="string">'Why fail?'</span>);</span><br></pre></td></tr></table></figure><p><code>expect</code>는 임의의 실패한 <code>assertion</code> 앞에 메시지를 포함할 수 있다. 예제를 실행해 보면 아래와 같이 실패한 결과에 메시지가 출력되는 것을 볼 수 있다.</p><p><img src="result_thumbnail_02.png" alt="result02"></p><p>처음 접할 때는 다소 생소할 수 있다. 하지만 걱정하지 않아도 된다. 잘 정리된 <a href="http://chaijs.com/api/bdd/" target="_blank" rel="noopener">expect API</a>가 있으니까 말이다.<br><code>expect api</code>에 리스팅 되어 있는 체이닝이다. 이 체이닝은 뒤에 있을 <code>should</code>에서도 같은 방식을 사용하고 있다.</p><blockquote><ul><li>to</li><li>be</li><li>been</li><li>that</li><li>which</li><li>and</li><li>has</li><li>have</li><li>with</li><li>at</li><li>of</li><li>same</li><li>but</li><li>does</li></ul></blockquote><p>코드에 대한 설명은 주석을 참고하자!.</p><h3 id="should"><a href="#should" class="headerlink" title="should"></a>should</h3><p>위에서 언급했지만 <code>should</code>는 <code>expect</code>와 같은 체이닝 방식을 사용한다. <code>should</code>는 <code>IE</code>와 사용할 때 몇 가지의 문제가 있으므로 브라우저 호환성을 알고 있어야 한다.<br>자, 그럼 이제 예제를 통해 <code>should</code>와 <code>expect</code>가 어떻게 같은 체이닝 방식을 사용하는지 확인해 보겠다. 새로운 테스트 스위트 <code>#Should Test</code>를 추가하겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'#Should Test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'should - Array'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        arr.should.have.lengthOf(<span class="number">5</span>);                        <span class="comment">//array length</span></span><br><span class="line">        arr.should.be.not.empty;                            <span class="comment">//empty</span></span><br><span class="line">        arr.should.have.ordered.members([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]);   <span class="comment">//arr === members</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'should - String'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">'Awesome!!'</span>;</span><br><span class="line"></span><br><span class="line">        str.should.be.a(<span class="string">'String'</span>);                  <span class="comment">//str type</span></span><br><span class="line">        str.should.equal(<span class="string">'Awesome!!'</span>);              <span class="comment">//str === 'Awesome!!'</span></span><br><span class="line">        str.should.have.lengthOf(<span class="number">7</span>, <span class="string">'Why fail?'</span>);   <span class="comment">//Error</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'should - Object'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;</span><br><span class="line">            assertion: [<span class="string">'assert'</span>, <span class="string">'expect'</span>, <span class="string">'should'</span>],</span><br><span class="line">            framework: <span class="string">'mocha'</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        obj.should.have.property(<span class="string">'assertion'</span>).with.lengthOf(<span class="number">3</span>);     <span class="comment">//assertion value length</span></span><br><span class="line">        obj.should.have.all.keys(<span class="string">'framework'</span>, <span class="string">'assertion'</span>);         <span class="comment">//obj key === keys</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>결과는 <code>expect</code>와 같음을 알 수 있다. 두 코드를 비교해 보면 어느 부분이 다른지 명확하게 보인다. 거의 다른 부분이 없다. 그럼 <code>expect</code>와 <code>should</code>가 다른 점이 무엇일까?</p><h4 id="expect와-should의-차이"><a href="#expect와-should의-차이" class="headerlink" title="expect와 should의 차이"></a>expect와 should의 차이</h4><p>우리가 처음 Chai를 설치하고 <code>test-chai.js</code>만들고 이렇게 코딩하였다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"><span class="keyword">var</span> assert = chai.assert;</span><br><span class="line"><span class="keyword">var</span> should = chai.should();</span><br></pre></td></tr></table></figure><p><code>()</code>가 있고 없고의 차이이다… 굳이 풀이하자면 이렇다.</p><div class="alert info"><p><em><strong>expect</strong>는 함수에 대한 참조일 뿐이고 <strong>should</strong>는 함수가 실행되고 있음</em></p></div><h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p><code>assert</code>는 <code>Node.js</code>에서 제공하는 <code>assert</code>의 표기법을 제공한다. 하지만 이 Chai의 <code>assert</code>가 좀 더 풍부한 표현을 제공하고 있다.<br><code>assert</code>는 간단한 예제만으로 넘어가도록 하겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'#Assert Test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'assert - Array'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">'Awesome!!'</span>;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;</span><br><span class="line">            assertion: [<span class="string">'assert'</span>, <span class="string">'expect'</span>, <span class="string">'should'</span>],</span><br><span class="line">            framework: <span class="string">'mocha'</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        assert.equal(str, <span class="string">'Awesome!!'</span>);         <span class="comment">//str === 'Awesome!!'</span></span><br><span class="line">        assert.typeOf(str, <span class="string">'String'</span>);           <span class="comment">//str type</span></span><br><span class="line">        assert.lengthOf(obj.assertion, <span class="number">3</span>);      <span class="comment">//assertion value length</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step02-chai" target="_blank" rel="noopener">예제 코드</a></p><hr><p>Mocha를 사용하다 보면 처음에 이 <code>Assertion</code>에 대해 다소 낯선 기분이 들 수도 있다. 하지만 걱정 할 필요가 없다. <a href="http://chaijs.com/api/bdd/" target="_blank" rel="noopener">API</a>에서 모든 것을 확인하고 테스트해 볼 수 있기 때문이다.<br>이제 Chai 사용법에 대해 알아 보았다. 기본적인 Mocha를 모두 터득한 것이다. 지금까지 배운 것만으로도 쉽지는 않겠지만 그럴싸한 단위 테스트를 진행할 수 있다.<br>다음 Tutorial에서는 <code>Hooks</code>와 Mocha에서 <code>BDD</code>, <code>TDD</code>의 다른점을 알아보겠다.</p><p><a href="https://kdydesign.github.io/2017/06/16/Mocha-step-03/">Step 03: Hooks</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> Assertion </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> chai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mocha Tutorial - Step 01. Hello World!</title>
      <link href="/2017/06/15/Mocha-step-01/"/>
      <url>/2017/06/15/Mocha-step-01/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>새로운 기술. 프로그램 언어를 입력할 때에는 항상 나타나는 <em>Hello World</em>. Mocha의 가장 기초 코드와는 거리가 멀지만 그래도 <em>Hello World</em>를 고집해 보겠다. <a href="https://kdydesign.github.io/2017/06/08/Mocha/">JavaScript 단위 테스트 프레임워크 - Mocha</a>에서 Mocha를 설치하였다.<br>이제 프로젝트에 필요한 기본 폴더를 구성하자. 먼저 <code>Mocha_test</code>라는 폴더를 만들자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ C:\Mocha_test</span><br></pre></td></tr></table></figure><p>해당 폴더에 <code>test.js</code>를 생성하여 아래와 같이 작성하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'#Hello World!'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'입력 값은 Hello World!'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> input = <span class="string">'Hello World!'</span>; <span class="comment">// 입력 값이라고 가정</span></span><br><span class="line"></span><br><span class="line">        assert.equal(<span class="string">'Hello World!'</span>, input);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 코드는 Mocha의 가장 기본 코드이다. Mocha는 <code>describe()</code>와 <code>it()</code>으로 테스트 스위트와 유닛 테스트를 정의하고 실행한다. Mocha는 <code>BDD</code> 스타일을 기본으로 하고 있지만 <code>TDD</code> 스타일도 지원하고 있다. 해당 강좌에서는 위와 같이 <code>BDD</code> 스타일로 작성하도록 하겠다.</p><h2 id="Assertion"><a href="#Assertion" class="headerlink" title="Assertion"></a>Assertion</h2><p>위 코드에서는 Node.js에 내장된 <code>Assetion</code> library를 사용하였지만 Mocha의 장점 중인 하나가 <code>Assertion</code> library와 독립적으로 사용할 수 있다는 것이다. 즉, <strong><em>mocha는 외부 Assertion library와 같이 사용</em></strong>할 수 있다. 아래에는 <a href="https://mochajs.org" target="_blank" rel="noopener">mochajs.org</a>에 리스팅 되어 있는 <code>Assertion</code> library이다.</p><div class="alert info"><p><strong>should.js</strong> - BDD 스타일의 Assertions<br><strong>expect.js</strong> - expect() 스타일의 Assertions<br><strong>chai</strong> - expect(), assert(), should-style의 Assertions<br><strong>better-assert</strong> - C-style 자체 문서화 된 assert()<br><strong>unexpected</strong> - 확장 가능한 BDD Assertion Toolkit</p></div><p>이제 위에서 생성한 <code>test.js</code>를 실행해 보도록 하겠다. 해당 경로에서 Mocha를 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha</span><br></pre></td></tr></table></figure><p>기본적으로 Mocha 실행 시 <code>test.js</code> 파일을 실행한다. 하지만 특정 파일도 실행할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha test.js</span><br></pre></td></tr></table></figure><p><code>1 passing</code>으로 통과되었다는 뜻이다.</p><p><img src="step01_result_thumbnail_01.png" alt="실행 결과01"></p><h2 id="describe"><a href="#describe" class="headerlink" title="describe()"></a>describe()</h2><p>하나의 <code>describe()</code> 안에는 여러 개의 <code>describe()</code>를 가질 수가 있고, <code>it()</code> 역시 여러 개를 가질 수도 있다.<br>예제를 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'#Hello World!'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'입력 값은 Hello World!'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> input = <span class="string">'Hello World!'</span>; <span class="comment">// 입력 값이라고 가정</span></span><br><span class="line"></span><br><span class="line">        assert.equal(<span class="string">'Hello World!'</span>, input);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    describe(<span class="string">'#String Test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        it(<span class="string">'Hello의 문자 개수는 5'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> str = <span class="string">'Hello'</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (str.length == <span class="number">5</span>) &#123;</span><br><span class="line">               assert.ok(<span class="literal">true</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               assert.ok(<span class="literal">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        it(<span class="string">'World는 W 대문자'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> str = <span class="string">'World'</span>;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (str.indexOf(<span class="string">'w'</span>) &gt; <span class="number">-1</span>) &#123;     <span class="comment">//오류 발생</span></span><br><span class="line">               assert.ok(<span class="literal">true</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               assert.ok(<span class="literal">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>#Hello World!</code>의 테스트 스위트는 <code>#String Test</code>라는 테스트 스위트를 가지고 있다. 그리고 <code>#String Test</code>는 두 개의 <code>it()</code>을 가질 수 있는 것을 볼 수 있다.<br>위 예제에서는 오류가 발생하도록 되어있다. 결과를 보도록 하자.</p><p><img src="step01_result_thumbnail_02.png" alt="실행 결과02"></p><p><code>2 passing</code>에 <code>1 failing</code></p><h2 id="NPM으로-실행하기"><a href="#NPM으로-실행하기" class="headerlink" title="NPM으로 실행하기."></a>NPM으로 실행하기.</h2><p>지금까지 우리는 <code>test.js</code>를 <code>$ mocha test.js</code> 또는 <code>$ mocha</code>를 통해 실행했다. 하지만 Mocha 역시 <code>Node.js</code>의 하나의 모듈이기 때문에 <code>npm</code>으로 실행을 할 수 있다. <code>npm</code>을 조금 다뤄보았다면 모두 아는 내용이지만 그래도 <code>-내 맴대로-</code> 포스트를 하겠다.</p><p>처음 <a href="https://kdydesign.github.io/2017/06/08/Mocha/">JavaScript 단위 테스트 프레임워크 - Mocha</a>에서 우리는 Mocha를 설치하기 전에 <code>$ npm init</code>을 통해 <code>package.json</code>을 생성하였다. 생성된 <code>package.json</code> 파일을 보면 <code>scripts</code>라는 항목이 있는데 우리는 이것을 npm으로 실행하면 끝!.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">  </span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "test": "mocha test"</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>결과는 같으며 실행 방식의 차이이다.</p><p><a href="https://github.com/kdydesign/Mocha-Tutorial/tree/master/step01-Hello%20World!" target="_blank" rel="noopener">예제 코드</a></p><hr><p>이것으로 가장 간단한 Mocha의 사용법을 익혔다. 이제 Mocha를 사용하면서 필요한 <code>Assertion</code> library를 사용해 볼 차례이다.</p><p><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-02/">Step 02: Assertion-chai</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
            <tag> Assertion </tag>
            
            <tag> 단위 테스트 </tag>
            
            <tag> assert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 단위 테스트 프레임워크 - Mocha</title>
      <link href="/2017/06/08/Mocha/"/>
      <url>/2017/06/08/Mocha/</url>
      
        <content type="html"><![CDATA[<!-- excerpt --><!-- excerpt --><p><img src="cover.png" alt="cover"></p><h2 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h2><p>기술이 나날히 발전함에 따라 Web Front-End에도 테스트 방법론들을 적용하여 보다 효율적이고 효과적으로 프로젝트를 진행할 수 있다. JavaScript기반의 테스트 프레임워크는 무수히 많다. 그 중 대표적으로 <code>Mocha</code>와 <code>jasmine</code>을 말 할수 있다. 이 두 프레임워크 중 어떤 프레임워크가 더욱 뛰어난지 비교할 수 없다. 그저 어떤 프레임워크를 사용하느냐는 진행하고자하는 프로젝트와 주변 환경의 요소에 따라 다르다. 이번 포스팅에서는 <code>Mocha</code>를 먼저 말하고 싶다.</p><p><code>Mocha</code>는 Node.js 기반의 Javascript 테스트 프레임워크이다. <code>Mocha</code> 공식 페이지에서는 <code>Mocha</code>를 세 단어로 설명하도 있다.</p><blockquote></blockquote><div class="alert info"><p><strong><em>Simple(간단하고), Flexible(유연하며), Fun(재미있는)</em></strong></p></div><p>정말 그런지 확인해보자.</p><h2 id="Mocha-설치하기"><a href="#Mocha-설치하기" class="headerlink" title="Mocha 설치하기"></a>Mocha 설치하기</h2><p><strong>Mocha</strong>를 설치하기 위해서는 먼저 Node.js와 npm이 설치되어 있어야 한다. Node.js와 npm 설치 방법과 개념은 npm과 node.js에 대해서는 <a href="https://kdydesign.github.io/2017/07/15/nodejs-npm-tutorial/">빠르게 배우는 Node.js와 NPM 설치부터 개념잡기</a>포스트를 참고하자.<br>Node.js와 npm을 설치하였다면 적당한 프로젝트 폴더를 생성한다. 여기서는 <code>Mocha_test</code>라고 하겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ C:\Mocha_test</span><br></pre></td></tr></table></figure><p>생성된 경로에 npm 명령어를 통해 <code>package.json</code>을 생성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>이제 <code>package.json</code>이 생성되었으니 본격적으로 <code>mocha</code>를 설치해 보자. <code>mocha</code>를 설치 할 때에는 <code>-g</code> 옵션을 붙혀서 global하게 설치해도 무방하다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mocha --save-dev 또는 npm i -g mocha</span><br></pre></td></tr></table></figure><p><code>--save-dev</code> 옵션을 주었기에 <code>package.json</code>에 <code>devDependencies</code>에서 <code>mocha</code>가 추가된 것을 볼 수 있다.<br><code>mocha</code>가 정상적으로 설치가 되어 있는지 확인하기 위해 다음과 같이 실행해 보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mocha --version 또는 mocha -V</span><br></pre></td></tr></table></figure><p><code>mocha</code>와 관련된 옵션은 <code>mocha -h</code>를 통해 확인 할 수 있다. 이제 <code>mocha</code> 설치까지 끝났으니 본격적으로 <code>mocha</code>를 사용할 때이다. 비교적 Learning Curve가 적어 Tutorial이 적지만 단계별로 진행해 보자.</p><p><a href="https://kdydesign.github.io/2017/06/15/Mocha-step-01/">Step 01: Hello World!</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mocha </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
